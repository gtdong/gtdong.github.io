<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gtdong.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"gitalk","active":true,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="20.并发入门Go 是并发式语言，而不是并行式语言。在讨论 Go 如何处理并发之前，我们必须理解何为并发，以及并发与并行的区别。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go-进阶">
<meta property="og:url" content="https://gtdong.github.io/2021/08/20/Go-2.%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="TsukiBlog">
<meta property="og:description" content="20.并发入门Go 是并发式语言，而不是并行式语言。在讨论 Go 如何处理并发之前，我们必须理解何为并发，以及并发与并行的区别。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/concurrency-parallelism-copy.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232812015-496811664.png">
<meta property="article:published_time" content="2021-08-20T05:05:00.000Z">
<meta property="article:modified_time" content="2022-04-30T16:12:01.095Z">
<meta property="article:author" content="Michaeldong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/concurrency-parallelism-copy.png">


<link rel="canonical" href="https://gtdong.github.io/2021/08/20/Go-2.%E8%BF%9B%E9%98%B6/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gtdong.github.io/2021/08/20/Go-2.%E8%BF%9B%E9%98%B6/","path":"2021/08/20/Go-2.进阶/","title":"Go-进阶"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go-进阶 | TsukiBlog</title>
  




<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TsukiBlog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E5%B9%B6%E5%8F%91%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">20.并发入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">并发是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">并行是什么？并行和并发有何区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%8A%80%E6%9C%AF%E4%B8%8A%E7%9C%8B%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">从技术上看并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%AF%B9%E5%B9%B6%E5%8F%91%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">1.4.</span> <span class="nav-text">Go 对并发的支持</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-Go%E6%90%BA%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">21.Go携程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">Go 协程是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E5%8D%8F%E7%A8%8B%E7%9B%B8%E6%AF%94%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">2.2.</span> <span class="nav-text">Go 协程相比于线程的优势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA-Go-%E5%8D%8F%E7%A8%8B%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">如何启动一个 Go 协程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA-Go-%E5%8D%8F%E7%A8%8B"><span class="nav-number">2.4.</span> <span class="nav-text">启动多个 Go 协程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-%E4%BF%A1%E9%81%93%EF%BC%88channel%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">22. 信道（channel）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E9%81%93%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">什么是信道？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">3.2.</span> <span class="nav-text">信道的声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%BF%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6"><span class="nav-number">3.3.</span> <span class="nav-text">通过信道进行发送和接收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%B8%8E%E6%8E%A5%E6%94%B6%E9%BB%98%E8%AE%A4%E6%98%AF%E9%98%BB%E5%A1%9E%E7%9A%84"><span class="nav-number">3.4.</span> <span class="nav-text">发送与接收默认是阻塞的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E7%9A%84%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.5.</span> <span class="nav-text">信道的代码示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E9%81%93%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.6.</span> <span class="nav-text">信道的另一个示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.7.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E4%BF%A1%E9%81%93"><span class="nav-number">3.8.</span> <span class="nav-text">单向信道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E4%BF%A1%E9%81%93%E5%92%8C%E4%BD%BF%E7%94%A8-for-range-%E9%81%8D%E5%8E%86%E4%BF%A1%E9%81%93"><span class="nav-number">3.9.</span> <span class="nav-text">关闭信道和使用 for range 遍历信道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-%E7%BC%93%E5%86%B2%E4%BF%A1%E9%81%93%E5%92%8C%E5%B7%A5%E4%BD%9C%E6%B1%A0%EF%BC%88Buffered-Channels-and-Worker-Pools%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">23. 缓冲信道和工作池（Buffered Channels and Worker Pools）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%86%B2%E4%BF%A1%E9%81%93%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">什么是缓冲信道？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80"><span class="nav-number">4.2.</span> <span class="nav-text">示例一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C"><span class="nav-number">4.3.</span> <span class="nav-text">示例二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81-1"><span class="nav-number">4.4.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E5%BA%A6-vs-%E5%AE%B9%E9%87%8F"><span class="nav-number">4.5.</span> <span class="nav-text">长度 vs 容量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WaitGroup"><span class="nav-number">4.6.</span> <span class="nav-text">WaitGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.7.</span> <span class="nav-text">工作池的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-Select"><span class="nav-number">5.</span> <span class="nav-text">24. Select</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-select%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">什么是 select？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">5.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">5.3.</span> <span class="nav-text">select 的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="nav-number">5.4.</span> <span class="nav-text">默认情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5"><span class="nav-number">5.5.</span> <span class="nav-text">死锁与默认情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96"><span class="nav-number">5.6.</span> <span class="nav-text">随机选取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%99%E4%B8%8B%E6%88%91%E6%87%82%E4%BA%86%EF%BC%9A%E7%A9%BA-select"><span class="nav-number">5.7.</span> <span class="nav-text">这下我懂了：空 select</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%96%E4%BB%A3%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">26. 结构体取代类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-%E6%94%AF%E6%8C%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">Go 支持面向对象吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%B1%BB"><span class="nav-number">6.2.</span> <span class="nav-text">使用结构体，而非类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-New-%E5%87%BD%E6%95%B0%EF%BC%8C%E8%80%8C%E9%9D%9E%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">使用 New() 函数，而非构造器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-%E7%BB%84%E5%90%88%E5%8F%96%E4%BB%A3%E7%BB%A7%E6%89%BF"><span class="nav-number">7.</span> <span class="nav-text">27. 组合取代继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%90%88"><span class="nav-number">7.1.</span> <span class="nav-text">通过嵌套结构体进行组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%87%E7%89%87%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-number">7.2.</span> <span class="nav-text">结构体切片的嵌套</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#28-%E5%A4%9A%E6%80%81"><span class="nav-number">8.</span> <span class="nav-text">28. 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81"><span class="nav-number">8.1.</span> <span class="nav-text">使用接口实现多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%A2%9E%E6%94%B6%E7%9B%8A%E6%B5%81"><span class="nav-number">8.2.</span> <span class="nav-text">新增收益流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-defer%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">什么是 defer？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">8.4.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E6%96%B9%E6%B3%95"><span class="nav-number">8.5.</span> <span class="nav-text">延迟方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E5%8F%82%E5%8F%96%E5%80%BC%EF%BC%88Arguments-Evaluation%EF%BC%89"><span class="nav-number">8.6.</span> <span class="nav-text">实参取值（Arguments Evaluation）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer-%E6%A0%88"><span class="nav-number">8.7.</span> <span class="nav-text">defer 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8"><span class="nav-number">8.8.</span> <span class="nav-text">defer 的实际应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">9.</span> <span class="nav-text">30. 错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="nav-number">9.1.</span> <span class="nav-text">什么是错误？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="nav-number">9.2.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">9.3.</span> <span class="nav-text">错误类型的表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E9%94%99%E8%AF%AF%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text">从错误获取更多信息的不同方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%AD%E8%A8%80%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">9.4.1.</span> <span class="nav-text">1. 断言底层结构体类型，使用结构体字段获取更多信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%AD%E8%A8%80%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">9.4.2.</span> <span class="nav-text">2. 断言底层结构体类型，调用方法获取更多信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83"><span class="nav-number">9.4.3.</span> <span class="nav-text">3. 直接比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%BF%BD%E7%95%A5%E9%94%99%E8%AF%AF"><span class="nav-number">9.5.</span> <span class="nav-text">不可忽略错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="nav-number">10.</span> <span class="nav-text">31. 自定义错误</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-New-%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="nav-number">10.1.</span> <span class="nav-text">使用 New 函数创建自定义错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Errorf-%E7%BB%99%E9%94%99%E8%AF%AF%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">10.2.</span> <span class="nav-text">使用 Errorf 给错误添加更多信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E6%AE%B5%E6%8F%90%E4%BE%9B%E9%94%99%E8%AF%AF%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">10.3.</span> <span class="nav-text">使用结构体类型和字段提供错误的更多信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E4%BE%9B%E9%94%99%E8%AF%AF%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">10.4.</span> <span class="nav-text">使用结构体类型的方法来提供错误的更多信息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-panic-%E5%92%8C-recover"><span class="nav-number">11.</span> <span class="nav-text">32. panic 和 recover</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-panic%EF%BC%9F"><span class="nav-number">11.1.</span> <span class="nav-text">什么是 panic？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-panic%EF%BC%9F"><span class="nav-number">11.2.</span> <span class="nav-text">什么时候应该使用 panic？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#panic-%E7%A4%BA%E4%BE%8B"><span class="nav-number">11.3.</span> <span class="nav-text">panic 示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E7%94%9F-panic-%E6%97%B6%E7%9A%84-defer"><span class="nav-number">11.4.</span> <span class="nav-text">发生 panic 时的 defer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#recover"><span class="nav-number">11.5.</span> <span class="nav-text">recover</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#panic%EF%BC%8Crecover-%E5%92%8C-Go-%E5%8D%8F%E7%A8%8B"><span class="nav-number">11.6.</span> <span class="nav-text">panic，recover 和 Go 协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6-panic"><span class="nav-number">11.7.</span> <span class="nav-text">运行时 panic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D%E5%90%8E%E8%8E%B7%E5%BE%97%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA"><span class="nav-number">11.8.</span> <span class="nav-text">恢复后获得堆栈跟踪</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91%EF%BC%88%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">12.</span> <span class="nav-text">33. 函数是一等公民（头等函数）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">什么是头等函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">12.2.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">12.3.</span> <span class="nav-text">用户自定义的函数类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.</span> <span class="nav-text">高阶函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%EF%BC%8C%E4%BC%A0%E9%80%92%E7%BB%99%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.1.</span> <span class="nav-text">把函数作为参数，传递给其它函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0"><span class="nav-number">12.4.2.</span> <span class="nav-text">在其它函数中返回函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">12.5.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%A8%E9%80%94"><span class="nav-number">12.6.</span> <span class="nav-text">头等函数的实际用途</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E5%8F%8D%E5%B0%84"><span class="nav-number">13.</span> <span class="nav-text">34. 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="nav-number">13.1.</span> <span class="nav-text">什么是反射？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%A3%80%E6%9F%A5%E5%8F%98%E9%87%8F%EF%BC%8C%E7%A1%AE%E5%AE%9A%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">13.2.</span> <span class="nav-text">为何需要检查变量，确定变量的类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reflect-%E5%8C%85"><span class="nav-number">13.3.</span> <span class="nav-text">reflect 包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reflect-Type-%E5%92%8C-reflect-Value"><span class="nav-number">13.3.1.</span> <span class="nav-text">reflect.Type 和 reflect.Value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#relfect-Kind"><span class="nav-number">13.3.2.</span> <span class="nav-text">relfect.Kind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NumField-%E5%92%8C-Field-%E6%96%B9%E6%B3%95"><span class="nav-number">13.3.3.</span> <span class="nav-text">NumField() 和 Field() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Int-%E5%92%8C-String-%E6%96%B9%E6%B3%95"><span class="nav-number">13.3.4.</span> <span class="nav-text">Int() 和 String() 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="nav-number">13.4.</span> <span class="nav-text">完整的程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%90%97%EF%BC%9F"><span class="nav-number">13.5.</span> <span class="nav-text">我们应该使用反射吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">14.</span> <span class="nav-text">35. 读取文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%88%B0%E5%86%85%E5%AD%98"><span class="nav-number">14.1.</span> <span class="nav-text">将整个文件读取到内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E7%BB%9D%E5%AF%B9%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="nav-number">14.1.1.</span> <span class="nav-text">1. 使用绝对文件路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A0%87%E8%AE%B0%E6%9D%A5%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84"><span class="nav-number">14.1.2.</span> <span class="nav-text">2. 使用命令行标记来传递文件路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B0%86%E6%96%87%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%9C%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">14.1.3.</span> <span class="nav-text">3. 将文件绑定在二进制文件中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">14.2.</span> <span class="nav-text">分块读取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%90%E8%A1%8C%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">14.3.</span> <span class="nav-text">逐行读取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">14.4.</span> <span class="nav-text">将字符串写入文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E8%8A%82%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">14.5.</span> <span class="nav-text">将字节写入文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E7%9A%84%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">14.6.</span> <span class="nav-text">将字符串一行一行的写入文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E5%88%B0%E6%96%87%E4%BB%B6"><span class="nav-number">14.7.</span> <span class="nav-text">追加到文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">14.8.</span> <span class="nav-text">并发写文件</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Michaeldong"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Michaeldong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated">
    <button><i class="fa fa-comment"></i>
      Chat
    </button>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gtdong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gtdong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/gtdong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gtdong.github.io/2021/08/20/Go-2.%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Michaeldong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TsukiBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go-进阶 | TsukiBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go-进阶
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-20 13:05:00" itemprop="dateCreated datePublished" datetime="2021-08-20T13:05:00+08:00">2021-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 00:12:01" itemprop="dateModified" datetime="2022-05-01T00:12:01+08:00">2022-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Go%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">Go语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>93k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:25</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="20-并发入门"><a href="#20-并发入门" class="headerlink" title="20.并发入门"></a>20.并发入门</h1><p><strong>Go 是并发式语言，而不是并行式语言</strong>。在讨论 Go 如何处理并发之前，我们必须理解何为并发，以及并发与并行的区别。</p>
<span id="more"></span>

<h2 id="并发是什么？"><a href="#并发是什么？" class="headerlink" title="并发是什么？"></a>并发是什么？</h2><p>并发是指立即处理多个任务的能力。一个例子就能很好地说明这一点。</p>
<p>我们可以想象一个人正在跑步。假如在他晨跑时，鞋带突然松了。于是他停下来，系一下鞋带，接下来继续跑。这个例子就是典型的并发。这个人能够一下搞定跑步和系鞋带两件事，即立即处理多个任务。</p>
<h2 id="并行是什么？并行和并发有何区别？"><a href="#并行是什么？并行和并发有何区别？" class="headerlink" title="并行是什么？并行和并发有何区别？"></a>并行是什么？并行和并发有何区别？</h2><p>并行是指同时处理多个任务。这听起来和并发差不多，但其实完全不同。</p>
<p>我们同样用这个跑步的例子来帮助理解。假如这个人在慢跑时，还在用他的 iPod 听着音乐。在这里，他是在跑步的同时听音乐，也就是同时处理多个任务。这称之为并行。</p>
<h2 id="从技术上看并发和并行"><a href="#从技术上看并发和并行" class="headerlink" title="从技术上看并发和并行"></a>从技术上看并发和并行</h2><p>通过现实中的例子，我们已经明白了什么是并发，以及并发与并行的区别。作为一名极客，我们接下来从技术的角度来考察并发和并行。😃</p>
<p>假如我们正在编写一个 web 浏览器。这个 web 浏览器有各种组件。其中两个分别是 web 页面的渲染区和从网上下载文件的下载器。假设我们已经构建好了浏览器代码，各个组件也都可以相互独立地运行（通过像 Java 里的线程，或者通过即将介绍的 Go 语言中的 Go 协程来实现）。当浏览器在单核处理器中运行时，处理器会在浏览器的两个组件间进行上下文切换。它可能在一段时间内下载文件，转而又对用户请求的 web 页面进行渲染。这就是并发。并发的进程从不同的时间点开始，分别交替运行。在这里，就是在不同的时间点开始进行下载和渲染，并相互交替运行的。</p>
<p>如果该浏览器在一个多核处理器上运行，此时下载文件的组件和渲染 HTML 的组件可能会在不同的核上同时运行。这称之为并行。</p>
<p><a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/concurrency-parallelism-copy.png"><img src="https://raw.githubusercontent.com/studygolang/gctt-images/master/golang-series/concurrency-parallelism-copy.png" alt="image"></a></p>
<p>并行不一定会加快运行速度，因为并行运行的组件之间可能需要相互通信。在我们浏览器的例子里，当文件下载完成后，应当对用户进行提醒，比如弹出一个窗口。于是，在负责下载的组件和负责渲染用户界面的组件之间，就产生了通信。在并发系统上，这种通信开销很小。但在多核的并行系统上，组件间的通信开销就很高了。所以，并行不一定会加快运行速度！</p>
<h2 id="Go-对并发的支持"><a href="#Go-对并发的支持" class="headerlink" title="Go 对并发的支持"></a>Go 对并发的支持</h2><p>Go 编程语言原生支持并发。Go 使用 Go 协程（Goroutine） 和信道（Channel）来处理并发。在接下来的教程里，我们还会详细介绍它们。</p>
<h1 id="21-Go携程"><a href="#21-Go携程" class="headerlink" title="21.Go携程"></a>21.Go携程</h1><h2 id="Go-协程是什么？"><a href="#Go-协程是什么？" class="headerlink" title="Go 协程是什么？"></a>Go 协程是什么？</h2><p>Go 协程是与其他函数或方法一起并发运行的函数或方法。Go 协程可以看作是轻量级线程。与线程相比，创建一个 Go 协程的成本很小。因此在 Go 应用中，常常会看到有数以千计的 Go 协程并发地运行。</p>
<h2 id="Go-协程相比于线程的优势"><a href="#Go-协程相比于线程的优势" class="headerlink" title="Go 协程相比于线程的优势"></a>Go 协程相比于线程的优势</h2><ul>
<li>相比线程而言，Go 协程的成本极低。堆栈大小只有若干 kb，并且可以根据应用的需求进行增减。而线程必须指定堆栈的大小，其堆栈是固定不变的。</li>
<li>Go 协程会复用（Multiplex）数量更少的 OS 线程。即使程序有数以千计的 Go 协程，也可能只有一个线程。如果该线程中的某一 Go 协程发生了阻塞（比如说等待用户输入），那么系统会再创建一个 OS 线程，并把其余 Go 协程都移动到这个新的 OS 线程。所有这一切都在运行时进行，作为程序员，我们没有直接面临这些复杂的细节，而是有一个简洁的 API 来处理并发。</li>
<li>Go 协程使用信道（Channel）来进行通信。信道用于防止多个协程访问共享内存时发生竞态条件（Race Condition）。信道可以看作是 Go 协程之间通信的管道。我们会在下一教程详细讨论信道。</li>
</ul>
<h2 id="如何启动一个-Go-协程？"><a href="#如何启动一个-Go-协程？" class="headerlink" title="如何启动一个 Go 协程？"></a>如何启动一个 Go 协程？</h2><p>调用函数或者方法时，在前面加上关键字 <code>go</code>，可以让一个新的 Go 协程并发地运行。</p>
<p>让我们创建一个 Go 协程吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 11 行，<code>go hello()</code> 启动了一个新的 Go 协程。现在 <code>hello()</code> 函数与 <code>main()</code> 函数会并发地执行。主函数会运行在一个特有的 Go 协程上，它称为 Go 主协程（Main Goroutine）。</p>
<p><strong>运行一下程序，你会很惊讶！</strong></p>
<p>该程序只会输出文本 <code>main function</code>。我们启动的 Go 协程究竟出现了什么问题？要理解这一切，我们需要理解两个 Go 协程的主要性质。</p>
<ul>
<li><strong>启动一个新的协程时，协程的调用会立即返回。与函数不同，程序控制不会去等待 Go 协程执行完毕。在调用 Go 协程之后，程序控制会立即返回到代码的下一行，忽略该协程的任何返回值。</strong></li>
<li><strong>如果希望运行其他 Go 协程，Go 主协程必须继续运行着。如果 Go 主协程终止，则程序终止，于是其他 Go 协程也不会继续运行。</strong></li>
</ul>
<p>现在你应该能够理解，为何我们的 Go 协程没有运行了吧。在第 11 行调用了 <code>go hello()</code> 之后，程序控制没有等待 <code>hello</code> 协程结束，立即返回到了代码下一行，打印 <code>main function</code>。接着由于没有其他可执行的代码，Go 主协程终止，于是 <code>hello</code> 协程就没有机会运行了。</p>
<p>我们现在修复这个问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 13 行，我们调用了 time 包里的函数 [<code>Sleep</code>]，该函数会休眠执行它的 Go 协程。在这里，我们使 Go 主协程休眠了 1 秒。因此在主协程终止之前，调用 <code>go hello()</code> 就有足够的时间来执行了。该程序首先打印 <code>Hello world goroutine</code>，等待 1 秒钟之后，接着打印 <code>main function</code>。</p>
<p>在 Go 主协程中使用休眠，以便等待其他协程执行完毕，这种方法只是用于理解 Go 协程如何工作的技巧。信道可用于在其他协程结束执行之前，阻塞 Go 主协程。我们会在下一教程中讨论信道。</p>
<h2 id="启动多个-Go-协程"><a href="#启动多个-Go-协程" class="headerlink" title="启动多个 Go 协程"></a>启动多个 Go 协程</h2><p>为了更好地理解 Go 协程，我们再编写一个程序，启动多个 Go 协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numbers</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">250</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alphabets</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;e&#x27;</span>; i++ &#123;</span><br><span class="line">        time.Sleep(<span class="number">400</span> * time.Millisecond)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> numbers()</span><br><span class="line">    <span class="keyword">go</span> alphabets()</span><br><span class="line">    time.Sleep(<span class="number">3000</span> * time.Millisecond)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main terminated&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 21 行和第 22 行，启动了两个 Go 协程。现在，这两个协程并发地运行。<code>numbers</code> 协程首先休眠 250 微秒，接着打印 <code>1</code>，然后再次休眠，打印 <code>2</code>，依此类推，一直到打印 <code>5</code> 结束。<code>alphabete</code> 协程同样打印从 <code>a</code> 到 <code>e</code> 的字母，并且每次有 400 微秒的休眠时间。 Go 主协程启动了 <code>numbers</code> 和 <code>alphabete</code> 两个 Go 协程，休眠了 3000 微秒后终止程序。</p>
<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy1</span> a <span class="number">2</span> <span class="number">3</span> b <span class="number">4</span> c <span class="number">5</span> d e main terminated</span><br></pre></td></tr></table></figure>

<p>程序的运作如下图所示</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232812015-496811664.png"><img src="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232812015-496811664.png" alt="img"></a></p>
<p>第一张蓝色的图表示 <code>numbers</code> 协程，第二张褐红色的图表示 <code>alphabets</code> 协程，第三张绿色的图表示 Go 主协程，而最后一张黑色的图把以上三种协程合并了，表明程序是如何运行的。在每个方框顶部，诸如 <code>0 ms</code> 和 <code>250 ms</code> 这样的字符串表示时间（以微秒为单位）。在每个方框的底部，<code>1</code>、<code>2</code>、<code>3</code> 等表示输出。蓝色方框表示：<code>250 ms</code> 打印出 <code>1</code>，<code>500 ms</code> 打印出 <code>2</code>，依此类推。最后黑色方框的底部的值会是 <code>1 a 2 3 b 4 c 5 d e main terminated</code>，这同样也是整个程序的输出。以上图片非常直观，你可以用它来理解程序是如何运作的。</p>
<h1 id="22-信道（channel）"><a href="#22-信道（channel）" class="headerlink" title="22. 信道（channel）"></a>22. 信道（channel）</h1><h2 id="什么是信道？"><a href="#什么是信道？" class="headerlink" title="什么是信道？"></a>什么是信道？</h2><p>信道可以想像成 Go 协程之间通信的管道。如同管道中的水会从一端流到另一端，通过使用信道，数据也可以从一端发送，在另一端接收。</p>
<h2 id="信道的声明"><a href="#信道的声明" class="headerlink" title="信道的声明"></a>信道的声明</h2><p>所有信道都关联了一个类型。信道只能运输这种类型的数据，而运输其他类型的数据都是非法的。</p>
<p><code>chan T</code> 表示 <code>T</code> 类型的信道。</p>
<p>信道的零值为 <code>nil</code>。信道的零值没有什么用，应该像对 map 和切片所做的那样，用 <code>make</code> 来定义信道。</p>
<p>下面编写代码，声明一个信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel a is nil, going to define it&quot;</span>)</span><br><span class="line">        a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Type of a is %T&quot;</span>, a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于信道的零值为 <code>nil</code>，在第 6 行，信道 <code>a</code> 的值就是 <code>nil</code>。于是，程序执行了 if 语句内的语句，定义了信道 <code>a</code>。程序中 <code>a</code> 是一个 int 类型的信道。该程序会输出：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copychannel a <span class="keyword">is</span> <span class="keyword">nil</span>, going <span class="keyword">to</span> define it  </span><br><span class="line"><span class="keyword">Type</span> <span class="keyword">of</span> a <span class="keyword">is</span> chan int</span><br></pre></td></tr></table></figure>

<p>简短声明通常也是一种定义信道的简洁有效的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copya := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>这一行代码同样定义了一个 int 类型的信道 <code>a</code>。</p>
<h2 id="通过信道进行发送和接收"><a href="#通过信道进行发送和接收" class="headerlink" title="通过信道进行发送和接收"></a>通过信道进行发送和接收</h2><p>如下所示，该语法通过信道发送和接收数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copydata := &lt;- a <span class="comment">// 读取信道 a  </span></span><br><span class="line">a &lt;- data <span class="comment">// 写入信道 a</span></span><br></pre></td></tr></table></figure>

<p>信道旁的箭头方向指定了是发送数据还是接收数据。</p>
<p>在第一行，箭头对于 <code>a</code> 来说是向外指的，因此我们读取了信道 <code>a</code> 的值，并把该值存储到变量 <code>data</code>。</p>
<p>在第二行，箭头指向了 <code>a</code>，因此我们在把数据写入信道 <code>a</code>。</p>
<h2 id="发送与接收默认是阻塞的"><a href="#发送与接收默认是阻塞的" class="headerlink" title="发送与接收默认是阻塞的"></a>发送与接收默认是阻塞的</h2><p>发送与接收默认是阻塞的。这是什么意思？当把数据发送到信道时，程序控制会在发送数据的语句处发生阻塞，直到有其它 Go 协程从信道读取到数据，才会解除阻塞。与此类似，当读取信道的数据时，如果没有其它的协程把数据写入到这个信道，那么读取过程就会一直阻塞着。</p>
<p>信道的这种特性能够帮助 Go 协程之间进行高效的通信，不需要用到其他编程语言常见的显式锁或条件变量。</p>
<h2 id="信道的代码示例"><a href="#信道的代码示例" class="headerlink" title="信道的代码示例"></a>信道的代码示例</h2><p>理论已经够了:)。接下来写点代码，看看协程之间通过信道是怎么通信的吧。</p>
<p>我们其实可以重写上章学习 [Go 协程]时写的程序，现在我们在这里用上信道。</p>
<p>首先引用前面教程里的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是上一篇的代码。我们使用到了休眠，使 Go 主协程等待 hello 协程结束。如果你看不懂，建议你阅读上一教程 [Go 协程]。</p>
<p>我们接下来使用信道来重写上面代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world goroutine&quot;</span>)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> hello(done)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">&quot;main function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序里，我们在第 12 行创建了一个 bool 类型的信道 <code>done</code>，并把 <code>done</code> 作为参数传递给了 <code>hello</code> 协程。在第 14 行，我们通过信道 <code>done</code> 接收数据。这一行代码发生了阻塞，除非有协程向 <code>done</code> 写入数据，否则程序不会跳到下一行代码。于是，这就不需要用以前的 <code>time.Sleep</code> 来阻止 Go 主协程退出了。</p>
<p><code>&lt;-done</code> 这行代码通过协程（译注：原文笔误，信道）<code>done</code> 接收数据，但并没有使用数据或者把数据存储到变量中。这完全是合法的。</p>
<p>现在我们的 Go 主协程发生了阻塞，等待信道 <code>done</code> 发送的数据。该信道作为参数传递给了协程 <code>hello</code>，<code>hello</code> 打印出 <code>Hello world goroutine</code>，接下来向 <code>done</code> 写入数据。当完成写入时，Go 主协程会通过信道 <code>done</code> 接收数据，于是它解除阻塞状态，打印出文本 <code>main function</code>。</p>
<p>该程序输出如下：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyHello world goroutine  </span><br><span class="line">main <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<p>我们稍微修改一下程序，在 <code>hello</code> 协程里加入休眠函数，以便更好地理解阻塞的概念。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;hello go routine is going to sleep&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;hello go routine awake and going to write to done&quot;</span>)</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Main going to call hello go goroutine&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> hello(done)</span><br><span class="line">    &lt;-done</span><br><span class="line">    fmt.Println(<span class="string">&quot;Main received data&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序里，我们向 <code>hello</code> 函数里添加了 4 秒的休眠（第 10 行）。</p>
<p>程序首先会打印 <code>Main going to call hello go goroutine</code>。接着会开启 <code>hello</code> 协程，打印 <code>hello go routine is going to sleep</code>。打印完之后，<code>hello</code> 协程会休眠 4 秒钟，而在这期间，主协程会在 <code>&lt;-done</code> 这一行发生阻塞，等待来自信道 <code>done</code> 的数据。4 秒钟之后，打印 <code>hello go routine awake and going to write to done</code>，接着再打印 <code>Main received data</code>。</p>
<h2 id="信道的另一个示例"><a href="#信道的另一个示例" class="headerlink" title="信道的另一个示例"></a>信道的另一个示例</h2><p>我们再编写一个程序来更好地理解信道。该程序会计算一个数中每一位的平方和与立方和，然后把平方和与立方和相加并打印出来。</p>
<p>例如，如果输出是 123，该程序会如下计算输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copysquares</span> = (<span class="number">1</span> * <span class="number">1</span>) + (<span class="number">2</span> * <span class="number">2</span>) + (<span class="number">3</span> * <span class="number">3</span>) </span><br><span class="line"><span class="attribute">cubes</span> = (<span class="number">1</span> * <span class="number">1</span> * <span class="number">1</span>) + (<span class="number">2</span> * <span class="number">2</span> * <span class="number">2</span>) + (<span class="number">3</span> * <span class="number">3</span> * <span class="number">3</span>) </span><br><span class="line"><span class="attribute">output</span> = squares + cubes = <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>我们会这样去构建程序：在一个单独的 Go 协程计算平方和，而在另一个协程计算立方和，最后在 Go 主协程把平方和与立方和相加。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcSquares</span><span class="params">(number <span class="type">int</span>, squareop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        sum += digit * digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    squareop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCubes</span><span class="params">(number <span class="type">int</span>, cubeop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        sum += digit * digit * digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    cubeop &lt;- sum</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    number := <span class="number">589</span></span><br><span class="line">    sqrch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    cubech := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> calcSquares(number, sqrch)</span><br><span class="line">    <span class="keyword">go</span> calcCubes(number, cubech)</span><br><span class="line">    squares, cubes := &lt;-sqrch, &lt;-cubech</span><br><span class="line">    fmt.Println(<span class="string">&quot;Final output&quot;</span>, squares + cubes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 7 行，函数 <code>calcSquares</code> 计算一个数每位的平方和，并把结果发送给信道 <code>squareop</code>。与此类似，在第 17 行函数 <code>calcCubes</code> 计算一个数每位的立方和，并把结果发送给信道 <code>cubop</code>。</p>
<p>这两个函数分别在单独的协程里运行（第 31 行和第 32 行），每个函数都有传递信道的参数，以便写入数据。Go 主协程会在第 33 行等待两个信道传来的数据。一旦从两个信道接收完数据，数据就会存储在变量 <code>squares</code> 和 <code>cubes</code> 里，然后计算并打印出最后结果。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyFinal</span> output <span class="number">1536</span></span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>使用信道需要考虑的一个重点是死锁。当 Go 协程给一个信道发送数据时，照理说会有其他 Go 协程来接收数据。如果没有的话，程序就会在运行时触发 panic，形成死锁。</p>
<p>同理，当有 Go 协程等着从一个信道接收数据时，我们期望其他的 Go 协程会向该信道写入数据，要不然程序就会触发 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中，我们创建了一个信道 <code>ch</code>，接着在下一行 <code>ch &lt;- 5</code>，我们把 <code>5</code> 发送到这个信道。对于本程序，没有其他的协程从 <code>ch</code> 接收数据。于是程序触发 panic，出现如下运行时错误。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copyfatal error: <span class="attribute">all</span> goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[chan send]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox249677995/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">6</span> +<span class="number">0</span>x80</span><br></pre></td></tr></table></figure>

<h2 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h2><p>我们目前讨论的信道都是双向信道，即通过信道既能发送数据，又能接收数据。其实也可以创建单向信道，这种信道只能发送或者接收数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(sendch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sendch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    sendch := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sendData(sendch)</span><br><span class="line">    fmt.Println(&lt;-sendch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的第 10 行，我们创建了唯送（Send Only）信道 <code>sendch</code>。<code>chan&lt;- int</code> 定义了唯送信道，因为箭头指向了 <code>chan</code>。在第 12 行，我们试图通过唯送信道接收数据，于是编译器报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copymain.<span class="keyword">go</span>:<span class="number">11</span>: invalid operation: &lt;-sendch (receive from send-only <span class="keyword">type</span> <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p><strong>一切都很顺利，只不过一个不能读取数据的唯送信道究竟有什么意义呢？</strong></p>
<p><strong>这就需要用到信道转换（Channel Conversion）了。把一个双向信道转换成唯送信道或者唯收（Receive Only）信道都是行得通的，但是反过来就不行。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(sendch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sendch &lt;- <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    cha1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sendData(cha1)</span><br><span class="line">    fmt.Println(&lt;-cha1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 10 行，我们创建了一个双向信道 <code>cha1</code>。在第 11 行 <code>cha1</code> 作为参数传递给了 <code>sendData</code> 协程。在第 5 行，函数 <code>sendData</code> 里的参数 <code>sendch chan&lt;- int</code> 把 <code>cha1</code> 转换为一个唯送信道。于是该信道在 <code>sendData</code> 协程里是一个唯送信道，而在 Go 主协程里是一个双向信道。该程序最终打印输出 <code>10</code>。</p>
<h2 id="关闭信道和使用-for-range-遍历信道"><a href="#关闭信道和使用-for-range-遍历信道" class="headerlink" title="关闭信道和使用 for range 遍历信道"></a>关闭信道和使用 for range 遍历信道</h2><p>数据发送方可以关闭信道，通知接收方这个信道不再有数据发送过来。</p>
<p>当从信道接收数据时，接收方可以多用一个变量来检查信道是否已经关闭。</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Copyv,</span> ok := &lt;- ch</span><br></pre></td></tr></table></figure>

<p>上面的语句里，如果成功接收信道所发送的数据，那么 <code>ok</code> 等于 true。而如果 <code>ok</code> 等于 false，说明我们试图读取一个关闭的通道。从关闭的信道读取到的值会是该信道类型的零值。例如，当信道是一个 <code>int</code> 类型的信道时，那么从关闭的信道读取的值将会是 <code>0</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(chnl <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        chnl &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(chnl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, ok := &lt;-ch</span><br><span class="line">        <span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received &quot;</span>, v, ok)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的程序中，<code>producer</code> 协程会从 0 到 9 写入信道 <code>chn1</code>，然后关闭该信道。主函数有一个无限的 for 循环（第 16 行），使用变量 <code>ok</code>（第 18 行）检查信道是否已经关闭。如果 <code>ok</code> 等于 false，说明信道已经关闭，于是退出 for 循环。如果 <code>ok</code> 等于 true，会打印出接收到的值和 <code>ok</code> 的值。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CopyReceived  <span class="number">0</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">1</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">2</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">3</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">4</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">5</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">6</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">7</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">8</span> <span class="literal">true</span>  </span><br><span class="line">Received  <span class="number">9</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>for range 循环用于在一个信道关闭之前，从信道接收数据。</p>
<p>接下来我们使用 for range 循环重写上面的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(chnl <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        chnl &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(chnl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received &quot;</span>,v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 16 行，for range 循环从信道 <code>ch</code> 接收数据，直到该信道关闭。一旦关闭了 <code>ch</code>，循环会自动结束。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyReceived</span>  <span class="number">0</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">1</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">2</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">3</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">4</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">5</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">6</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">7</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">8</span>  </span><br><span class="line"><span class="attribute">Received</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用 for range 循环，重写[信道的另一个示例]这一节里面的代码，提高代码的可重用性。</p>
<p>如果你仔细观察这段代码，会发现获得一个数里的每位数的代码在 <code>calcSquares</code> 和 <code>calcCubes</code> 两个函数内重复了。我们将把这段代码抽离出来，放在一个单独的函数里，然后并发地调用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="type">int</span>, dchnl <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        dchnl &lt;- digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(dchnl)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcSquares</span><span class="params">(number <span class="type">int</span>, squareop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    dch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> digits(number, dch)</span><br><span class="line">    <span class="keyword">for</span> digit := <span class="keyword">range</span> dch &#123;</span><br><span class="line">        sum += digit * digit</span><br><span class="line">    &#125;</span><br><span class="line">    squareop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCubes</span><span class="params">(number <span class="type">int</span>, cubeop <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    dch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> digits(number, dch)</span><br><span class="line">    <span class="keyword">for</span> digit := <span class="keyword">range</span> dch &#123;</span><br><span class="line">        sum += digit * digit * digit</span><br><span class="line">    &#125;</span><br><span class="line">    cubeop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    number := <span class="number">589</span></span><br><span class="line">    sqrch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    cubech := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> calcSquares(number, sqrch)</span><br><span class="line">    <span class="keyword">go</span> calcCubes(number, cubech)</span><br><span class="line">    squares, cubes := &lt;-sqrch, &lt;-cubech</span><br><span class="line">    fmt.Println(<span class="string">&quot;Final output&quot;</span>, squares+cubes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序里的 <code>digits</code> 函数，包含了获取一个数的每位数的逻辑，并且 <code>calcSquares</code> 和 <code>calcCubes</code> 两个函数并发地调用了 <code>digits</code>。当计算完数字里面的每一位数时，第 13 行就会关闭信道。<code>calcSquares</code> 和 <code>calcCubes</code> 两个协程使用 for range 循环分别监听了它们的信道，直到该信道关闭。程序的其他地方不变，该程序同样会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyFinal</span> output <span class="number">1536</span></span><br></pre></td></tr></table></figure>

<p>关于信道还有一些其他的概念，比如缓冲信道（Buffered Channel）、工作池（Worker Pool）和 select。我们会在接下来的教程里专门介绍它们</p>
<h1 id="23-缓冲信道和工作池（Buffered-Channels-and-Worker-Pools）"><a href="#23-缓冲信道和工作池（Buffered-Channels-and-Worker-Pools）" class="headerlink" title="23. 缓冲信道和工作池（Buffered Channels and Worker Pools）"></a>23. 缓冲信道和工作池（Buffered Channels and Worker Pools）</h1><h2 id="什么是缓冲信道？"><a href="#什么是缓冲信道？" class="headerlink" title="什么是缓冲信道？"></a>什么是缓冲信道？</h2><p>在[上一教程]里，我们讨论的主要是无缓冲信道。我们在[信道]的教程里详细讨论了，无缓冲信道的发送和接收过程是阻塞的。</p>
<p>我们还可以创建一个有缓冲（Buffer）的信道。只在缓冲已满的情况，才会阻塞向缓冲信道（Buffered Channel）发送数据。同样，只有在缓冲为空的时候，才会阻塞从缓冲信道接收数据。</p>
<p>通过向 <code>make</code> 函数再传递一个表示容量的参数（指定缓冲的大小），可以创建缓冲信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copych := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, capacity)</span><br></pre></td></tr></table></figure>

<p>要让一个信道有缓冲，上面语法中的 <code>capacity</code> 应该大于 0。无缓冲信道的容量默认为 0，因此我们在[上一教程]创建信道时，省略了容量参数。</p>
<p>我们开始编写代码，创建一个缓冲信道。</p>
<h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;naveen&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;paul&quot;</span></span><br><span class="line">    fmt.Println(&lt;- ch)</span><br><span class="line">    fmt.Println(&lt;- ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序里的第 9 行，我们创建了一个缓冲信道，其容量为 2。由于该信道的容量为 2，因此可向它写入两个字符串，而且不会发生阻塞。在第 10 行和第 11 行，我们向信道写入两个字符串，该信道并没有发生阻塞。我们又在第 12 行和第 13 行分别读取了这两个字符串。该程序输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copynaveen  </span></span><br><span class="line"><span class="attribute">paul</span></span><br></pre></td></tr></table></figure>

<h2 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h2><p>我们再看一个缓冲信道的示例，其中有一个并发的 Go 协程来向信道写入数据，而 Go 主协程负责读取数据。该示例帮助我们进一步理解，在向缓冲信道写入数据时，什么时候会发生阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">        fmt.Println(<span class="string">&quot;successfully wrote&quot;</span>, i, <span class="string">&quot;to ch&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> write(ch)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;read value&quot;</span>, v,<span class="string">&quot;from ch&quot;</span>)</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，第 16 行在 Go 主协程中创建了容量为 2 的缓冲信道 <code>ch</code>，而第 17 行把 <code>ch</code> 传递给了 <code>write</code> 协程。接下来 Go 主协程休眠了两秒。在这期间，<code>write</code> 协程在并发地运行。<code>write</code> 协程有一个 for 循环，依次向信道 <code>ch</code> 写入 0～4。而缓冲信道的容量为 2，因此 <code>write</code> 协程里立即会向 <code>ch</code> 写入 0 和 1，接下来发生阻塞，直到 <code>ch</code> 内的值被读取。因此，该程序立即打印出下面两行：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copysuccessfully</span> wrote <span class="number">0</span> to ch  </span><br><span class="line"><span class="attribute">successfully</span> wrote <span class="number">1</span> to ch</span><br></pre></td></tr></table></figure>

<p>打印上面两行之后，<code>write</code> 协程中向 <code>ch</code> 的写入发生了阻塞，直到 <code>ch</code> 有值被读取到。而 Go 主协程休眠了两秒后，才开始读取该信道，因此在休眠期间程序不会打印任何结果。主协程结束休眠后，在第 19 行使用 for range 循环，开始读取信道 <code>ch</code>，打印出了读取到的值后又休眠两秒，这个循环一直到 <code>ch</code> 关闭才结束。所以该程序在两秒后会打印下面两行：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyread</span> value <span class="number">0</span> from ch  </span><br><span class="line"><span class="attribute">successfully</span> wrote <span class="number">2</span> to ch</span><br></pre></td></tr></table></figure>

<p>该过程会一直进行，直到信道读取完所有的值，并在 <code>write</code> 协程中关闭信道。最终输出如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copysuccessfully wrote <span class="number">0</span> <span class="keyword">to</span> ch  </span><br><span class="line">successfully wrote <span class="number">1</span> <span class="keyword">to</span> ch  </span><br><span class="line"><span class="built_in">read</span> value <span class="number">0</span> <span class="keyword">from</span> ch  </span><br><span class="line">successfully wrote <span class="number">2</span> <span class="keyword">to</span> ch  </span><br><span class="line"><span class="built_in">read</span> value <span class="number">1</span> <span class="keyword">from</span> ch  </span><br><span class="line">successfully wrote <span class="number">3</span> <span class="keyword">to</span> ch  </span><br><span class="line"><span class="built_in">read</span> value <span class="number">2</span> <span class="keyword">from</span> ch  </span><br><span class="line">successfully wrote <span class="number">4</span> <span class="keyword">to</span> ch  </span><br><span class="line"><span class="built_in">read</span> value <span class="number">3</span> <span class="keyword">from</span> ch  </span><br><span class="line"><span class="built_in">read</span> value <span class="number">4</span> <span class="keyword">from</span> ch</span><br></pre></td></tr></table></figure>

<h2 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;naveen&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;paul&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;steve&quot;</span></span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序里，我们向容量为 2 的缓冲信道写入 3 个字符串。当在程序控制到达第 3 次写入时（第 11 行），由于它超出了信道的容量，因此这次写入发生了阻塞。现在想要这次写操作能够进行下去，必须要有其它协程来读取这个信道的数据。但在本例中，并没有并发协程来读取这个信道，因此这里会发生<strong>死锁</strong>（deadlock）。程序会在运行时触发 panic，信息如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copyfatal error: <span class="attribute">all</span> goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[chan send]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox274756028/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">11</span> +<span class="number">0</span>x100</span><br></pre></td></tr></table></figure>

<h2 id="长度-vs-容量"><a href="#长度-vs-容量" class="headerlink" title="长度 vs 容量"></a>长度 vs 容量</h2><p>缓冲信道的容量是指信道可以存储的值的数量。我们在使用 <code>make</code> 函数创建缓冲信道的时候会指定容量大小。</p>
<p>缓冲信道的长度是指信道中当前排队的元素个数。</p>
<p>代码可以把一切解释得很清楚。😃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;naveen&quot;</span></span><br><span class="line">    ch &lt;- <span class="string">&quot;paul&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;capacity is&quot;</span>, <span class="built_in">cap</span>(ch))</span><br><span class="line">    fmt.Println(<span class="string">&quot;length is&quot;</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">    fmt.Println(<span class="string">&quot;read value&quot;</span>, &lt;-ch)</span><br><span class="line">    fmt.Println(<span class="string">&quot;new length is&quot;</span>, <span class="built_in">len</span>(ch))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序里，我们创建了一个容量为 3 的信道，于是它可以保存 3 个字符串。接下来，我们分别在第 9 行和第 10 行向信道写入了两个字符串。于是信道有两个字符串排队，因此其长度为 2。在第 13 行，我们又从信道读取了一个字符串。现在该信道内只有一个字符串，因此其长度变为 1。该程序会输出：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copycapacity <span class="built_in">is</span> <span class="number">3</span>  </span><br><span class="line"><span class="built_in">length</span> <span class="built_in">is</span> <span class="number">2</span>  </span><br><span class="line"><span class="built_in">read</span> value naveen  </span><br><span class="line"><span class="built_in">new</span> <span class="built_in">length</span> <span class="built_in">is</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p>在本教程的下一节里，我们会讲到<strong>工作池</strong>（Worker Pools）。而 <code>WaitGroup</code> 用于实现工作池，因此要理解工作池，我们首先需要学习 <code>WaitGroup</code>。</p>
<p><code>WaitGroup</code> 用于等待一批 Go 协程执行结束。程序控制会一直阻塞，直到这些协程全部执行完毕。假设我们有 3 个并发执行的 Go 协程（由 Go 主协程生成）。Go 主协程需要等待这 3 个协程执行结束后，才会终止。这就可以用 <code>WaitGroup</code> 来实现。</p>
<p>理论说完了，我们编写点儿代码吧。😃</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;started Goroutine &quot;</span>, i)</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Goroutine %d ended\n&quot;</span>, i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    no := <span class="number">3</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; no; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> process(i, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;All go routines finished executing&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[WaitGroup]是一个结构体类型，我们在第 18 行创建了 <code>WaitGroup</code> 类型的变量，其初始值为零值。<code>WaitGroup</code> 使用计数器来工作。当我们调用 <code>WaitGroup</code> 的 <code>Add</code> 并传递一个 <code>int</code> 时，<code>WaitGroup</code> 的计数器会加上 <code>Add</code> 的传参。要减少计数器，可以调用 <code>WaitGroup</code> 的 <code>Done()</code> 方法。<code>Wait()</code> 方法会阻塞调用它的 Go 协程，直到计数器变为 0 后才会停止阻塞。</p>
<p>上述程序里，for 循环迭代了 3 次，我们在循环内调用了 <code>wg.Add(1)</code>（第 20 行）。因此计数器变为 3。for 循环同样创建了 3 个 <code>process</code> 协程，然后在第 23 行调用了 <code>wg.Wait()</code>，确保 Go 主协程等待计数器变为 0。在第 13 行，<code>process</code> 协程内调用了 <code>wg.Done</code>，可以让计数器递减。一旦 3 个子协程都执行完毕（即 <code>wg.Done()</code> 调用了 3 次），那么计数器就变为 0，于是主协程会解除阻塞。</p>
<p><strong>在第 21 行里，传递 wg 的地址是很重要的。如果没有传递 wg 的地址，那么每个 Go 协程将会得到一个 WaitGroup 值的拷贝，因而当它们执行结束时，main 函数并不会知道</strong>。</p>
<p>该程序输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copystarted</span> Goroutine  <span class="number">2</span>  </span><br><span class="line"><span class="attribute">started</span> Goroutine  <span class="number">0</span>  </span><br><span class="line"><span class="attribute">started</span> Goroutine  <span class="number">1</span>  </span><br><span class="line"><span class="attribute">Goroutine</span> <span class="number">0</span> ended  </span><br><span class="line"><span class="attribute">Goroutine</span> <span class="number">2</span> ended  </span><br><span class="line"><span class="attribute">Goroutine</span> <span class="number">1</span> ended  </span><br><span class="line"><span class="attribute">All</span> go routines finished executing</span><br></pre></td></tr></table></figure>

<p>由于 Go 协程的执行顺序不一定，因此你的输出可能和我不一样。😃</p>
<h2 id="工作池的实现"><a href="#工作池的实现" class="headerlink" title="工作池的实现"></a>工作池的实现</h2><p>缓冲信道的重要应用之一就是实现[工作池]。</p>
<p>一般而言，工作池就是一组等待任务分配的线程。一旦完成了所分配的任务，这些线程可继续等待任务的分配。</p>
<p>我们会使用缓冲信道来实现工作池。我们工作池的任务是计算所输入数字的每一位的和。例如，如果输入 234，结果会是 9（即 2 + 3 + 4）。向工作池输入的是一列伪随机数。</p>
<p>我们工作池的核心功能如下：</p>
<ul>
<li>创建一个 Go 协程池，监听一个等待作业分配的输入型缓冲信道。</li>
<li>将作业添加到该输入型缓冲信道中。</li>
<li>作业完成后，再将结果写入一个输出型缓冲信道。</li>
<li>从输出型缓冲信道读取并打印结果。</li>
</ul>
<p>我们会逐步编写这个程序，让代码易于理解。</p>
<p>第一步就是创建一个结构体，表示作业和结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copytype Job <span class="keyword">struct</span> &#123;  </span><br><span class="line">    id       <span class="type">int</span></span><br><span class="line">    randomno <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;  </span><br><span class="line">    job         Job</span><br><span class="line">    sumofdigits <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 <code>Job</code> 结构体变量都会有 <code>id</code> 和 <code>randomno</code> 两个字段，<code>randomno</code> 用于计算其每位数之和。</p>
<p>而 <code>Result</code> 结构体有一个 <code>job</code> 字段，表示所对应的作业，还有一个 <code>sumofdigits</code> 字段，表示计算的结果（每位数字之和）。</p>
<p>第二步是分别创建用于接收作业和写入结果的缓冲信道。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyvar jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">10</span>)  </span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>工作协程（Worker Goroutine）会监听缓冲信道 <code>jobs</code> 里更新的作业。一旦工作协程完成了作业，其结果会写入缓冲信道 <code>results</code>。</p>
<p>如下所示，<code>digits</code> 函数的任务实际上就是计算整数的每一位之和，最后返回该结果。为了模拟出 <code>digits</code> 在计算过程中花费了一段时间，我们在函数内添加了两秒的休眠时间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc digits(number <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    no := number</span><br><span class="line">    <span class="keyword">for</span> no != <span class="number">0</span> &#123;</span><br><span class="line">        digit := no % <span class="number">10</span></span><br><span class="line">        sum += digit</span><br><span class="line">        no /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们写一个创建工作协程的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc worker(wg *sync.WaitGroup) &#123;  </span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        output := Result&#123;job, digits(job.randomno)&#125;</span><br><span class="line">        results &lt;- output</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数创建了一个工作者（Worker），读取 <code>jobs</code> 信道的数据，根据当前的 <code>job</code> 和 <code>digits</code> 函数的返回值，创建了一个 <code>Result</code> 结构体变量，然后将结果写入 <code>results</code> 缓冲信道。<code>worker</code> 函数接收了一个 <code>WaitGroup</code> 类型的 <code>wg</code> 作为参数，当所有的 <code>jobs</code> 完成的时候，调用了 <code>Done()</code> 方法。</p>
<p><code>createWorkerPool</code> 函数创建了一个 Go 协程的工作池。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc createWorkerPool(noOfWorkers <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfWorkers; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数的参数是需要创建的工作协程的数量。在创建 Go 协程之前，它调用了 <code>wg.Add(1)</code> 方法，于是 <code>WaitGroup</code> 计数器递增。接下来，我们创建工作协程，并向 <code>worker</code> 函数传递 <code>wg</code> 的地址。创建了需要的工作协程后，函数调用 <code>wg.Wait()</code>，等待所有的 Go 协程执行完毕。所有协程完成执行之后，函数会关闭 <code>results</code> 信道。因为所有协程都已经执行完毕，于是不再需要向 <code>results</code> 信道写入数据了。</p>
<p>现在我们已经有了工作池，我们继续编写一个函数，把作业分配给工作者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc allocate(noOfJobs <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfJobs; i++ &#123;</span><br><span class="line">        randomno := rand.Intn(<span class="number">999</span>)</span><br><span class="line">        job := Job&#123;i, randomno&#125;</span><br><span class="line">        jobs &lt;- job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>allocate</code> 函数接收所需创建的作业数量作为输入参数，生成了最大值为 998 的伪随机数，并使用该随机数创建了 <code>Job</code> 结构体变量。这个函数把 for 循环的计数器 <code>i</code> 作为 id，最后把创建的结构体变量写入 <code>jobs</code> 信道。当写入所有的 <code>job</code> 时，它关闭了 <code>jobs</code> 信道。</p>
<p>下一步是创建一个读取 <code>results</code> 信道和打印输出的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc result(done <span class="keyword">chan</span> <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Job id %d, input random no %d , sum of digits %d\n&quot;</span>, result.job.id, result.job.randomno, result.sumofdigits)</span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>result</code> 函数读取 <code>results</code> 信道，并打印出 <code>job</code> 的 <code>id</code>、输入的随机数、该随机数的每位数之和。<code>result</code> 函数也接受 <code>done</code> 信道作为参数，当打印所有结果时，<code>done</code> 会被写入 true。</p>
<p>现在一切准备充分了。我们继续完成最后一步，在 <code>main()</code> 函数中调用上面所有的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc main() &#123;  </span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    noOfJobs := <span class="number">100</span></span><br><span class="line">    <span class="keyword">go</span> allocate(noOfJobs)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> result(done)</span><br><span class="line">    noOfWorkers := <span class="number">10</span></span><br><span class="line">    createWorkerPool(noOfWorkers)</span><br><span class="line">    &lt;-done</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    diff := endTime.Sub(startTime)</span><br><span class="line">    fmt.Println(<span class="string">&quot;total time taken &quot;</span>, diff.Seconds(), <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先在 <code>main</code> 函数的第 2 行，保存了程序的起始时间，并在最后一行（第 12 行）计算了 <code>endTime</code> 和 <code>startTime</code> 的差值，显示出程序运行的总时间。由于我们想要通过改变协程数量，来做一点基准指标（Benchmark），所以需要这么做。</p>
<p>我们把 <code>noOfJobs</code> 设置为 100，接下来调用了 <code>allocate</code>，向 <code>jobs</code> 信道添加作业。</p>
<p>我们创建了 <code>done</code> 信道，并将其传递给 <code>result</code> 协程。于是该协程会开始打印结果，并在完成打印时发出通知。</p>
<p>通过调用 <code>createWorkerPool</code> 函数，我们最终创建了一个有 10 个协程的工作池。<code>main</code> 函数会监听 <code>done</code> 信道的通知，等待所有结果打印结束。</p>
<p>为了便于参考，下面是整个程序。我还引用了必要的包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;  </span><br><span class="line">    id       <span class="type">int</span></span><br><span class="line">    randomno <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Result <span class="keyword">struct</span> &#123;  </span><br><span class="line">    job         Job</span><br><span class="line">    sumofdigits <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jobs = <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">10</span>)  </span><br><span class="line"><span class="keyword">var</span> results = <span class="built_in">make</span>(<span class="keyword">chan</span> Result, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digits</span><span class="params">(number <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    no := number</span><br><span class="line">    <span class="keyword">for</span> no != <span class="number">0</span> &#123;</span><br><span class="line">        digit := no % <span class="number">10</span></span><br><span class="line">        sum += digit</span><br><span class="line">        no /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        output := Result&#123;job, digits(job.randomno)&#125;</span><br><span class="line">        results &lt;- output</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createWorkerPool</span><span class="params">(noOfWorkers <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfWorkers; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(noOfJobs <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; noOfJobs; i++ &#123;</span><br><span class="line">        randomno := rand.Intn(<span class="number">999</span>)</span><br><span class="line">        job := Job&#123;i, randomno&#125;</span><br><span class="line">        jobs &lt;- job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">result</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Job id %d, input random no %d , sum of digits %d\n&quot;</span>, result.job.id, result.job.randomno, result.sumofdigits)</span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    startTime := time.Now()</span><br><span class="line">    noOfJobs := <span class="number">100</span></span><br><span class="line">    <span class="keyword">go</span> allocate(noOfJobs)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> result(done)</span><br><span class="line">    noOfWorkers := <span class="number">10</span></span><br><span class="line">    createWorkerPool(noOfWorkers)</span><br><span class="line">    &lt;-done</span><br><span class="line">    endTime := time.Now()</span><br><span class="line">    diff := endTime.Sub(startTime)</span><br><span class="line">    fmt.Println(<span class="string">&quot;total time taken &quot;</span>, diff.Seconds(), <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更精确地计算总时间，请在你的本地机器上运行该程序。</p>
<p>该程序输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyJob id 1, <span class="keyword">input</span> random <span class="keyword">no</span> 636, <span class="keyword">sum</span> of digits 15  </span><br><span class="line">Job id 0, <span class="keyword">input</span> random <span class="keyword">no</span> 878, <span class="keyword">sum</span> of digits 23  </span><br><span class="line">Job id 9, <span class="keyword">input</span> random <span class="keyword">no</span> 150, <span class="keyword">sum</span> of digits 6  </span><br><span class="line">...</span><br><span class="line"><span class="keyword">total</span> time taken  20.01081009 seconds</span><br></pre></td></tr></table></figure>

<p>程序总共会打印 100 行，对应着 100 项作业，然后最后会打印一行程序消耗的总时间。你的输出会和我的不同，因为 Go 协程的运行顺序不一定，同样总时间也会因为硬件而不同。在我的例子中，运行程序大约花费了 20 秒。</p>
<p>现在我们把 <code>main</code> 函数里的 <code>noOfWorkers</code> 增加到 20。我们把工作者的数量加倍了。由于工作协程增加了（准确说来是两倍），因此程序花费的总时间会减少（准确说来是一半）。在我的例子里，程序会打印出 10.004364685 秒。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy</span>...</span><br><span class="line"><span class="attribute">total</span> time taken  <span class="number">10</span>.<span class="number">004364685</span> seconds</span><br></pre></td></tr></table></figure>

<p>现在我们可以理解了，随着工作协程数量增加，完成作业的总时间会减少。你们可以练习一下：在 <code>main</code> 函数里修改 <code>noOfJobs</code> 和 <code>noOfWorkers</code> 的值，并试着去分析一下结果。</p>
<h1 id="24-Select"><a href="#24-Select" class="headerlink" title="24. Select"></a>24. Select</h1><h2 id="什么是-select？"><a href="#什么是-select？" class="headerlink" title="什么是 select？"></a>什么是 select？</h2><p><code>select</code> 语句用于在多个发送/接收信道操作中进行选择。<code>select</code> 语句会一直阻塞，直到发送/接收操作准备就绪。如果有多个信道操作准备完毕，<code>select</code> 会随机地选取其中之一执行。该语法与 <code>switch</code> 类似，所不同的是，这里的每个 <code>case</code> 语句都是信道操作。我们好好看一些代码来加深理解吧。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">6</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">&quot;from server1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">    ch &lt;- <span class="string">&quot;from server2&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> server1(output1)</span><br><span class="line">    <span class="keyword">go</span> server2(output2)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">        fmt.Println(s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">        fmt.Println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序里，<code>server1</code> 函数（第 8 行）休眠了 6 秒，接着将文本 <code>from server1</code> 写入信道 <code>ch</code>。而 <code>server2</code> 函数（第 12 行）休眠了 3 秒，然后把 <code>from server2</code> 写入了信道 <code>ch</code>。</p>
<p>而 <code>main</code> 函数在第 20 行和第 21 行，分别调用了 <code>server1</code> 和 <code>server2</code> 两个 Go 协程。</p>
<p>在第 22 行，程序运行到了 <code>select</code> 语句。<code>select</code> 会一直发生阻塞，除非其中有 case 准备就绪。在上述程序里，<code>server1</code> 协程会在 6 秒之后写入 <code>output1</code> 信道，而<code>server2</code> 协程在 3 秒之后就写入了 <code>output2</code> 信道。因此 <code>select</code> 语句会阻塞 3 秒钟，等着 <code>server2</code> 向 <code>output2</code> 信道写入数据。3 秒钟过后，程序会输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyfrom</span> server2</span><br></pre></td></tr></table></figure>

<p>然后程序终止。</p>
<h2 id="select-的应用"><a href="#select-的应用" class="headerlink" title="select 的应用"></a>select 的应用</h2><p>在上面程序中，函数之所以取名为 <code>server1</code> 和 <code>server2</code>，是为了展示 <code>select</code> 的实际应用。</p>
<p>假设我们有一个关键性应用，需要尽快地把输出返回给用户。这个应用的数据库复制并且存储在世界各地的服务器上。假设函数 <code>server1</code> 和 <code>server2</code> 与这样不同区域的两台服务器进行通信。每台服务器的负载和网络时延决定了它的响应时间。我们向两台服务器发送请求，并使用 <code>select</code> 语句等待相应的信道发出响应。<code>select</code> 会选择首先响应的服务器，而忽略其它的响应。使用这种方法，我们可以向多个服务器发送请求，并给用户返回最快的响应了。:）</p>
<h2 id="默认情况"><a href="#默认情况" class="headerlink" title="默认情况"></a>默认情况</h2><p>在没有 case 准备就绪时，可以执行 <code>select</code> 语句中的默认情况（Default Case）。这通常用于防止 <code>select</code> 语句一直阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    time.Sleep(<span class="number">10500</span> * time.Millisecond)</span><br><span class="line">    ch &lt;- <span class="string">&quot;process successful&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> process(ch)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">1000</span> * time.Millisecond)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">            fmt.Println(<span class="string">&quot;received value: &quot;</span>, v)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;no value received&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序中，第 8 行的 <code>process</code> 函数休眠了 10500 毫秒（10.5 秒），接着把 <code>process successful</code> 写入 <code>ch</code> 信道。在程序中的第 15 行，并发地调用了这个函数。</p>
<p>在并发地调用了 <code>process</code> 协程之后，主协程启动了一个无限循环。这个无限循环在每一次迭代开始时，都会先休眠 1000 毫秒（1 秒），然后执行一个 select 操作。在最开始的 10500 毫秒中，由于 <code>process</code> 协程在 10500 毫秒后才会向 <code>ch</code> 信道写入数据，因此 <code>select</code> 语句的第一个 case（即 <code>case v := &lt;-ch:</code>）并未就绪。所以在这期间，程序会执行默认情况，该程序会打印 10 次 <code>no value received</code>。</p>
<p>在 10.5 秒之后，<code>process</code> 协程会在第 10 行向 <code>ch</code> 写入 <code>process successful</code>。现在，就可以执行 <code>select</code> 语句的第一个 case 了，程序会打印 <code>received value: process successful</code>，然后程序终止。该程序会输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyno</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line"><span class="literal">no</span> value received  </span><br><span class="line">received value:  process successful</span><br></pre></td></tr></table></figure>

<h2 id="死锁与默认情况"><a href="#死锁与默认情况" class="headerlink" title="死锁与默认情况"></a>死锁与默认情况</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中，我们在第 4 行创建了一个信道 <code>ch</code>。我们在 <code>select</code> 内部（第 6 行），试图读取信道 <code>ch</code>。由于没有 Go 协程向该信道写入数据，因此 <code>select</code> 语句会一直阻塞，导致死锁。该程序会触发运行时 <code>panic</code>，报错信息如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copyfatal error: <span class="attribute">all</span> goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[chan receive]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox416567824/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">6</span> +<span class="number">0</span>x80</span><br></pre></td></tr></table></figure>

<p>如果存在默认情况，就不会发生死锁，因为在没有其他 case 准备就绪时，会执行默认情况。我们用默认情况重写后，程序如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;default case executed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序会输出：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copydefault <span class="keyword">case</span> executed</span><br></pre></td></tr></table></figure>

<p>如果 <code>select</code> 只含有值为 <code>nil</code> 的信道，也同样会执行默认情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v := &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;received value&quot;</span>, v)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;default case executed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，<code>ch</code> 等于 <code>nil</code>，而我们试图在 <code>select</code> 中读取 <code>ch</code>（第 8 行）。如果没有默认情况，<code>select</code> 会一直阻塞，导致死锁。由于我们在 <code>select</code> 内部加入了默认情况，程序会执行它，并输出：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copydefault <span class="keyword">case</span> executed</span><br></pre></td></tr></table></figure>

<h2 id="随机选取"><a href="#随机选取" class="headerlink" title="随机选取"></a>随机选取</h2><p>当 <code>select</code> 由多个 case 准备就绪时，将会随机地选取其中之一去执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server1</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="string">&quot;from server1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server2</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    ch &lt;- <span class="string">&quot;from server2&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    output1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    output2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> server1(output1)</span><br><span class="line">    <span class="keyword">go</span> server2(output2)</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> s1 := &lt;-output1:</span><br><span class="line">        fmt.Println(s1)</span><br><span class="line">    <span class="keyword">case</span> s2 := &lt;-output2:</span><br><span class="line">        fmt.Println(s2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序里，我们在第 18 行和第 19 行分别调用了 <code>server1</code> 和 <code>server2</code> 两个 Go 协程。接下来，主程序休眠了 1 秒钟（第 20 行）。当程序控制到达第 21 行的 <code>select</code> 语句时，<code>server1</code> 已经把 <code>from server1</code> 写到了 <code>output1</code> 信道上，而 <code>server2</code> 也同样把 <code>from server2</code> 写到了 <code>output2</code> 信道上。因此这个 <code>select</code> 语句中的两种情况都准备好执行了。如果你运行这个程序很多次的话，输出会是 <code>from server1</code> 或者 <code>from server2</code>，这会根据随机选取的结果而变化。</p>
<p>请在你的本地系统上运行这个程序，获得程序的随机结果。因为如果你在 playground 上在线运行的话，它的输出总是一样的，这是由于 playground 不具有随机性所造成的。</p>
<h2 id="这下我懂了：空-select"><a href="#这下我懂了：空-select" class="headerlink" title="这下我懂了：空 select"></a>这下我懂了：空 select</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你认为上面代码会输出什么？</p>
<p>我们已经知道，除非有 case 执行，select 语句就会一直阻塞着。在这里，<code>select</code> 语句没有任何 case，因此它会一直阻塞，导致死锁。该程序会触发 panic，输出如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copyfatal error: <span class="attribute">all</span> goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[select (no cases)]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox299546399/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">4</span> +<span class="number">0</span>x20</span><br></pre></td></tr></table></figure>

<h1 id="26-结构体取代类"><a href="#26-结构体取代类" class="headerlink" title="26. 结构体取代类"></a>26. 结构体取代类</h1><h2 id="Go-支持面向对象吗？"><a href="#Go-支持面向对象吗？" class="headerlink" title="Go 支持面向对象吗？"></a>Go 支持面向对象吗？</h2><p>Go 并不是完全面向对象的编程语言。Go 官网回答了 Go 是否是面向对象语言，摘录如下。</p>
<blockquote>
<p>可以说是，也可以说不是。虽然 Go 有类型和方法，支持面向对象的编程风格，但却没有类型的层次结构。Go 中的“接口”概念提供了一种不同的方法，我们认为它易于使用，也更为普遍。Go 也可以将结构体嵌套使用，这与子类化（Subclassing）类似，但并不完全相同。此外，Go 提供的特性比 C++ 或 Java 更为通用：子类可以由任何类型的数据来定义，甚至是内建类型（如简单的“未装箱的”整型）。这在结构体（类）中没有受到限制。</p>
</blockquote>
<p>在接下来的教程里，我们会讨论如何使用 Go 来实现面向对象编程概念。与其它面向对象语言（如 Java）相比，Go 有很多完全不同的特性。</p>
<h2 id="使用结构体，而非类"><a href="#使用结构体，而非类" class="headerlink" title="使用结构体，而非类"></a>使用结构体，而非类</h2><p>Go 不支持类，而是提供了[结构体]。结构体中可以添加[方法]。这样可以将数据和操作数据的方法绑定在一起，实现与类相似的效果。</p>
<p>为了加深理解，我们来编写一个示例吧。</p>
<p>在示例中，我们创建一个自定义[包]，它帮助我们更好地理解，结构体是如何有效地取代类的。</p>
<p>在你的 Go 工作区创建一个名为 <code>oop</code> 的文件夹。在 <code>opp</code> 中再创建子文件夹 <code>employee</code>。在 <code>employee</code> 内，创建一个名为 <code>employee.go</code> 的文件。</p>
<p>文件夹结构会是这样：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C<span class="function"><span class="title">opyworkspacepath</span> -&gt;</span> <span class="function"><span class="title">oop</span> -&gt;</span> <span class="function"><span class="title">employee</span> -&gt;</span> employee.go</span><br></pre></td></tr></table></figure>

<p>请将 <code>employee.go</code> 里的内容替换为如下所示的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage employee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    FirstName   <span class="type">string</span></span><br><span class="line">    LastName    <span class="type">string</span></span><br><span class="line">    TotalLeaves <span class="type">int</span></span><br><span class="line">    LeavesTaken <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> LeavesRemaining() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s has %d leaves remaining&quot;</span>, e.FirstName, e.LastName, (e.TotalLeaves - e.LeavesTaken))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序里，第 1 行指定了该文件属于 <code>employee</code> 包。而第 7 行声明了一个 <code>Employee</code> 结构体。在第 14 行，结构体 <code>Employee</code> 添加了一个名为 <code>LeavesRemaining</code> 的方法。该方法会计算和显示员工的剩余休假数。于是现在我们有了一个结构体，并绑定了结构体的方法，这与类很相似。</p>
<p>接着在 <code>oop</code> 文件夹里创建一个文件，命名为 <code>main.go</code>。</p>
<p>现在目录结构如下所示：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C<span class="function"><span class="title">opyworkspacepath</span> -&gt;</span> <span class="function"><span class="title">oop</span> -&gt;</span> <span class="function"><span class="title">employee</span> -&gt;</span> employee.go  </span><br><span class="line"><span class="function"><span class="title">workspacepath</span> -&gt;</span> <span class="function"><span class="title">oop</span> -&gt;</span> main.go</span><br></pre></td></tr></table></figure>

<p><code>main.go</code> 的内容如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;oop/employee&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := employee.Employee &#123;</span><br><span class="line">        FirstName: <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">        LastName: <span class="string">&quot;Adolf&quot;</span>,</span><br><span class="line">        TotalLeaves: <span class="number">30</span>,</span><br><span class="line">        LeavesTaken: <span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    e.LeavesRemaining()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在第 3 行引用了 <code>employee</code> 包。在 <code>main()</code>（第 12 行），我们调用了 <code>Employee</code> 的 <code>LeavesRemaining()</code> 方法。</p>
<p>由于有自定义包，这个程序不能在 go playground 上运行。你可以在你的本地运行，在 <code>workspacepath/bin/oop</code> 下输入命令 <code>go install opp</code>，程序会打印输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopySam Adolf has 10 leaves remaining</span><br></pre></td></tr></table></figure>

<h2 id="使用-New-函数，而非构造器"><a href="#使用-New-函数，而非构造器" class="headerlink" title="使用 New() 函数，而非构造器"></a>使用 New() 函数，而非构造器</h2><p>我们上面写的程序看起来没什么问题，但还是有一些细节问题需要注意。我们看看当定义一个零值的 <code>employee</code> 结构体变量时，会发生什么。将 <code>main.go</code> 的内容修改为如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;oop/employee&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> e employee.Employee</span><br><span class="line">    e.LeavesRemaining()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的修改只是创建一个零值的 <code>Employee</code> 结构体变量（第 6 行）。该程序会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyhas 0 leaves remaining</span><br></pre></td></tr></table></figure>

<p>你可以看到，使用 <code>Employee</code> 创建的零值变量没有什么用。它没有合法的姓名，也没有合理的休假细节。</p>
<p>在像 Java 这样的 OOP 语言中，是使用构造器来解决这种问题的。一个合法的对象必须使用参数化的构造器来创建。</p>
<p>Go 并不支持构造器。如果某类型的零值不可用，需要程序员来隐藏该类型，避免从其他包直接访问。程序员应该提供一种名为 <code>NewT(parameters)</code> 的 [函数]，按照要求来初始化 <code>T</code> 类型的变量。按照 Go 的惯例，应该把创建 <code>T</code> 类型变量的函数命名为 <code>NewT(parameters)</code>。这就类似于构造器了。如果一个包只含有一种类型，按照 Go 的惯例，应该把函数命名为 <code>New(parameters)</code>， 而不是 <code>NewT(parameters)</code>。</p>
<p>让我修改一下原先的代码，使得每当创建 <code>employee</code> 的时候，它都是可用的。</p>
<p>首先应该让 <code>Employee</code> 结构体不可引用，然后创建一个 <code>New</code> 函数，用于创建 <code>Employee</code> 结构体变量。在 <code>employee.go</code> 中输入下面代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copypackage employee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName   <span class="type">string</span></span><br><span class="line">    lastName    <span class="type">string</span></span><br><span class="line">    totalLeaves <span class="type">int</span></span><br><span class="line">    leavesTaken <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(firstName <span class="type">string</span>, lastName <span class="type">string</span>, totalLeave <span class="type">int</span>, leavesTaken <span class="type">int</span>)</span></span> employee &#123;  </span><br><span class="line">    e := employee &#123;firstName, lastName, totalLeave, leavesTaken&#125;</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e employee)</span></span> LeavesRemaining() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s has %d leaves remaining&quot;</span>, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进行了一些重要的修改。我们把 <code>Employee</code> 结构体的首字母改为小写 <code>e</code>，也就是将 <code>type Employee struct</code> 改为了 <code>type employee struct</code>。通过这种方法，我们把 <code>employee</code> 结构体变为了不可引用的，防止其他包对它的访问。除非有特殊需求，否则也要隐藏所有不可引用的结构体的所有字段，这是 Go 的最佳实践。由于我们不会在外部包需要 <code>employee</code> 的字段，因此我们也让这些字段无法引用。</p>
<p>同样，我们还修改了 <code>LeavesRemaining()</code> 的方法。</p>
<p>现在由于 <code>employee</code> 不可引用，因此不能在其他包内直接创建 <code>Employee</code> 类型的变量。于是我们在第 14 行提供了一个可引用的 <code>New</code> 函数，该函数接收必要的参数，返回一个新创建的 <code>employee</code> 结构体变量。</p>
<p>这个程序还需要一些必要的修改，但现在先运行这个程序，理解一下当前的修改。如果运行当前程序，编译器会报错，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copygo/src/constructor/main.go:6: undefined: employee.Employee</span><br></pre></td></tr></table></figure>

<p>这是因为我们将 <code>Employee</code> 设置为不可引用，因此编译器会报错，提示该类型没有在 <code>main.go</code> 中定义。很完美，正如我们期望的一样，其他包现在不能轻易创建零值的 <code>employee</code> 变量了。我们成功地避免了创建不可用的 <code>employee</code> 结构体变量。现在创建 <code>employee</code> 变量的唯一方法就是使用 <code>New</code> 函数。</p>
<p>如下所示，修改 <code>main.go</code> 里的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;oop/employee&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := employee.New(<span class="string">&quot;Sam&quot;</span>, <span class="string">&quot;Adolf&quot;</span>, <span class="number">30</span>, <span class="number">20</span>)</span><br><span class="line">    e.LeavesRemaining()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该文件唯一的修改就是第 6 行。通过向 <code>New</code> 函数传入所需变量，我们创建了一个新的 <code>employee</code> 结构体变量。</p>
<p>下面是修改后的两个文件的内容。</p>
<p>employee.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copypackage employee</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName   <span class="type">string</span></span><br><span class="line">    lastName    <span class="type">string</span></span><br><span class="line">    totalLeaves <span class="type">int</span></span><br><span class="line">    leavesTaken <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(firstName <span class="type">string</span>, lastName <span class="type">string</span>, totalLeave <span class="type">int</span>, leavesTaken <span class="type">int</span>)</span></span> employee &#123;  </span><br><span class="line">    e := employee &#123;firstName, lastName, totalLeave, leavesTaken&#125;</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e employee)</span></span> LeavesRemaining() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s has %d leaves remaining&quot;</span>, e.firstName, e.lastName, (e.totalLeaves - e.leavesTaken))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;oop/employee&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := employee.New(<span class="string">&quot;Sam&quot;</span>, <span class="string">&quot;Adolf&quot;</span>, <span class="number">30</span>, <span class="number">20</span>)</span><br><span class="line">    e.LeavesRemaining()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该程序，会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopySam Adolf has 10 leaves remaining</span><br></pre></td></tr></table></figure>

<p>现在你能明白了，虽然 Go 不支持类，但结构体能够很好地取代类，而以 <code>New(parameters)</code> 签名的方法可以替代构造器。</p>
<h1 id="27-组合取代继承"><a href="#27-组合取代继承" class="headerlink" title="27. 组合取代继承"></a>27. 组合取代继承</h1><p>Go 不支持继承，但它支持组合（Composition）。组合一般定义为“合并在一起”。汽车就是一个关于组合的例子：一辆汽车由车轮、引擎和其他各种部件组合在一起。</p>
<h2 id="通过嵌套结构体进行组合"><a href="#通过嵌套结构体进行组合" class="headerlink" title="通过嵌套结构体进行组合"></a>通过嵌套结构体进行组合</h2><p>在 Go 中，通过在结构体内嵌套结构体，可以实现组合。</p>
<p>组合的典型例子就是博客帖子。每一个博客的帖子都有标题、内容和作者信息。使用组合可以很好地表示它们。通过学习本教程后面的内容，我们会知道如何实现组合。</p>
<p>我们首先创建一个 <code>author</code> 结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> author <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName  <span class="type">string</span></span><br><span class="line">    bio       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a author)</span></span> fullName() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s %s&quot;</span>, a.firstName, a.lastName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码片段中，我们创建了一个 <code>author</code> 结构体，<code>author</code> 的字段有 <code>firstname</code>、<code>lastname</code> 和 <code>bio</code>。我们还添加了一个 <code>fullName()</code> 方法，其中 <code>author</code> 作为接收者类型，该方法返回了作者的全名。</p>
<p>下一步我们创建 <code>post</code> 结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copytype post <span class="keyword">struct</span> &#123;  </span><br><span class="line">    title     <span class="type">string</span></span><br><span class="line">    content   <span class="type">string</span></span><br><span class="line">    author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p post)</span></span> details() &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Title: &quot;</span>, p.title)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Content: &quot;</span>, p.content)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Author: &quot;</span>, p.author.fullName())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bio: &quot;</span>, p.author.bio)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>post</code> 结构体的字段有 <code>title</code> 和 <code>content</code>。它还有一个嵌套的匿名字段 <code>author</code>。该字段指定 <code>author</code> 组成了 <code>post</code> 结构体。现在 <code>post</code> 可以访问 <code>author</code> 结构体的所有字段和方法。我们同样给 <code>post</code> 结构体添加了 <code>details()</code> 方法，用于打印标题、内容和作者的全名与简介。</p>
<p>一旦结构体内嵌套了一个结构体字段，Go 可以使我们访问其嵌套的字段，好像这些字段属于外部结构体一样。所以上面第 11 行的 <code>p.author.fullName()</code> 可以替换为 <code>p.fullName()</code>。于是，<code>details()</code> 方法可以重写，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc (p post) details() &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Title: &quot;</span>, p.title)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Content: &quot;</span>, p.content)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Author: &quot;</span>, p.fullName())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bio: &quot;</span>, p.bio)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们的 <code>author</code> 和 <code>post</code> 结构体都已准备就绪，我们来创建一个博客帖子来完成这个程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> author <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName  <span class="type">string</span></span><br><span class="line">    bio       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a author)</span></span> fullName() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s %s&quot;</span>, a.firstName, a.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> post <span class="keyword">struct</span> &#123;  </span><br><span class="line">    title   <span class="type">string</span></span><br><span class="line">    content <span class="type">string</span></span><br><span class="line">    author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p post)</span></span> details() &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Title: &quot;</span>, p.title)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Content: &quot;</span>, p.content)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Author: &quot;</span>, p.fullName())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bio: &quot;</span>, p.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    author1 := author&#123;</span><br><span class="line">        <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Golang Enthusiast&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    post1 := post&#123;</span><br><span class="line">        <span class="string">&quot;Inheritance in Go&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Go supports composition instead of inheritance&quot;</span>,</span><br><span class="line">        author1,</span><br><span class="line">    &#125;</span><br><span class="line">    post1.details()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，main 函数在第 31 行新建了一个 <code>author</code> 结构体变量。而在第 36 行，我们通过嵌套 <code>author1</code> 来创建一个 <code>post</code>。该程序输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyTitle:  Inheritance <span class="keyword">in</span> Go  </span><br><span class="line">Content:  Go supports composition instead of inheritance  </span><br><span class="line">Author:  Naveen Ramanathan  </span><br><span class="line">Bio:  Golang Enthusiast</span><br></pre></td></tr></table></figure>

<h2 id="结构体切片的嵌套"><a href="#结构体切片的嵌套" class="headerlink" title="结构体切片的嵌套"></a>结构体切片的嵌套</h2><p>我们可以进一步处理这个示例，使用博客帖子的切片来创建一个网站。</p>
<p>我们首先定义 <code>website</code> 结构体。请在上述代码里的 main 函数中，添加下面的代码，并运行它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copytype website <span class="keyword">struct</span> &#123;  </span><br><span class="line">        []post</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w website)</span></span> contents() &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Contents of Website\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> w.posts &#123;</span><br><span class="line">        v.details()</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你添加上述代码后，当你运行程序时，编译器将会报错，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copymain.go:31:9: syntax error: unexpected [, expecting field name or embedded <span class="built_in">type</span></span><br></pre></td></tr></table></figure>

<p>这项错误指出了嵌套的结构体切片 <code>[]post</code>。错误的原因是结构体不能嵌套一个匿名切片。我们需要一个字段名。所以我们来修复这个错误，让编译器顺利通过。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copytype website <span class="keyword">struct</span> &#123;  </span><br><span class="line">        posts []post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我给帖子的切片 <code>[]post</code> 添加了字段名 <code>posts</code>。</p>
<p>现在我们来修改主函数，为我们的新网站创建一些帖子吧。</p>
<p>修改后的完整代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> author <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName  <span class="type">string</span></span><br><span class="line">    bio       <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a author)</span></span> fullName() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s %s&quot;</span>, a.firstName, a.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> post <span class="keyword">struct</span> &#123;  </span><br><span class="line">    title   <span class="type">string</span></span><br><span class="line">    content <span class="type">string</span></span><br><span class="line">    author</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p post)</span></span> details() &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Title: &quot;</span>, p.title)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Content: &quot;</span>, p.content)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Author: &quot;</span>, p.fullName())</span><br><span class="line">    fmt.Println(<span class="string">&quot;Bio: &quot;</span>, p.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> website <span class="keyword">struct</span> &#123;  </span><br><span class="line"> posts []post</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w website)</span></span> contents() &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Contents of Website\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> w.posts &#123;</span><br><span class="line">        v.details()</span><br><span class="line">        fmt.Println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    author1 := author&#123;</span><br><span class="line">        <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Golang Enthusiast&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    post1 := post&#123;</span><br><span class="line">        <span class="string">&quot;Inheritance in Go&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Go supports composition instead of inheritance&quot;</span>,</span><br><span class="line">        author1,</span><br><span class="line">    &#125;</span><br><span class="line">    post2 := post&#123;</span><br><span class="line">        <span class="string">&quot;Struct instead of Classes in Go&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Go does not support classes but methods can be added to structs&quot;</span>,</span><br><span class="line">        author1,</span><br><span class="line">    &#125;</span><br><span class="line">    post3 := post&#123;</span><br><span class="line">        <span class="string">&quot;Concurrency&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Go is a concurrent language and not a parallel one&quot;</span>,</span><br><span class="line">        author1,</span><br><span class="line">    &#125;</span><br><span class="line">    w := website&#123;</span><br><span class="line">        posts: []post&#123;post1, post2, post3&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    w.contents()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的主函数中，我们创建了一个作者 <code>author1</code>，以及三个帖子 <code>post1</code>、<code>post2</code> 和 <code>post3</code>。我们最后通过嵌套三个帖子，在第 62 行创建了网站 <code>w</code>，并在下一行显示内容。</p>
<p>程序会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CopyContents of Website</span><br><span class="line"></span><br><span class="line">Title:  Inheritance <span class="keyword">in</span> Go  </span><br><span class="line">Content:  Go supports composition instead of inheritance  </span><br><span class="line">Author:  Naveen Ramanathan  </span><br><span class="line">Bio:  Golang Enthusiast</span><br><span class="line"></span><br><span class="line">Title:  Struct instead of Classes <span class="keyword">in</span> Go  </span><br><span class="line">Content:  Go does not support classes but methods can be added to structs  </span><br><span class="line">Author:  Naveen Ramanathan  </span><br><span class="line">Bio:  Golang Enthusiast</span><br><span class="line"></span><br><span class="line">Title:  Concurrency  </span><br><span class="line">Content:  Go is a concurrent language and not a parallel one  </span><br><span class="line">Author:  Naveen Ramanathan  </span><br><span class="line">Bio:  Golang Enthusiast</span><br></pre></td></tr></table></figure>

<h1 id="28-多态"><a href="#28-多态" class="headerlink" title="28. 多态"></a>28. 多态</h1><p>Go 通过[接口]来实现多态。我们已经讨论过，在 Go 语言中，我们是隐式地实现接口。一个类型如果定义了接口所声明的全部[方法]，那它就实现了该接口。现在我们来看看，利用接口，Go 是如何实现多态的。</p>
<h2 id="使用接口实现多态"><a href="#使用接口实现多态" class="headerlink" title="使用接口实现多态"></a>使用接口实现多态</h2><p>一个类型如果定义了接口的所有方法，那它就隐式地实现了该接口。</p>
<p><strong>所有实现了接口的类型，都可以把它的值保存在一个接口类型的变量中。在 Go 中，我们使用接口的这种特性来实现多态</strong>。</p>
<p>通过一个程序我们来理解 Go 语言的多态，它会计算一个组织机构的净收益。为了简单起见，我们假设这个虚构的组织所获得的收入来源于两个项目：<code>fixed billing</code> 和 <code>time and material</code>。该组织的净收益等于这两个项目的收入总和。同样为了简单起见，我们假设货币单位是美元，而无需处理美分。因此货币只需简单地用 <code>int</code> 来表示。</p>
<p>我们首先定义一个接口 <code>Income</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copytype Income <span class="keyword">interface</span> &#123;  </span><br><span class="line">    calculate() <span class="type">int</span></span><br><span class="line">    source() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了接口 <code>Interface</code>，它包含了两个方法：<code>calculate()</code> 计算并返回项目的收入，而 <code>source()</code> 返回项目名称。</p>
<p>下面我们定义一个表示 <code>FixedBilling</code> 项目的结构体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copytype FixedBilling <span class="keyword">struct</span> &#123;  </span><br><span class="line">    projectName <span class="type">string</span></span><br><span class="line">    biddedAmount <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目 <code>FixedBillin</code> 有两个字段：<code>projectName</code> 表示项目名称，而 <code>biddedAmount</code> 表示组织向该项目投标的金额。</p>
<p><code>TimeAndMaterial</code> 结构体用于表示项目 Time and Material。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copytype TimeAndMaterial <span class="keyword">struct</span> &#123;  </span><br><span class="line">    projectName <span class="type">string</span></span><br><span class="line">    noOfHours  <span class="type">int</span></span><br><span class="line">    hourlyRate <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体 <code>TimeAndMaterial</code> 拥有三个字段名：<code>projectName</code>、<code>noOfHours</code> 和 <code>hourlyRate</code>。</p>
<p>下一步我们给这些结构体类型定义方法，计算并返回实际收入和项目名称。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc (fb FixedBilling) calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fb.biddedAmount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fb FixedBilling)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fb.projectName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeAndMaterial)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> tm.noOfHours * tm.hourlyRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeAndMaterial)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> tm.projectName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目 <code>FixedBilling</code> 里面，收入就是项目的投标金额。因此我们返回 <code>FixedBilling</code> 类型的 <code>calculate()</code> 方法。</p>
<p>而在项目 <code>TimeAndMaterial</code> 里面，收入等于 <code>noOfHours</code> 和 <code>hourlyRate</code> 的乘积，作为 <code>TimeAndMaterial</code> 类型的 <code>calculate()</code> 方法的返回值。</p>
<p>我们还通过 <code>source()</code> 方法返回了表示收入来源的项目名称。</p>
<p>由于 <code>FixedBilling</code> 和 <code>TimeAndMaterial</code> 两个结构体都定义了 <code>Income</code> 接口的两个方法：<code>calculate()</code> 和 <code>source()</code>，因此这两个结构体都实现了 <code>Income</code> 接口。</p>
<p>我们来声明一个 <code>calculateNetIncome</code> 函数，用来计算并打印总收入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc calculateNetIncome(ic []Income) &#123;  </span><br><span class="line">    <span class="keyword">var</span> netincome <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, income := <span class="keyword">range</span> ic &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Income From %s = $%d\n&quot;</span>, income.source(), income.calculate())</span><br><span class="line">        netincome += income.calculate()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Net income of organisation = $%d&quot;</span>, netincome)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的[函数]接收一个 <code>Income</code> 接口类型的[切片]作为参数。该函数会遍历这个接口切片，并依个调用 <code>calculate()</code> 方法，计算出总收入。该函数同样也会通过调用 <code>source()</code> 显示收入来源。根据 <code>Income</code> 接口的具体类型，程序会调用不同的 <code>calculate()</code> 和 <code>source()</code> 方法。于是，我们在 <code>calculateNetIncome</code> 函数中就实现了多态。</p>
<p>如果在该组织以后增加了新的收入来源，<code>calculateNetIncome</code> 无需修改一行代码，就可以正确地计算总收入了。</p>
<p>最后就剩下这个程序的 <code>main</code> 函数了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc main() &#123;  </span><br><span class="line">    project1 := FixedBilling&#123;projectName: <span class="string">&quot;Project 1&quot;</span>, biddedAmount: <span class="number">5000</span>&#125;</span><br><span class="line">    project2 := FixedBilling&#123;projectName: <span class="string">&quot;Project 2&quot;</span>, biddedAmount: <span class="number">10000</span>&#125;</span><br><span class="line">    project3 := TimeAndMaterial&#123;projectName: <span class="string">&quot;Project 3&quot;</span>, noOfHours: <span class="number">160</span>, hourlyRate: <span class="number">25</span>&#125;</span><br><span class="line">    incomeStreams := []Income&#123;project1, project2, project3&#125;</span><br><span class="line">    calculateNetIncome(incomeStreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的 <code>main</code> 函数中，我们创建了三个项目，有两个是 <code>FixedBilling</code> 类型，一个是 <code>TimeAndMaterial</code> 类型。接着我们创建了一个 <code>Income</code> 类型的切片，存放了这三个项目。由于这三个项目都实现了 <code>Interface</code> 接口，因此可以把这三个项目放入 <code>Income</code> 切片。最后我们将该切片作为参数，调用了 <code>calculateNetIncome</code> 函数，显示了项目不同的收益和收入来源。</p>
<p>以下完整的代码供你参考。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Income <span class="keyword">interface</span> &#123;  </span><br><span class="line">    calculate() <span class="type">int</span></span><br><span class="line">    source() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FixedBilling <span class="keyword">struct</span> &#123;  </span><br><span class="line">    projectName <span class="type">string</span></span><br><span class="line">    biddedAmount <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeAndMaterial <span class="keyword">struct</span> &#123;  </span><br><span class="line">    projectName <span class="type">string</span></span><br><span class="line">    noOfHours  <span class="type">int</span></span><br><span class="line">    hourlyRate <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fb FixedBilling)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fb.biddedAmount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fb FixedBilling)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fb.projectName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeAndMaterial)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> tm.noOfHours * tm.hourlyRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeAndMaterial)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> tm.projectName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateNetIncome</span><span class="params">(ic []Income)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> netincome <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, income := <span class="keyword">range</span> ic &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Income From %s = $%d\n&quot;</span>, income.source(), income.calculate())</span><br><span class="line">        netincome += income.calculate()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Net income of organisation = $%d&quot;</span>, netincome)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    project1 := FixedBilling&#123;projectName: <span class="string">&quot;Project 1&quot;</span>, biddedAmount: <span class="number">5000</span>&#125;</span><br><span class="line">    project2 := FixedBilling&#123;projectName: <span class="string">&quot;Project 2&quot;</span>, biddedAmount: <span class="number">10000</span>&#125;</span><br><span class="line">    project3 := TimeAndMaterial&#123;projectName: <span class="string">&quot;Project 3&quot;</span>, noOfHours: <span class="number">160</span>, hourlyRate: <span class="number">25</span>&#125;</span><br><span class="line">    incomeStreams := []Income&#123;project1, project2, project3&#125;</span><br><span class="line">    calculateNetIncome(incomeStreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyIncome</span> From Project <span class="number">1</span> = $<span class="number">5000</span>  </span><br><span class="line"><span class="attribute">Income</span> From Project <span class="number">2</span> = $<span class="number">10000</span>  </span><br><span class="line"><span class="attribute">Income</span> From Project <span class="number">3</span> = $<span class="number">4000</span>  </span><br><span class="line"><span class="attribute">Net</span> income of organisation = $<span class="number">19000</span></span><br></pre></td></tr></table></figure>

<h2 id="新增收益流"><a href="#新增收益流" class="headerlink" title="新增收益流"></a>新增收益流</h2><p>假设前面的组织通过广告业务，建立了一个新的收益流（Income Stream）。我们可以看到添加它非常简单，并且计算总收益也很容易，我们无需对 <code>calculateNetIncome</code> 函数进行任何修改。这就是多态的好处。</p>
<p>我们首先定义 <code>Advertisement</code> 类型，并在 <code>Advertisement</code> 类型中定义 <code>calculate()</code> 和 <code>source()</code> 方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copytype Advertisement <span class="keyword">struct</span> &#123;  </span><br><span class="line">    adName     <span class="type">string</span></span><br><span class="line">    CPC        <span class="type">int</span></span><br><span class="line">    noOfClicks <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Advertisement)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a.CPC * a.noOfClicks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Advertisement)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a.adName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Advertisement</code> 类型有三个字段，分别是 <code>adName</code>、<code>CPC</code>（每次点击成本）和 <code>noOfClicks</code>（点击次数）。广告的总收益等于 <code>CPC</code> 和 <code>noOfClicks</code> 的乘积。</p>
<p>现在我们稍微修改一下 <code>main</code> 函数，把新的收益流添加进来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc main() &#123;  </span><br><span class="line">    project1 := FixedBilling&#123;projectName: <span class="string">&quot;Project 1&quot;</span>, biddedAmount: <span class="number">5000</span>&#125;</span><br><span class="line">    project2 := FixedBilling&#123;projectName: <span class="string">&quot;Project 2&quot;</span>, biddedAmount: <span class="number">10000</span>&#125;</span><br><span class="line">    project3 := TimeAndMaterial&#123;projectName: <span class="string">&quot;Project 3&quot;</span>, noOfHours: <span class="number">160</span>, hourlyRate: <span class="number">25</span>&#125;</span><br><span class="line">    bannerAd := Advertisement&#123;adName: <span class="string">&quot;Banner Ad&quot;</span>, CPC: <span class="number">2</span>, noOfClicks: <span class="number">500</span>&#125;</span><br><span class="line">    popupAd := Advertisement&#123;adName: <span class="string">&quot;Popup Ad&quot;</span>, CPC: <span class="number">5</span>, noOfClicks: <span class="number">750</span>&#125;</span><br><span class="line">    incomeStreams := []Income&#123;project1, project2, project3, bannerAd, popupAd&#125;</span><br><span class="line">    calculateNetIncome(incomeStreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们创建了两个广告项目，即 <code>bannerAd</code> 和 <code>popupAd</code>。<code>incomeStream</code> 切片包含了这两个创建的广告项目。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Income <span class="keyword">interface</span> &#123;  </span><br><span class="line">    calculate() <span class="type">int</span></span><br><span class="line">    source() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FixedBilling <span class="keyword">struct</span> &#123;  </span><br><span class="line">    projectName  <span class="type">string</span></span><br><span class="line">    biddedAmount <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TimeAndMaterial <span class="keyword">struct</span> &#123;  </span><br><span class="line">    projectName <span class="type">string</span></span><br><span class="line">    noOfHours   <span class="type">int</span></span><br><span class="line">    hourlyRate  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Advertisement <span class="keyword">struct</span> &#123;  </span><br><span class="line">    adName     <span class="type">string</span></span><br><span class="line">    CPC        <span class="type">int</span></span><br><span class="line">    noOfClicks <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fb FixedBilling)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fb.biddedAmount</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fb FixedBilling)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fb.projectName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeAndMaterial)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> tm.noOfHours * tm.hourlyRate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm TimeAndMaterial)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> tm.projectName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Advertisement)</span></span> calculate() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a.CPC * a.noOfClicks</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a Advertisement)</span></span> source() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> a.adName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateNetIncome</span><span class="params">(ic []Income)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> netincome <span class="type">int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, income := <span class="keyword">range</span> ic &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Income From %s = $%d\n&quot;</span>, income.source(), income.calculate())</span><br><span class="line">        netincome += income.calculate()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Net income of organisation = $%d&quot;</span>, netincome)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    project1 := FixedBilling&#123;projectName: <span class="string">&quot;Project 1&quot;</span>, biddedAmount: <span class="number">5000</span>&#125;</span><br><span class="line">    project2 := FixedBilling&#123;projectName: <span class="string">&quot;Project 2&quot;</span>, biddedAmount: <span class="number">10000</span>&#125;</span><br><span class="line">    project3 := TimeAndMaterial&#123;projectName: <span class="string">&quot;Project 3&quot;</span>, noOfHours: <span class="number">160</span>, hourlyRate: <span class="number">25</span>&#125;</span><br><span class="line">    bannerAd := Advertisement&#123;adName: <span class="string">&quot;Banner Ad&quot;</span>, CPC: <span class="number">2</span>, noOfClicks: <span class="number">500</span>&#125;</span><br><span class="line">    popupAd := Advertisement&#123;adName: <span class="string">&quot;Popup Ad&quot;</span>, CPC: <span class="number">5</span>, noOfClicks: <span class="number">750</span>&#125;</span><br><span class="line">    incomeStreams := []Income&#123;project1, project2, project3, bannerAd, popupAd&#125;</span><br><span class="line">    calculateNetIncome(incomeStreams)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序会输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CopyIncome <span class="keyword">From</span> Project <span class="number">1</span> = <span class="meta">$5000</span>  </span><br><span class="line">Income <span class="keyword">From</span> Project <span class="number">2</span> = <span class="meta">$10000</span>  </span><br><span class="line">Income <span class="keyword">From</span> Project <span class="number">3</span> = <span class="meta">$4000</span>  </span><br><span class="line">Income <span class="keyword">From</span> Banner Ad = <span class="meta">$1000</span>  </span><br><span class="line">Income <span class="keyword">From</span> Popup Ad = <span class="meta">$3750</span>  </span><br><span class="line">Net income <span class="keyword">of</span> organisation = <span class="meta">$23750</span></span><br></pre></td></tr></table></figure>

<p>你会发现，尽管我们新增了收益流，但却完全没有修改 <code>calculateNetIncome</code> 函数。这就是多态带来的好处。由于新的 <code>Advertisement</code> 同样实现了 <code>Income</code> 接口，所以我们能够向 <code>incomeStreams</code> 切片添加 <code>Advertisement</code>。<code>calculateNetIncome</code> 无需修改，因为它能够调用 <code>Advertisement</code> 类型的 <code>calculate()</code> 和 <code>source()</code> 方法。29. Defer</p>
<h2 id="什么是-defer？"><a href="#什么是-defer？" class="headerlink" title="什么是 defer？"></a>什么是 defer？</h2><p><code>defer</code> 语句的用途是：含有 <code>defer</code> 语句的函数，会在该函数将要返回之前，调用另一个函数。这个定义可能看起来很复杂，我们通过一个示例就很容易明白了。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finished</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Finished finding largest&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largest</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> finished()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Started finding largest&quot;</span>)</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v &gt; max &#123;</span><br><span class="line">            max = v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Largest number in&quot;</span>, nums, <span class="string">&quot;is&quot;</span>, max)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">78</span>, <span class="number">109</span>, <span class="number">2</span>, <span class="number">563</span>, <span class="number">300</span>&#125;</span><br><span class="line">    largest(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序很简单，就是找出一个给定切片的最大值。<code>largest</code> 函数接收一个 int 类型的<a target="_blank" rel="noopener" href="https://studygolang.com/articles/12121">切片</a>作为参数，然后打印出该切片中的最大值。<code>largest</code> 函数的第一行的语句为 <code>defer finished()</code>。这表示在 <code>finished()</code> 函数将要返回之前，会调用 <code>finished()</code> 函数。运行该程序，你会看到有如下输出：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyStarted finding largest  </span><br><span class="line">Largest number in [78<span class="number"> 109 </span>2<span class="number"> 563 </span>300] is<span class="number"> 563 </span> </span><br><span class="line">Finished finding largest</span><br></pre></td></tr></table></figure>

<p><code>largest</code> 函数开始执行后，会打印上面的两行输出。而就在 <code>largest</code> 将要返回的时候，又调用了我们的延迟函数（Deferred Function），打印出 <code>Finished finding largest</code> 的文本。</p>
<h2 id="延迟方法"><a href="#延迟方法" class="headerlink" title="延迟方法"></a>延迟方法</h2><p><code>defer</code> 不仅限于[函数]的调用，调用[方法]也是合法的。我们写一个小程序来测试吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span></span> fullName() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s&quot;</span>,p.firstName,p.lastName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    p := person &#123;</span><br><span class="line">        firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        lastName: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> p.fullName()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Welcome &quot;</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们在第 22 行延迟了一个方法调用。而其他的代码很直观，这里不再解释。该程序输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyWelcome John Smith</span></span><br></pre></td></tr></table></figure>

<h2 id="实参取值（Arguments-Evaluation）"><a href="#实参取值（Arguments-Evaluation）" class="headerlink" title="实参取值（Arguments Evaluation）"></a>实参取值（Arguments Evaluation）</h2><p>在 Go 语言中，并非在调用延迟函数的时候才确定实参，而是当执行 <code>defer</code> 语句的时候，就会对延迟函数的实参进行求值。</p>
<p>通过一个例子就能够理解了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a in deferred function&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> printA(a)</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before deferred function call&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序里的第 11 行，<code>a</code> 的初始值为 5。在第 12 行执行 <code>defer</code> 语句的时候，由于 <code>a</code> 等于 5，因此延迟函数 <code>printA</code> 的实参也等于 5。接着我们在第 13 行将 <code>a</code> 的值修改为 10。下一行会打印出 <code>a</code> 的值。该程序输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyvalue <span class="keyword">of</span> a <span class="keyword">before</span> <span class="keyword">deferred</span> <span class="keyword">function</span> <span class="keyword">call</span> <span class="number">10</span>  </span><br><span class="line"><span class="keyword">value</span> <span class="keyword">of</span> a <span class="keyword">in</span> <span class="keyword">deferred</span> <span class="keyword">function</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出，我们可以看出，在调用了 <code>defer</code> 语句后，虽然我们将 <code>a</code> 修改为 10，但调用延迟函数 <code>printA(a)</code>后，仍然打印的是 5。</p>
<h2 id="defer-栈"><a href="#defer-栈" class="headerlink" title="defer 栈"></a>defer 栈</h2><p>当一个函数内多次调用 <code>defer</code> 时，Go 会把 <code>defer</code> 调用放入到一个栈中，随后按照后进先出（Last In First Out, LIFO）的顺序执行。</p>
<p>我们下面编写一个小程序，使用 <code>defer</code> 栈，将一个字符串逆序打印。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name := <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Orignal String: %s\n&quot;</span>, <span class="type">string</span>(name))</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Reversed String: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">rune</span>(name) &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%c&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中的第 11 行，<code>for range</code> 循环会遍历一个字符串，并在第 12 行调用了 <code>defer fmt.Printf(&quot;%c&quot;, v)</code>。这些延迟调用会添加到一个栈中，按照后进先出的顺序执行，因此，该字符串会逆序打印出来。该程序会输出：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyOrignal <span class="type">String</span>: Naveen  </span><br><span class="line">Reversed <span class="type">String</span>: neevaN</span><br></pre></td></tr></table></figure>

<h2 id="defer-的实际应用"><a href="#defer-的实际应用" class="headerlink" title="defer 的实际应用"></a>defer 的实际应用</h2><p>目前为止，我们看到的代码示例，都没有体现出 <code>defer</code> 的实际用途。本节我们会看看 <code>defer</code> 的实际应用。</p>
<p>当一个函数应该在与当前代码流（Code Flow）无关的环境下调用时，可以使用 <code>defer</code>。我们通过一个用到了 [<code>WaitGroup</code>] 代码示例来理解这句话的含义。我们首先会写一个没有使用 <code>defer</code> 的程序，然后我们会用 <code>defer</code> 来修改，看到 <code>defer</code> 带来的好处。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;  </span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    width  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> area(wg *sync.WaitGroup) &#123;  </span><br><span class="line">    <span class="keyword">if</span> r.length &lt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;rect %v&#x27;s length should be greater than zero\n&quot;</span>, r)</span><br><span class="line">        wg.Done()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r.width &lt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;rect %v&#x27;s width should be greater than zero\n&quot;</span>, r)</span><br><span class="line">        wg.Done()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    area := r.length * r.width</span><br><span class="line">    fmt.Printf(<span class="string">&quot;rect %v&#x27;s area %d\n&quot;</span>, r, area)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    r1 := rect&#123;<span class="number">-67</span>, <span class="number">89</span>&#125;</span><br><span class="line">    r2 := rect&#123;<span class="number">5</span>, <span class="number">-67</span>&#125;</span><br><span class="line">    r3 := rect&#123;<span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    rects := []rect&#123;r1, r2, r3&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> rects &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> v.area(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;All go routines finished executing&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序里，我们在第 8 行创建了 <code>rect</code> 结构体，并在第 13 行创建了 <code>rect</code> 的方法 <code>area</code>，计算出矩形的面积。<code>area</code> 检查了矩形的长宽是否小于零。如果矩形的长宽小于零，它会打印出对应的提示信息，而如果大于零，它会打印出矩形的面积。</p>
<p><code>main</code> 函数创建了 3 个 <code>rect</code> 类型的变量：<code>r1</code>、<code>r2</code> 和 <code>r3</code>。在第 34 行，我们把这 3 个变量添加到了 <code>rects</code> 切片里。该切片接着使用 <code>for range</code> 循环遍历，把 <code>area</code> 方法作为一个并发的 Go 协程进行调用（第 37 行）。我们用 <code>WaitGroup wg</code> 来确保 <code>main</code> 函数在其他协程执行完毕之后，才会结束执行。<code>WaitGroup</code> 作为参数传递给 <code>area</code> 方法后，在第 16 行、第 21 行和第 26 行通知 <code>main</code> 函数，表示现在协程已经完成所有任务。<strong>如果你仔细观察，会发现 wg.Done() 只在 area 函数返回的时候才会调用。wg.Done() 应该在 area 将要返回之前调用，并且与代码流的路径（Path）无关，因此我们可以只调用一次 defer，来有效地替换掉 wg.Done() 的多次调用</strong>。</p>
<p>我们来用 <code>defer</code> 来重写上面的代码。</p>
<p>在下面的代码中，我们移除了原先程序中的 3 个 <code>wg.Done</code> 的调用，而是用一个单独的 <code>defer wg.Done()</code> 来取代它（第 14 行）。这使得我们的代码更加简洁易懂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rect <span class="keyword">struct</span> &#123;  </span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    width  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rect)</span></span> area(wg *sync.WaitGroup) &#123;  </span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">if</span> r.length &lt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;rect %v&#x27;s length should be greater than zero\n&quot;</span>, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> r.width &lt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;rect %v&#x27;s width should be greater than zero\n&quot;</span>, r)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    area := r.length * r.width</span><br><span class="line">    fmt.Printf(<span class="string">&quot;rect %v&#x27;s area %d\n&quot;</span>, r, area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    r1 := rect&#123;<span class="number">-67</span>, <span class="number">89</span>&#125;</span><br><span class="line">    r2 := rect&#123;<span class="number">5</span>, <span class="number">-67</span>&#125;</span><br><span class="line">    r3 := rect&#123;<span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    rects := []rect&#123;r1, r2, r3&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> rects &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> v.area(&amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;All go routines finished executing&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyrect</span> &#123;<span class="number">8</span> <span class="number">9</span>&#125;&#x27;s area <span class="number">72</span>  </span><br><span class="line"><span class="attribute">rect</span> &#123;-<span class="number">67</span> <span class="number">89</span>&#125;&#x27;s length should be greater than zero  </span><br><span class="line"><span class="attribute">rect</span> &#123;<span class="number">5</span> -<span class="number">67</span>&#125;&#x27;s width should be greater than zero  </span><br><span class="line"><span class="attribute">All</span> go routines finished executing</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，使用 <code>defer</code> 还有一个好处。假设我们使用 <code>if</code> 条件语句，又给 <code>area</code> 方法添加了一条返回路径（Return Path）。如果没有使用 <code>defer</code> 来调用 <code>wg.Done()</code>，我们就得很小心了，确保在这条新添的返回路径里调用了 <code>wg.Done()</code>。由于现在我们延迟调用了 <code>wg.Done()</code>，因此无需再为这条新的返回路径添加 <code>wg.Done()</code> 了。</p>
<h1 id="30-错误处理"><a href="#30-错误处理" class="headerlink" title="30. 错误处理"></a>30. 错误处理</h1><h2 id="什么是错误？"><a href="#什么是错误？" class="headerlink" title="什么是错误？"></a>什么是错误？</h2><p>错误表示程序中出现了异常情况。比如当我们试图打开一个文件时，文件系统里却并没有这个文件。这就是异常情况，它用一个错误来表示。</p>
<p>在 Go 中，错误一直是很常见的。错误用内建的 <code>error</code> 类型来表示。</p>
<p>就像其他的内建类型（如 <code>int</code>、<code>float64</code> 等），错误值可以存储在变量里、作为函数的返回值等等。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>现在我们开始编写一个示例，该程序试图打开一个并不存在的文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    f, err := os.Open(<span class="string">&quot;/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(f.Name(), <span class="string">&quot;opened successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序的第 9 行，我们试图打开路径为 <code>/test.txt</code> 的文件。<code>os</code> 包里的 [<code>Open</code>]函数有如下签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc Open(name <span class="type">string</span>) (file *File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p><strong>如果成功打开文件，Open 函数会返回一个文件句柄（File Handler）和一个值为 nil 的错误。而如果打开文件时发生了错误，会返回一个不等于 nil 的错误</strong>。</p>
<p>如果一个[函数] 或[方法] 返回了错误，按照惯例，错误会作为最后一个值返回。于是 <code>Open</code> 函数也是将 <code>err</code> 作为最后一个返回值。</p>
<p><strong>按照 Go 的惯例，在处理错误时，通常都是将返回的错误与 nil 比较。nil 值表示了没有错误发生，而非 nil 值表示出现了错误</strong>。在这里，我们第 10 行检查了错误值是否为 <code>nil</code>。如果不是 <code>nil</code>，我们会简单地打印出错误，并在 <code>main</code> 函数中返回。</p>
<p>运行该程序会输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyopen /<span class="keyword">test</span>.txt: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>

<p>很棒！我们得到了一个错误，它指出该文件并不存在。</p>
<h2 id="错误类型的表示"><a href="#错误类型的表示" class="headerlink" title="错误类型的表示"></a>错误类型的表示</h2><p>让我们进一步深入，理解 <code>error</code> 类型是如何定义的。<code>error</code> 是一个[接口]类型，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copytype <span class="type">error</span> <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error</code> 有了一个签名为 <code>Error() string</code> 的方法。所有实现该接口的类型都可以当作一个错误类型。<code>Error()</code> 方法给出了错误的描述。</p>
<p><code>fmt.Println</code> 在打印错误时，会在内部调用 <code>Error() string</code> 方法来得到该错误的描述。上一节示例中的第 11 行，就是这样打印出错误的描述的。</p>
<h2 id="从错误获取更多信息的不同方法"><a href="#从错误获取更多信息的不同方法" class="headerlink" title="从错误获取更多信息的不同方法"></a>从错误获取更多信息的不同方法</h2><p>现在，我们知道了 <code>error</code> 是一个接口类型，让我们看看如何从一个错误获取更多信息。</p>
<p>在前面的示例里，我们只是打印出错误的描述。如果我们想知道这个错误的文件路径，该怎么做呢？一种选择是直接解析错误的字符串。这是前面示例的输出：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyopen /<span class="keyword">test</span>.txt: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>

<p><strong>我们解析了这条错误信息，虽然获取了发生错误的文件路径，但是这种方法很不优雅。随着语言版本的更新，这条错误的描述随时都有可能变化，使我们程序出错</strong>。</p>
<p>有没有更加可靠的方法来获取文件名呢？答案是肯定的，这是可以做到的，Go 标准库给出了各种提取错误相关信息的方法。我们一个个来看看吧。</p>
<h3 id="1-断言底层结构体类型，使用结构体字段获取更多信息"><a href="#1-断言底层结构体类型，使用结构体字段获取更多信息" class="headerlink" title="1. 断言底层结构体类型，使用结构体字段获取更多信息"></a>1. 断言底层结构体类型，使用结构体字段获取更多信息</h3><p>如果你仔细阅读了 [<code>Open</code>] 函数的文档，你可以看见它返回的错误类型是 <code>*PathError</code>。[<code>PathError</code>]是[结构体]类型，它在标准库中的实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copytype PathError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Op   <span class="type">string</span></span><br><span class="line">    Path <span class="type">string</span></span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PathError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> e.Op + <span class="string">&quot; &quot;</span> + e.Path + <span class="string">&quot;: &quot;</span> + e.Err.Error() &#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，你就知道了 <code>*PathError</code> 通过声明 <code>Error() string</code> 方法，实现了 <code>error</code> 接口。<code>Error() string</code> 将文件操作、路径和实际错误拼接，并返回该字符串。于是我们得到该错误信息：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyopen /<span class="keyword">test</span>.txt: <span class="keyword">No</span> such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>

<p>结构体 <code>PathError</code> 的 <code>Path</code> 字段，就有导致错误的文件路径。我们修改前面写的程序，打印出该路径。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    f, err := os.Open(<span class="string">&quot;/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;File at path&quot;</span>, err.Path, <span class="string">&quot;failed to open&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(f.Name(), <span class="string">&quot;opened successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序里，我们在第 10 行使用了[类型断言]（Type Assertion）来获取 <code>error</code> 接口的底层值（Underlying Value）。接下来在第 11 行，我们使用 <code>err.Path</code> 来打印该路径。该程序会输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyFile <span class="keyword">at</span> path /test.txt failed <span class="built_in">to</span> <span class="built_in">open</span></span><br></pre></td></tr></table></figure>

<p>很棒！我们已经使用类型断言成功获取到了该错误的文件路径。</p>
<h3 id="2-断言底层结构体类型，调用方法获取更多信息"><a href="#2-断言底层结构体类型，调用方法获取更多信息" class="headerlink" title="2. 断言底层结构体类型，调用方法获取更多信息"></a>2. 断言底层结构体类型，调用方法获取更多信息</h3><p>第二种获取更多错误信息的方法，也是对底层类型进行断言，然后通过调用该结构体类型的方法，来获取更多的信息。</p>
<p>我们通过一个实例来理解这一点。</p>
<p>标准库中的 <code>DNSError</code> 结构体类型定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copytype DNSError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DNSError)</span></span> Error() <span class="type">string</span> &#123;  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DNSError)</span></span> Timeout() <span class="type">bool</span> &#123;  </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *DNSError)</span></span> Temporary() <span class="type">bool</span> &#123;  </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看到，<code>DNSError</code> 结构体还有 <code>Timeout() bool</code> 和 <code>Temporary() bool</code> 两个方法，它们返回一个布尔值，指出该错误是由超时引起的，还是临时性错误。</p>
<p>接下来我们编写一个程序，断言 <code>*DNSError</code> 类型，并调用这些方法来确定该错误是临时性错误，还是由超时导致的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    addr, err := net.LookupHost(<span class="string">&quot;golangbot123.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err, ok := err.(*net.DNSError); ok &#123;</span><br><span class="line">        <span class="keyword">if</span> err.Timeout() &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;operation timed out&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> err.Temporary() &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;temporary error&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;generic error: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(addr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中，我们在第 9 行，试图获取 <code>golangbot123.com</code>（无效的域名） 的 ip。在第 10 行，我们通过 <code>*net.DNSError</code> 的类型断言，获取到了错误的底层值。接下来的第 11 行和第 13 行，我们分别检查了该错误是由超时引起的，还是一个临时性错误。</p>
<p>在本例中，我们的错误既不是临时性错误，也不是由超时引起的，因此该程序输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copygeneric</span> <span class="literal">error</span>:  lookup golangbot123.com: <span class="literal">no</span> such host</span><br></pre></td></tr></table></figure>

<p>如果该错误是临时性错误，或是由超时引发的，那么对应的 if 语句会执行，于是我们就可以适当地处理它们。</p>
<h3 id="3-直接比较"><a href="#3-直接比较" class="headerlink" title="3. 直接比较"></a>3. 直接比较</h3><p>第三种获取错误的更多信息的方式，是与 <code>error</code> 类型的变量直接比较。我们通过一个示例来理解。</p>
<p><code>filepath</code> 包中的 [<code>Glob</code>] 用于返回满足 glob 模式的所有文件名。如果模式写的不对，该函数会返回一个错误 <code>ErrBadPattern</code>。</p>
<p><code>filepath</code> 包中的 <code>ErrBadPattern</code> 定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyvar ErrBadPattern = errors.New(<span class="string">&quot;syntax error in pattern&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>errors.New()</code> 用于创建一个新的错误。我们会在下一教程中详细讨论它。</p>
<p>当模式不正确时，<code>Glob</code> 函数会返回 <code>ErrBadPattern</code>。</p>
<p>我们来写一个小程序来看看这个错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    files, <span class="type">error</span> := filepath.Glob(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">error</span> != <span class="literal">nil</span> &amp;&amp; <span class="type">error</span> == filepath.ErrBadPattern &#123;</span><br><span class="line">        fmt.Println(<span class="type">error</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;matched files&quot;</span>, files)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序里，我们查询了模式为 <code>[</code> 的文件，然而这个模式写的不正确。我们检查了该错误是否为 <code>nil</code>。为了获取该错误的更多信息，我们在第 10 行将 <code>error</code> 直接与 <code>filepath.ErrBadPattern</code> 相比较。如果该条件满足，那么该错误就是由模式错误导致的。该程序会输出：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copysyntax</span> <span class="literal">error</span> in pattern</span><br></pre></td></tr></table></figure>

<p>标准库在提供错误的详细信息时，使用到了上述提到的三种方法。在下一教程里，我们会通过这些方法来创建我们自己的自定义错误。</p>
<h2 id="不可忽略错误"><a href="#不可忽略错误" class="headerlink" title="不可忽略错误"></a>不可忽略错误</h2><p>绝不要忽略错误。忽视错误会带来问题。接下来我重写上面的示例，在列出所有满足模式的文件名时，我省略了错误处理的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    files, _ := filepath.Glob(<span class="string">&quot;[&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;matched files&quot;</span>, files)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经从前面的示例知道了这个模式是错误的。在第 9 行，通过使用 <code>_</code> 空白标识符，我忽略了 <code>Glob</code> 函数返回的错误。我在第 10 行简单打印了所有匹配的文件。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copymatched</span> files<span class="meta"> []</span></span><br></pre></td></tr></table></figure>

<p>由于我忽略了错误，输出看起来就像是没有任何匹配了 glob 模式的文件，但实际上这是因为模式的写法不对。所以绝不要忽略错误。</p>
<p>本教程到此结束。</p>
<p>这一教程我们讨论了该如何处理程序中出现的错误，也讨论了如何查询关于错误的更多信息。简单概括一下本教程讨论的内容：</p>
<ul>
<li>什么是错误？</li>
<li>错误的表示</li>
<li>获取错误详细信息的各种方法</li>
<li>不能忽视错误</li>
</ul>
<h1 id="31-自定义错误"><a href="#31-自定义错误" class="headerlink" title="31. 自定义错误"></a>31. 自定义错误</h1><h2 id="使用-New-函数创建自定义错误"><a href="#使用-New-函数创建自定义错误" class="headerlink" title="使用 New 函数创建自定义错误"></a>使用 New 函数创建自定义错误</h2><p>创建自定义错误最简单的方法是使用 [<code>errors</code>]包中的 [<code>New</code>]函数。</p>
<p>在使用 New [函数]创建自定义错误之前，我们先来看看 <code>New</code> 是如何实现的。如下所示，是 [<code>errors</code> 包]中的 <code>New</code> 函数的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// Package errors implements functions to manipulate errors.</span></span><br><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns an error that formats as the given text.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// errorString is a trivial implementation of error.</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>New</code> 函数的实现很简单。<code>errorString</code> 是一个[结构体]类型，只有一个字符串字段 <code>s</code>。第 14 行使用了 <code>errorString</code> 指针接受者（Pointer Receiver），来实现 <code>error</code> 接口的 <code>Error() string</code> [方法]。</p>
<p>第 5 行的 <code>New</code> 函数有一个字符串参数，通过这个参数创建了 <code>errorString</code> 类型的变量，并返回了它的地址。于是它就创建并返回了一个新的错误。</p>
<p>现在我们已经知道了 <code>New</code> 函数是如何工作的，我们开始在程序里使用 <code>New</code> 来创建自定义错误吧。</p>
<p>我们将创建一个计算圆半径的简单程序，如果半径为负，它会返回一个错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea</span><span class="params">(radius <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;Area calculation failed, radius is less than zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    radius := <span class="number">-20.0</span></span><br><span class="line">    area, err := circleArea(radius)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area of circle %0.2f&quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们检查半径是否小于零（第 10 行）。如果半径小于零，我们会返回等于 0 的面积，以及相应的错误信息。如果半径大于零，则会计算出面积，并返回值为 <code>nil</code> 的错误（第 13 行）。</p>
<p>在 <code>main</code> 函数里，我们在第 19 行检查错误是否等于 <code>nil</code>。如果不是 <code>nil</code>，我们会打印出错误并返回，否则我们会打印出圆的面积。</p>
<p>在我们的程序中，半径小于零，因此打印出：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyArea calculation failed, radius <span class="keyword">is</span> <span class="keyword">less than</span> zero</span><br></pre></td></tr></table></figure>

<h2 id="使用-Errorf-给错误添加更多信息"><a href="#使用-Errorf-给错误添加更多信息" class="headerlink" title="使用 Errorf 给错误添加更多信息"></a>使用 Errorf 给错误添加更多信息</h2><p>上面的程序效果不错，但是如果我们能够打印出当前圆的半径，那就更好了。这就要用到 [<code>fmt</code>]包中的 [<code>Errorf</code>] 函数了。<code>Errorf</code> 函数会根据格式说明符，规定错误的格式，并返回一个符合该错误的[字符串]。</p>
<p>接下来我们使用 <code>Errorf</code> 函数来改进我们的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea</span><span class="params">(radius <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;Area calculation failed, radius %0.2f is less than zero&quot;</span>, radius)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    radius := <span class="number">-20.0</span></span><br><span class="line">    area, err := circleArea(radius)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area of circle %0.2f&quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们使用 <code>Errorf</code>（第 10 行）打印了发生错误的半径。程序运行后会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyArea</span> calculation failed, radius -<span class="number">20</span>.<span class="number">00</span> is less than zero</span><br></pre></td></tr></table></figure>

<h2 id="使用结构体类型和字段提供错误的更多信息"><a href="#使用结构体类型和字段提供错误的更多信息" class="headerlink" title="使用结构体类型和字段提供错误的更多信息"></a>使用结构体类型和字段提供错误的更多信息</h2><p>错误还可以用实现了 <code>error</code> [接口]的结构体来表示。这种方式可以更加灵活地处理错误。在上面例子中，如果我们希望访问引发错误的半径，现在唯一的方法就是解析错误的描述信息 <code>Area calculation failed, radius -20.00 is less than zero</code>。这样做不太好，因为一旦描述信息发生变化，程序就会出错。</p>
<p>我们会使用标准库里采用的方法，在上一教程中“断言底层结构体类型，使用结构体字段获取更多信息”这一节，我们讲解了这一方法，可以使用结构体字段来访问引发错误的半径。我们会创建一个实现 <code>error</code> 接口的结构体类型，并使用它的字段来提供关于错误的更多信息。</p>
<p>第一步就是创建一个表示错误的结构体类型。错误类型的命名约定是名称以 <code>Error</code> 结尾。因此我们不妨把结构体类型命名为 <code>areaError</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copytype areaError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    err    <span class="type">string</span></span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的结构体类型有一个 <code>radius</code> 字段，它存储了与错误有关的半径，而 <code>err</code> 字段存储了实际的错误信息。</p>
<p>下一步是实现 <code>error</code> 接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc (e *areaError) Error() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;radius %0.2f: %s&quot;</span>, e.radius, e.err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用指针接收者 <code>*areaError</code>，实现了 <code>error</code> 接口的 <code>Error() string</code> 方法。该方法打印出半径和关于错误的描述。</p>
<p>现在我们来编写 <code>main</code> 函数和 <code>circleArea</code> 函数来完成整个程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    err    <span class="type">string</span></span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> Error() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;radius %0.2f: %s&quot;</span>, e.radius, e.err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">circleArea</span><span class="params">(radius <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> radius &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;<span class="string">&quot;radius is negative&quot;</span>, radius&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * radius * radius, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    radius := <span class="number">-20.0</span></span><br><span class="line">    area, err := circleArea(radius)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Radius %0.2f is less than zero&quot;</span>, err.radius)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area of rectangle1 %0.2f&quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://play.golang.org/p/OTs7J0adQg">在 playground 上运行</a></p>
<p>在上面的程序中，<code>circleArea</code>（第 17 行）用于计算圆的面积。该函数首先检查半径是否小于零，如果小于零，它会通过错误半径和对应错误信息，创建一个 <code>areaError</code> 类型的值，然后返回 <code>areaError</code> 值的地址，与此同时 <code>area</code> 等于 0（第 19 行）。<strong>于是我们提供了更多的错误信息（即导致错误的半径），我们使用了自定义错误的结构体字段来定义它</strong>。</p>
<p>如果半径是非负数，该函数会在第 21 行计算并返回面积，同时错误值为 <code>nil</code>。</p>
<p>在 <code>main</code> 函数的 26 行，我们试图计算半径为 -20 的圆的面积。由于半径小于零，因此会导致一个错误。</p>
<p>我们在第 27 行检查了错误是否为 <code>nil</code>，并在下一行断言了 <code>*areaError</code> 类型。<strong>如果错误是 *areaError 类型，我们就可以用 err.radius 来获取错误的半径（第 29 行），打印出自定义错误的消息，最后程序返回退出</strong>。</p>
<p>如果断言错误，我们就在第 32 行打印该错误，并返回。如果没有发生错误，在第 35 行会打印出面积。</p>
<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyRadius</span> -<span class="number">20</span>.<span class="number">00</span> is less than zero</span><br></pre></td></tr></table></figure>

<p>下面我们来使用上一教程提到的[第二种方法]，使用自定义错误类型的方法来提供错误的更多信息。</p>
<h2 id="使用结构体类型的方法来提供错误的更多信息"><a href="#使用结构体类型的方法来提供错误的更多信息" class="headerlink" title="使用结构体类型的方法来提供错误的更多信息"></a>使用结构体类型的方法来提供错误的更多信息</h2><p>在本节里，我们会编写一个计算矩形面积的程序。如果长或宽小于零，程序就会打印出错误。</p>
<p>第一步就是创建一个表示错误的结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copytype areaError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    err    <span class="type">string</span> <span class="comment">//error description</span></span><br><span class="line">    length <span class="type">float64</span> <span class="comment">//length which caused the error</span></span><br><span class="line">    width  <span class="type">float64</span> <span class="comment">//width which caused the error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的结构体类型除了有一个错误描述字段，还有可能引发错误的宽和高。</p>
<p>现在我们有了错误类型，我们来实现 <code>error</code> 接口，并给该错误类型添加两个方法，使它提供了更多的错误信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc (e *areaError) Error() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> lengthNegative() <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.length &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> widthNegative() <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.width &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码片段中，我们从 <code>Error() string</code> 方法中返回了关于错误的描述。当 <code>length</code> 小于零时，<code>lengthNegative() bool</code> 方法返回 <code>true</code>，而当 <code>width</code> 小于零时，<code>widthNegative() bool</code> 方法返回 <code>true</code>。<strong>这两个方法都提供了关于错误的更多信息，在这里，它提示我们计算面积失败的原因（长度为负数或者宽度为负数）。于是我们就有了两个错误类型结构体的方法，来提供更多的错误信息</strong>。</p>
<p>下一步就是编写计算面积的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc rectArea(length, width <span class="type">float64</span>) (<span class="type">float64</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    err := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">0</span> &#123;</span><br><span class="line">        err += <span class="string">&quot;length is less than zero&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> width &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            err = <span class="string">&quot;width is less than zero&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err += <span class="string">&quot;, width is less than zero&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;err, length, width&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length * width, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code>rectArea</code> 函数检查了长或宽是否小于零，如果小于零，<code>rectArea</code> 会返回一个错误信息，否则 <code>rectArea</code> 会返回矩形的面积和一个值为 <code>nil</code> 的错误。</p>
<p>让我们创建 <code>main</code> 函数来完成整个程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc main() &#123;  </span><br><span class="line">    length, width := <span class="number">-5.0</span>, <span class="number">-9.0</span></span><br><span class="line">    area, err := rectArea(length, width)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> err.lengthNegative() &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;error: length %0.2f is less than zero\n&quot;</span>, err.length)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> err.widthNegative() &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;error: width %0.2f is less than zero\n&quot;</span>, err.width)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;area of rect&quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 程序中，我们检查了错误是否为 <code>nil</code>（第 4 行）。如果错误值不是 <code>nil</code>，我们会在下一行断言 <code>*areaError</code> 类型。然后，我们使用 <code>lengthNegative()</code> 和 <code>widthNegative()</code> 方法，检查错误的原因是长度小于零还是宽度小于零。这样我们就使用了错误结构体类型的方法，来提供更多的错误信息。</p>
<p>如果没有错误发生，就会打印矩形的面积。</p>
<p>下面是整个程序的代码供你参考。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> areaError <span class="keyword">struct</span> &#123;  </span><br><span class="line">    err    <span class="type">string</span>  <span class="comment">//error description</span></span><br><span class="line">    length <span class="type">float64</span> <span class="comment">//length which caused the error</span></span><br><span class="line">    width  <span class="type">float64</span> <span class="comment">//width which caused the error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> Error() <span class="type">string</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> lengthNegative() <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.length &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *areaError)</span></span> widthNegative() <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.width &lt; <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectArea</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;  </span><br><span class="line">    err := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">0</span> &#123;</span><br><span class="line">        err += <span class="string">&quot;length is less than zero&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> width &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            err = <span class="string">&quot;width is less than zero&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err += <span class="string">&quot;, width is less than zero&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, &amp;areaError&#123;err, length, width&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length * width, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    length, width := <span class="number">-5.0</span>, <span class="number">-9.0</span></span><br><span class="line">    area, err := rectArea(length, width)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err, ok := err.(*areaError); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> err.lengthNegative() &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;error: length %0.2f is less than zero\n&quot;</span>, err.length)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> err.widthNegative() &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;error: width %0.2f is less than zero\n&quot;</span>, err.width)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;area of rect&quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会打印输出：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyerror: length <span class="string">-5</span>.00 is less than zero  </span><br><span class="line"><span class="keyword">error: </span>width <span class="string">-9</span>.00 is less than zero</span><br></pre></td></tr></table></figure>

<p>在上一教程[错误处理]中，我们介绍了三种提供更多错误信息的方法，现在我们已经看了其中两个示例。</p>
<p>第三种方法使用的是直接比较，比较简单。我留给读者作为练习，你们可以试着使用这种方法来给出自定义错误的更多信息。</p>
<p>本教程到此结束。</p>
<p>简单概括一下本教程讨论的内容：</p>
<ul>
<li>使用 <code>New</code> 函数创建自定义错误</li>
<li>使用 <code>Error</code> 添加更多错误信息</li>
<li>使用结构体类型和字段，提供更多错误信息</li>
<li>使用结构体类型和方法，提供更多错误信息</li>
</ul>
<h1 id="32-panic-和-recover"><a href="#32-panic-和-recover" class="headerlink" title="32. panic 和 recover"></a>32. panic 和 recover</h1><h2 id="什么是-panic？"><a href="#什么是-panic？" class="headerlink" title="什么是 panic？"></a>什么是 panic？</h2><p>在 Go 语言中，程序中一般是使用[错误]来处理异常情况。对于程序中出现的大部分异常情况，错误就已经够用了。</p>
<p>但在有些情况，当程序发生异常时，无法继续运行。在这种情况下，我们会使用 <code>panic</code> 来终止程序。当[函数]发生 panic 时，它会终止运行，在执行完所有的[延迟]函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前[协程]的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪（Stack Trace），最后程序终止。在编写一个示例程序后，我们就能很好地理解这个概念了。</p>
<p>在本教程里，我们还会接着讨论，当程序发生 panic 时，使用 <code>recover</code> 可以重新获得对该程序的控制。</p>
<p>可以认为 <code>panic</code> 和 <code>recover</code> 与其他语言中的 <code>try-catch-finally</code> 语句类似，只不过一般我们很少使用 <code>panic</code> 和 <code>recover</code>。而当我们使用了 <code>panic</code> 和 <code>recover</code> 时，也会比 <code>try-catch-finally</code> 更加优雅，代码更加整洁。</p>
<h2 id="什么时候应该使用-panic？"><a href="#什么时候应该使用-panic？" class="headerlink" title="什么时候应该使用 panic？"></a>什么时候应该使用 panic？</h2><p><strong>需要注意的是，你应该尽可能地使用错误，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制</strong>。</p>
<p>panic 有两个合理的用例。</p>
<ol>
<li><strong>发生了一个不能恢复的错误，此时程序不能继续运行</strong>。 一个例子就是 web 服务器无法绑定所要求的端口。在这种情况下，就应该使用 panic，因为如果不能绑定端口，啥也做不了。</li>
<li><strong>发生了一个编程上的错误</strong>。 假如我们有一个接收指针参数的方法，而其他人使用 <code>nil</code> 作为参数调用了它。在这种情况下，我们可以使用 panic，因为这是一个编程错误：用 <code>nil</code> 参数调用了一个只能接收合法指针的方法。</li>
</ol>
<h2 id="panic-示例"><a href="#panic-示例" class="headerlink" title="panic 示例"></a>panic 示例</h2><p>内建函数 <code>panic</code> 的签名如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc <span class="built_in">panic</span>(<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>当程序终止时，会打印传入 <code>panic</code> 的参数。我们写一个示例，你就会清楚它的用途了。我们现在就开始吧。</p>
<p>我们会写一个例子，来展示 <code>panic</code> 如何工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="type">string</span>, lastName *<span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;runtime error: first name cannot be nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;runtime error: last name cannot be nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;returned normally from fullName&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    firstName := <span class="string">&quot;Elon&quot;</span></span><br><span class="line">    fullName(&amp;firstName, <span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;returned normally from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序很简单，会打印一个人的全名。第 7 行的 <code>fullName</code> 函数会打印出一个人的全名。该函数在第 8 行和第 11 行分别检查了 <code>firstName</code> 和 <code>lastName</code> 的指针是否为 <code>nil</code>。如果是 <code>nil</code>，<code>fullName</code> 函数会调用含有不同的错误信息的 <code>panic</code>。当程序终止时，会打印出该错误信息。</p>
<p>运行该程序，会有如下输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypanic: runtime error: last name cannot be nil</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[running]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.fullName</span>(<span class="number">0</span>x1040c128, <span class="number">0</span>x0)  </span><br><span class="line">    /tmp/sandbox135038844/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">12</span> +<span class="number">0</span>x120</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox135038844/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">20</span> +<span class="number">0</span>x80</span><br></pre></td></tr></table></figure>

<p>我们来分析这个输出，理解一下 panic 是如何工作的，并且思考当程序发生 panic 时，会怎样打印堆栈跟踪。</p>
<p>在第 19 行，我们将 <code>Elon</code> 赋值给了 <code>firstName</code>。在第 20 行，我们调用了 <code>fullName</code> 函数，其中 <code>lastName</code> 等于 <code>nil</code>。因此，满足了第 11 行的条件，程序发生 panic。当出现了 panic 时，程序就会终止运行，打印出传入 panic 的参数，接着打印出堆栈跟踪。因此，第 14 行和第 15 行的代码并不会在发生 panic 之后执行。程序首先会打印出传入 <code>panic</code> 函数的信息：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypanic: <span class="keyword">runtime</span> error: <span class="keyword">last</span> name cannot <span class="keyword">be</span> <span class="built_in">empty</span></span><br></pre></td></tr></table></figure>

<p>接着打印出堆栈跟踪。</p>
<p>程序在 <code>fullName</code> 函数的第 12 行发生 panic，因此，首先会打印出如下所示的输出。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copymain<span class="selector-class">.fullName</span>(<span class="number">0</span>x1040c128, <span class="number">0</span>x0)  </span><br><span class="line">    /tmp/sandbox135038844/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">12</span> +<span class="number">0</span>x120</span><br></pre></td></tr></table></figure>

<p>接着会打印出堆栈的下一项。在本例中，堆栈跟踪中的下一项是第 20 行（因为发生 panic 的 <code>fullName</code> 调用就在这一行），因此接下来会打印出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copymain<span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox135038844/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">20</span> +<span class="number">0</span>x80</span><br></pre></td></tr></table></figure>

<p>现在我们已经到达了导致 panic 的顶层函数，这里没有更多的层级，因此结束打印。</p>
<h2 id="发生-panic-时的-defer"><a href="#发生-panic-时的-defer" class="headerlink" title="发生 panic 时的 defer"></a>发生 panic 时的 defer</h2><p>我们重新总结一下 panic 做了什么。<strong>当函数发生 panic 时，它会终止运行，在执行完所有的延迟函数后，程序控制返回到该函数的调用方。这样的过程会一直持续下去，直到当前协程的所有函数都返回退出，然后程序会打印出 panic 信息，接着打印出堆栈跟踪，最后程序终止</strong>。</p>
<p>在上面的例子中，我们没有延迟调用任何函数。如果有延迟函数，会先调用它，然后程序控制返回到函数调用方。</p>
<p>我们来修改上面的示例，使用一个延迟语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="type">string</span>, lastName *<span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;deferred call in fullName&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;runtime error: first name cannot be nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;runtime error: last name cannot be nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;returned normally from fullName&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;deferred call in main&quot;</span>)</span><br><span class="line">    firstName := <span class="string">&quot;Elon&quot;</span></span><br><span class="line">    fullName(&amp;firstName, <span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;returned normally from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们只修改了两处，分别在第 8 行和第 20 行添加了延迟函数的调用。</p>
<p>该函数会打印：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CopyThis program prints,</span><br><span class="line"></span><br><span class="line">deferred call <span class="keyword">in</span> fullName  </span><br><span class="line">deferred call <span class="keyword">in</span> <span class="selector-tag">main</span>  </span><br><span class="line">panic: runtime error: last name cannot be nil</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[running]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.fullName</span>(<span class="number">0</span>x1042bf90, <span class="number">0</span>x0)  </span><br><span class="line">    /tmp/sandbox060731990/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">13</span> +<span class="number">0</span>x280</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox060731990/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">22</span> +<span class="number">0</span>xc0</span><br></pre></td></tr></table></figure>

<p>当程序在第 13 行发生 panic 时，首先执行了延迟函数，接着控制返回到函数调用方，调用方的延迟函数继续运行，直到到达顶层调用函数。</p>
<p>在我们的例子中，首先执行 <code>fullName</code> 函数中的 <code>defer</code> 语句（第 8 行）。程序打印出：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copydeferred <span class="built_in">call</span> <span class="keyword">in</span> fullName</span><br></pre></td></tr></table></figure>

<p>接着程序返回到 <code>main</code> 函数，执行了 <code>main</code> 函数的延迟调用，因此会输出：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copydeferred <span class="built_in">call</span> <span class="keyword">in</span> main</span><br></pre></td></tr></table></figure>

<p>现在程序控制到达了顶层函数，因此该函数会打印出 panic 信息，然后是堆栈跟踪，最后终止程序。</p>
<h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p><code>recover</code> 是一个内建函数，用于重新获得 panic 协程的控制。</p>
<p><code>recover</code> 函数的标签如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc <span class="built_in">recover</span>() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>只有在延迟函数的内部，调用 <code>recover</code> 才有用。在延迟函数内调用 <code>recover</code>，可以取到 <code>panic</code> 的错误信息，并且停止 panic 续发事件（Panicking Sequence），程序运行恢复正常。如果在延迟函数的外部调用 <code>recover</code>，就不能停止 panic 续发事件。</p>
<p>我们来修改一下程序，在发生 panic 之后，使用 <code>recover</code> 来恢复正常的运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverName</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r!= <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recovered from &quot;</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fullName</span><span class="params">(firstName *<span class="type">string</span>, lastName *<span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> recoverName()</span><br><span class="line">    <span class="keyword">if</span> firstName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;runtime error: first name cannot be nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> lastName == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;runtime error: last name cannot be nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s\n&quot;</span>, *firstName, *lastName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;returned normally from fullName&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;deferred call in main&quot;</span>)</span><br><span class="line">    firstName := <span class="string">&quot;Elon&quot;</span></span><br><span class="line">    fullName(&amp;firstName, <span class="literal">nil</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;returned normally from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 7 行，<code>recoverName()</code> 函数调用了 <code>recover()</code>，返回了调用 <code>panic</code> 的传参。在这里，我们只是打印出 <code>recover</code> 的返回值（第 8 行）。在 <code>fullName</code> 函数内，我们在第 14 行延迟调用了 <code>recoverNames()</code>。</p>
<p>当 <code>fullName</code> 发生 panic 时，会调用延迟函数 <code>recoverName()</code>，它使用了 <code>recover()</code> 来停止 panic 续发事件。</p>
<p>该程序会输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyrecovered <span class="keyword">from</span>  runtime error: last <span class="type">name</span> cannot be nil  </span><br><span class="line">returned normally <span class="keyword">from</span> main  </span><br><span class="line"><span class="keyword">deferred</span> <span class="keyword">call</span> <span class="keyword">in</span> main</span><br></pre></td></tr></table></figure>

<p>当程序在第 19 行发生 panic 时，会调用延迟函数 <code>recoverName</code>，它反过来会调用 <code>recover()</code> 来重新获得 panic 协程的控制。第 8 行调用了 <code>recover</code>，返回了 <code>panic</code> 的传参，因此会打印：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyrecovered <span class="keyword">from</span>  runtime <span class="keyword">error</span>: <span class="keyword">last</span> <span class="built_in">name</span> cannot be nil</span><br></pre></td></tr></table></figure>

<p>在执行完 <code>recover()</code> 之后，panic 会停止，程序控制返回到调用方（在这里就是 <code>main</code> 函数），程序在发生 panic 之后，从第 29 行开始会继续正常地运行。程序会打印 <code>returned normally from main</code>，之后是 <code>deferred call in main</code>。</p>
<h2 id="panic，recover-和-Go-协程"><a href="#panic，recover-和-Go-协程" class="headerlink" title="panic，recover 和 Go 协程"></a>panic，recover 和 Go 协程</h2><p>只有在相同的 [Go 协程]中调用 recover 才管用。<code>recover</code> 不能恢复一个不同协程的 panic。我们用一个例子来理解这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recovery</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recovered:&quot;</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> recovery()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Inside A&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> b()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Inside B&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;oh! B panicked&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a()</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，函数 <code>b()</code> 在第 23 行发生 panic。函数 <code>a()</code> 调用了一个延迟函数 <code>recovery()</code>，用于恢复 panic。在第 17 行，函数 <code>b()</code> 作为一个不同的协程来调用。下一行的 <code>Sleep</code> 只是保证 <code>a()</code> 在 <code>b()</code> 运行结束之后才退出。</p>
<p>你认为程序会输出什么？panic 能够恢复吗？答案是否定的，panic 并不会恢复。因为调用 <code>recovery</code> 的协程和 <code>b()</code> 中发生 panic 的协程并不相同，因此不可能恢复 panic。</p>
<p>运行该程序会输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CopyInside A  </span><br><span class="line">Inside B  </span><br><span class="line">panic: oh! B panicked</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">5</span> <span class="selector-attr">[running]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.b</span>()  </span><br><span class="line">    /tmp/sandbox388039916/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">23</span> +<span class="number">0</span>x80</span><br><span class="line">created by <span class="selector-tag">main</span><span class="selector-class">.a</span>  </span><br><span class="line">    /tmp/sandbox388039916/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">17</span> +<span class="number">0</span>xc0</span><br></pre></td></tr></table></figure>

<p>从输出可以看出，panic 没有恢复。</p>
<p>如果函数 <code>b()</code> 在相同的协程里调用，panic 就可以恢复。</p>
<p>如果程序的第 17 行由 <code>go b()</code> 修改为 <code>b()</code>，就可以恢复 panic 了，因为 panic 发生在与 recover 相同的协程里。如果运行这个修改后的程序，会输出：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">CopyInside</span> <span class="selector-tag">A</span>  </span><br><span class="line"><span class="selector-tag">Inside</span> <span class="selector-tag">B</span>  </span><br><span class="line"><span class="selector-tag">recovered</span>: <span class="selector-tag">oh</span>! <span class="selector-tag">B</span> <span class="selector-tag">panicked</span>  </span><br><span class="line"><span class="selector-tag">normally</span> <span class="selector-tag">returned</span> <span class="selector-tag">from</span> <span class="selector-tag">main</span></span><br></pre></td></tr></table></figure>

<h2 id="运行时-panic"><a href="#运行时-panic" class="headerlink" title="运行时 panic"></a>运行时 panic</h2><p>运行时错误（如数组越界）也会导致 panic。这等价于调用了内置函数 <code>panic</code>，其参数由接口类型 [runtime.Error]给出。<code>runtime.Error</code> 接口的定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copytype Error <span class="keyword">interface</span> &#123;  </span><br><span class="line">    <span class="type">error</span></span><br><span class="line">    <span class="comment">// RuntimeError is a no-op function but</span></span><br><span class="line">    <span class="comment">// serves to distinguish types that are run time</span></span><br><span class="line">    <span class="comment">// errors from ordinary errors: a type is a</span></span><br><span class="line">    <span class="comment">// run time error if it has a RuntimeError method.</span></span><br><span class="line">    RuntimeError()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>runtime.Error</code> 接口满足内建接口类型 [<code>error</code>]。</p>
<p>我们来编写一个示例，创建一个运行时 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    n := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(n[<span class="number">3</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a()</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，第 9 行我们试图访问 <code>n[3]</code>，这是一个对[切片]的错误引用。该程序会发生 panic，输出如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypanic: runtime error: index out of range</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> <span class="selector-attr">[running]</span>:  </span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.a</span>()  </span><br><span class="line">    /tmp/sandbox780439659/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">9</span> +<span class="number">0</span>x40</span><br><span class="line"><span class="selector-tag">main</span><span class="selector-class">.main</span>()  </span><br><span class="line">    /tmp/sandbox780439659/<span class="selector-tag">main</span><span class="selector-class">.go</span>:<span class="number">13</span> +<span class="number">0</span>x20</span><br></pre></td></tr></table></figure>

<p>你也许想知道，是否可以恢复一个运行时 panic？当然可以！我们来修改一下上面的代码，恢复这个 panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">r</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Recovered&quot;</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> r()</span><br><span class="line">    n := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(n[<span class="number">3</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a()</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面程序会输出：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyRecovered runtime error: <span class="keyword">index</span> <span class="keyword">out</span> <span class="keyword">of</span> range  </span><br><span class="line">normally returned <span class="keyword">from</span> main</span><br></pre></td></tr></table></figure>

<p>从输出可以知道，我们已经恢复了这个 panic。</p>
<h2 id="恢复后获得堆栈跟踪"><a href="#恢复后获得堆栈跟踪" class="headerlink" title="恢复后获得堆栈跟踪"></a>恢复后获得堆栈跟踪</h2><p>当我们恢复 panic 时，我们就释放了它的堆栈跟踪。实际上，在上述程序里，恢复 panic 之后，我们就失去了堆栈跟踪。</p>
<p>有办法可以打印出堆栈跟踪，就是使用 [<code>Debug</code>]包中的 [<code>PrintStack</code>]函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/debug&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">r</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Recovered&quot;</span>, r)</span><br><span class="line">        debug.PrintStack()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">defer</span> r()</span><br><span class="line">    n := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>&#125;</span><br><span class="line">    fmt.Println(n[<span class="number">3</span>])</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a()</span><br><span class="line">    fmt.Println(<span class="string">&quot;normally returned from main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们在第 11 行使用了 <code>debug.PrintStack()</code> 打印堆栈跟踪。</p>
<p>该程序会输出：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CopyRecovered <span class="keyword">runtime</span> error: index out of range  </span><br><span class="line">goroutine <span class="number">1</span> [running]:  </span><br><span class="line"><span class="keyword">runtime</span>/debug.Stack(<span class="number">0</span>x1042beb8, <span class="number">0</span>x2, <span class="number">0</span>x2, <span class="number">0</span>x1c)  </span><br><span class="line">    <span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/runtime/</span>debug/stack.go:<span class="number">24</span> +<span class="number">0</span>xc0</span><br><span class="line"><span class="keyword">runtime</span>/debug.PrintStack()  </span><br><span class="line">    <span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/runtime/</span>debug/stack.go:<span class="number">16</span> +<span class="number">0</span>x20</span><br><span class="line">main.r()  </span><br><span class="line">    <span class="regexp">/tmp/</span>sandbox949178097/main.go:<span class="number">11</span> +<span class="number">0</span>xe0</span><br><span class="line">panic(<span class="number">0</span>xf0a80, <span class="number">0</span>x17cd50)  </span><br><span class="line">    <span class="regexp">/usr/</span>local<span class="regexp">/go/</span>src<span class="regexp">/runtime/</span>panic.go:<span class="number">491</span> +<span class="number">0</span>x2c0</span><br><span class="line">main.a()  </span><br><span class="line">    <span class="regexp">/tmp/</span>sandbox949178097/main.go:<span class="number">18</span> +<span class="number">0</span>x80</span><br><span class="line">main.main()  </span><br><span class="line">    <span class="regexp">/tmp/</span>sandbox949178097/main.go:<span class="number">23</span> +<span class="number">0</span>x20</span><br><span class="line">normally returned <span class="keyword">from</span> main</span><br></pre></td></tr></table></figure>

<p>从输出我们可以看出，首先已经恢复了 panic，打印出 <code>Recovered runtime error: index out of range</code>。此外，我们也打印出了堆栈跟踪。在恢复了 panic 之后，还打印出 <code>normally returned from main</code>。</p>
<p>本教程到此结束。</p>
<p>简单概括一下本教程讨论的内容：</p>
<ul>
<li>什么是 panic？</li>
<li>什么时候应该使用 panic？</li>
<li>panic 示例</li>
<li>发生 panic 时的 defer</li>
<li>recover</li>
<li>panic，recover 和 Go 协程</li>
<li>运行时 panic</li>
<li>恢复后获得堆栈跟踪</li>
</ul>
<h1 id="33-函数是一等公民（头等函数）"><a href="#33-函数是一等公民（头等函数）" class="headerlink" title="33. 函数是一等公民（头等函数）"></a>33. 函数是一等公民（头等函数）</h1><p>现在简单概括一下本教程讨论的内容：</p>
<ul>
<li>什么是头等函数？</li>
<li>匿名函数</li>
<li>用户自定义的函数类型</li>
<li>高阶函数<ul>
<li>把函数作为参数，传递给其它函数</li>
<li>在其它函数中返回函数</li>
</ul>
</li>
<li>闭包</li>
<li>头等函数的实际用途</li>
</ul>
<h2 id="什么是头等函数？"><a href="#什么是头等函数？" class="headerlink" title="什么是头等函数？"></a>什么是头等函数？</h2><p><strong>支持头等函数（First Class Function）的编程语言，可以把函数赋值给变量，也可以把函数作为其它函数的参数或者返回值。Go 语言支持头等函数的机制</strong>。</p>
<p>本教程我们会讨论头等函数的语法和用例。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>我们来编写一个简单的示例，把函数赋值给一个变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello world first class function&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    a()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们将一个函数赋值给了变量 <code>a</code>（第 8 行）。这是把函数赋值给变量的语法。你如果观察得仔细的话，会发现赋值给 <code>a</code> 的函数没有名称。<strong>由于没有名称，这类函数称为匿名函数（Anonymous Function）</strong>。</p>
<p>调用该函数的唯一方法就是使用变量 <code>a</code>。我们在下一行调用了它。<code>a()</code> 调用了这个函数，打印出 <code>hello world first class function</code>。在第 12 行，我们打印出 <code>a</code> 的类型。这会输出 <code>func()</code>。</p>
<p>运行该程序，会输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyhello world first <span class="keyword">class</span> <span class="symbol">function</span></span><br><span class="line"><span class="symbol">func</span>()</span><br></pre></td></tr></table></figure>

<p>要调用一个匿名函数，可以不用赋值给变量。通过下面的例子，我们看看这是怎么做到的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;hello world first class function&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，第 8 行定义了一个匿名函数，并在定义之后，我们使用 <code>()</code> 立即调用了该函数（第 10 行）。该程序会输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyhello world first <span class="keyword">class</span> <span class="symbol">function</span></span><br></pre></td></tr></table></figure>

<p>就像其它函数一样，还可以向匿名函数传递参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Welcome&quot;</span>, n)</span><br><span class="line">    &#125;(<span class="string">&quot;Gophers&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们向匿名函数传递了一个字符串参数（第 10 行）。运行该程序后会输出：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyWelcome Gophers</span></span><br></pre></td></tr></table></figure>

<h2 id="用户自定义的函数类型"><a href="#用户自定义的函数类型" class="headerlink" title="用户自定义的函数类型"></a>用户自定义的函数类型</h2><p>正如我们定义自己的结构体类型一样，我们可以定义自己的函数类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copytype add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>以上代码片段创建了一个新的函数类型 <code>add</code>，它接收两个整型参数，并返回一个整型。现在我们来定义 <code>add</code> 类型的变量。</p>
<p>我们来编写一个程序，定义一个 <code>add</code> 类型的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a add = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    s := a(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sum&quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 10 行，我们定义了一个 <code>add</code> 类型的变量 <code>a</code>，并向它赋值了一个符合 <code>add</code> 类型签名的函数。我们在第 13 行调用了该函数，并将结果赋值给 <code>s</code>。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopySum</span> <span class="number">11</span></span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数（Hiher-order Function）定义为：<strong>满足下列条件之一的函数</strong>：</p>
<ul>
<li><strong>接收一个或多个函数作为参数</strong></li>
<li><strong>返回值是一个函数</strong></li>
</ul>
<p>针对上述两种情况，我们看看一些简单实例。</p>
<h3 id="把函数作为参数，传递给其它函数"><a href="#把函数作为参数，传递给其它函数" class="headerlink" title="把函数作为参数，传递给其它函数"></a>把函数作为参数，传递给其它函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simple</span><span class="params">(a <span class="keyword">func</span>(a, b <span class="type">int</span>)</span></span> <span class="type">int</span>) &#123;  </span><br><span class="line">    fmt.Println(a(<span class="number">60</span>, <span class="number">7</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    simple(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实例中，第 7 行我们定义了一个函数 <code>simple</code>，<code>simple</code> 接收一个函数参数（该函数接收两个 <code>int</code> 参数，返回一个 <code>a</code> 整型）。在 <code>main</code> 函数的第 12 行，我们创建了一个匿名函数 <code>f</code>，其签名符合 <code>simple</code> 函数的参数。我们在下一行调用了 <code>simple</code>，并传递了参数 <code>f</code>。该程序打印输出 67。</p>
<h3 id="在其它函数中返回函数"><a href="#在其它函数中返回函数" class="headerlink" title="在其它函数中返回函数"></a>在其它函数中返回函数</h3><p>现在我们重写上面的代码，在 <code>simple</code> 函数中返回一个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">simple</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    f := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := simple()</span><br><span class="line">    fmt.Println(s(<span class="number">60</span>, <span class="number">7</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，第 7 行的 <code>simple</code> 函数返回了一个函数，并接受两个 <code>int</code> 参数，返回一个 <code>int</code>。</p>
<p>在第 15 行，我们调用了 <code>simple</code> 函数。我们把 <code>simple</code> 的返回值赋值给了 <code>s</code>。现在 <code>s</code> 包含了 <code>simple</code> 函数返回的函数。我们调用了 <code>s</code>，并向它传递了两个 int 参数（第 16 行）。该程序输出 67。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（Closure）是匿名函数的一个特例。当一个匿名函数所访问的变量定义在函数体的外部时，就称这样的匿名函数为闭包。</p>
<p>看看一个示例就明白了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">5</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;a =&quot;</span>, a)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，匿名函数在第 10 行访问了变量 <code>a</code>，而 <code>a</code> 存在于函数体的外部。因此这个匿名函数就是闭包。</p>
<p>每一个闭包都会绑定一个它自己的外围变量（Surrounding Variable）。我们通过一个简单示例来体会这句话的含义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendStr</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">    t := <span class="string">&quot;Hello&quot;</span></span><br><span class="line">    c := <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">        t = t + <span class="string">&quot; &quot;</span> + b</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := appendStr()</span><br><span class="line">    b := appendStr()</span><br><span class="line">    fmt.Println(a(<span class="string">&quot;World&quot;</span>))</span><br><span class="line">    fmt.Println(b(<span class="string">&quot;Everyone&quot;</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(a(<span class="string">&quot;Gopher&quot;</span>))</span><br><span class="line">    fmt.Println(b(<span class="string">&quot;!&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，函数 <code>appendStr</code> 返回了一个闭包。这个闭包绑定了变量 <code>t</code>。我们来理解这是什么意思。</p>
<p>在第 17 行和第 18 行声明的变量 <code>a</code> 和 <code>b</code> 都是闭包，它们绑定了各自的 <code>t</code> 值。</p>
<p>我们首先用参数 <code>World</code> 调用了 <code>a</code>。现在 <code>a</code> 中 <code>t</code> 值变为了 <code>Hello World</code>。</p>
<p>在第 20 行，我们又用参数 <code>Everyone</code> 调用了 <code>b</code>。由于 <code>b</code> 绑定了自己的变量 <code>t</code>，因此 <code>b</code> 中的 <code>t</code> 还是等于初始值 <code>Hello</code>。于是该函数调用之后，<code>b</code> 中的 <code>t</code> 变为了 <code>Hello Everyone</code>。程序的其他部分很简单，不再解释。</p>
<p>该程序会输出：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyHello World  </span><br><span class="line">Hello Everyone  </span><br><span class="line">Hello World Gopher  </span><br><span class="line">Hello Everyone !</span><br></pre></td></tr></table></figure>

<h2 id="头等函数的实际用途"><a href="#头等函数的实际用途" class="headerlink" title="头等函数的实际用途"></a>头等函数的实际用途</h2><p>迄今为止，我们已经定义了什么是头等函数，也看了一些专门设计的示例，来学习它们如何工作。现在我们来编写一些实际的程序，来展现头等函数的实际用处。</p>
<p>我们会创建一个程序，基于一些条件，来过滤一个 <code>students</code> 切片。现在我们来逐步实现它。</p>
<p>首先定义一个 <code>student</code> 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copytype student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">    grade <span class="type">string</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是编写一个 <code>filter</code> 函数。该函数接收一个 <code>students</code> 切片和一个函数作为参数，这个函数会计算一个学生是否满足筛选条件。写出这个函数后，你很快就会明白，我们继续吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc filter(s []student, f <span class="function"><span class="keyword">func</span><span class="params">(student)</span></span> <span class="type">bool</span>) []student &#123;  </span><br><span class="line">    <span class="keyword">var</span> r []student</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> f(v) == <span class="literal">true</span> &#123;</span><br><span class="line">            r = <span class="built_in">append</span>(r, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的函数中，<code>filter</code> 的第二个参数是一个函数。这个函数接收 <code>student</code> 参数，返回一个 <code>bool</code> 值。这个函数计算了某一学生是否满足筛选条件。我们在第 3 行遍历了 <code>student</code> 切片，将每个学生作为参数传递给了函数 <code>f</code>。如果该函数返回 <code>true</code>，就表示该学生通过了筛选条件，接着将该学生添加到了结果切片 <code>r</code> 中。你可能会很困惑这个函数的实际用途，等我们完成程序你就知道了。我添加了 <code>main</code> 函数，整个程序如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName  <span class="type">string</span></span><br><span class="line">    grade     <span class="type">string</span></span><br><span class="line">    country   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(s []student, f <span class="keyword">func</span>(student)</span></span> <span class="type">bool</span>) []student &#123;  </span><br><span class="line">    <span class="keyword">var</span> r []student</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="keyword">if</span> f(v) == <span class="literal">true</span> &#123;</span><br><span class="line">            r = <span class="built_in">append</span>(r, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s1 := student&#123;</span><br><span class="line">        firstName: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        lastName:  <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">        grade:     <span class="string">&quot;A&quot;</span>,</span><br><span class="line">        country:   <span class="string">&quot;India&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    s2 := student&#123;</span><br><span class="line">        firstName: <span class="string">&quot;Samuel&quot;</span>,</span><br><span class="line">        lastName:  <span class="string">&quot;Johnson&quot;</span>,</span><br><span class="line">        grade:     <span class="string">&quot;B&quot;</span>,</span><br><span class="line">        country:   <span class="string">&quot;USA&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    s := []student&#123;s1, s2&#125;</span><br><span class="line">    f := filter(s, <span class="function"><span class="keyword">func</span><span class="params">(s student)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> s.grade == <span class="string">&quot;B&quot;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main</code> 函数中，我们首先创建了两个学生 <code>s1</code> 和 <code>s2</code>，并将他们添加到了切片 <code>s</code>。现在假设我们想要查询所有成绩为 <code>B</code> 的学生。为了实现这样的功能，我们传递了一个检查学生成绩是否为 <code>B</code> 的函数，如果是，该函数会返回 <code>true</code>。我们把这个函数作为参数传递给了 <code>filter</code> 函数（第 38 行）。上述程序会输出：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy[&#123;Samuel <span class="keyword">Johnson </span><span class="keyword">B </span>USA&#125;]</span><br></pre></td></tr></table></figure>

<p>假设我们想要查找所有来自印度的学生。通过修改传递给 <code>filter</code> 的函数参数，就很容易地实现了。</p>
<p>实现它的代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copyc := filter(s, <span class="function"><span class="keyword">func</span><span class="params">(s student)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> s.country == <span class="string">&quot;India&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(c)</span><br></pre></td></tr></table></figure>

<p>请将该函数添加到 <code>main</code> 函数，并检查它的输出。</p>
<p>我们最后再编写一个程序，来结束这一节的讨论。这个程序会对切片的每个元素执行相同的操作，并返回结果。例如，如果我们希望将切片中的所有整数乘以 5，并返回出结果，那么通过头等函数可以很轻松地实现。我们把这种对集合中的每个元素进行操作的函数称为 <code>map</code> 函数。相关代码如下所示，它们很容易看懂。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iMap</span><span class="params">(s []<span class="type">int</span>, f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">int</span>) []<span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> r []<span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        r = <span class="built_in">append</span>(r, f(v))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    r := iMap(a, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="number">5</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy</span>[<span class="number">25</span> <span class="number">30</span> <span class="number">35</span> <span class="number">40</span> <span class="number">45</span>]</span><br></pre></td></tr></table></figure>

<h1 id="34-反射"><a href="#34-反射" class="headerlink" title="34. 反射"></a>34. 反射</h1><p>反射是 Go 语言的高级主题之一。</p>
<p>分为如下小节。</p>
<ul>
<li>什么是反射？</li>
<li>为何需要检查变量，确定变量的类型？</li>
<li>reflect 包<ul>
<li>reflect.Type 和 reflect.Value</li>
<li>reflect.Kind</li>
<li>NumField() 和 Field() 方法</li>
<li>Int() 和 String() 方法</li>
</ul>
</li>
<li>完整的程序</li>
<li>我们应该使用反射吗？</li>
</ul>
<h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><p>反射就是程序能够在运行时检查变量和值，求出它们的类型。你可能还不太懂，这没关系。在本教程结束后，你就会清楚地理解反射，所以跟着我们的教程学习吧。</p>
<h2 id="为何需要检查变量，确定变量的类型？"><a href="#为何需要检查变量，确定变量的类型？" class="headerlink" title="为何需要检查变量，确定变量的类型？"></a>为何需要检查变量，确定变量的类型？</h2><p>在学习反射时，所有人首先面临的疑惑就是：如果程序中每个变量都是我们自己定义的，那么在编译时就可以知道变量类型了，为什么我们还需要在运行时检查变量，求出它的类型呢？没错，在大多数时候都是这样，但并非总是如此。</p>
<p>我来解释一下吧。下面我们编写一个简单的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %T&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>i</code> 的类型在编译时就知道了，然后我们在下一行打印出 <code>i</code>。这里没什么特别之处。</p>
<p>现在了解一下，需要在运行时求得变量类型的情况。假如我们要编写一个简单的函数，它接收结构体作为参数，并用它来创建一个 SQL 插入查询。</p>
<p>考虑下面的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">1234</span>,</span><br><span class="line">        customerId: <span class="number">567</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们需要编写一个函数，接收结构体变量 <code>o</code> 作为参数，返回下面的 SQL 插入查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">order</span> <span class="keyword">values</span>(<span class="number">1234</span>, <span class="number">567</span>)</span><br></pre></td></tr></table></figure>

<p>这个函数写起来很简单。我们现在编写这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(o order)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    i := fmt.Sprintf(<span class="string">&quot;insert into order values(%d, %d)&quot;</span>, o.ordId, o.customerId)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">1234</span>,</span><br><span class="line">        customerId: <span class="number">567</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(createQuery(o))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 12 行，<code>createQuery</code> 函数用 <code>o</code> 的两个字段（<code>ordId</code> 和 <code>customerId</code>），创建了插入查询。该程序会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyinsert into order values(1234, 567)</span><br></pre></td></tr></table></figure>

<p>现在我们来升级这个查询生成器。如果我们想让它变得通用，可以适用于任何结构体类型，该怎么办呢？我们用程序来理解一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    id <span class="type">int</span></span><br><span class="line">    address <span class="type">string</span></span><br><span class="line">    salary <span class="type">int</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的目标就是完成 <code>createQuery</code> 函数（上述程序中的第 16 行），它可以接收任何结构体作为参数，根据结构体的字段创建插入查询。</p>
<p>例如，如果我们传入下面的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyo := order &#123;</span><br><span class="line">    ordId: <span class="number">1234</span>,</span><br><span class="line">    customerId: <span class="number">567</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createQuery</code> 函数应该返回：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">order</span> <span class="keyword">values</span> (<span class="number">1234</span>, <span class="number">567</span>)</span><br></pre></td></tr></table></figure>

<p>类似地，如果我们传入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copy e := employee &#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        id: <span class="number">565</span>,</span><br><span class="line">        address: <span class="string">&quot;Science Park Road, Singapore&quot;</span>,</span><br><span class="line">        salary: <span class="number">90000</span>,</span><br><span class="line">        country: <span class="string">&quot;Singapore&quot;</span>,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该函数会返回：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(&quot;Naveen&quot;, <span class="number">565</span>, &quot;Science Park Road, Singapore&quot;, <span class="number">90000</span>, &quot;Singapore&quot;)</span><br></pre></td></tr></table></figure>

<p>由于 <code>createQuery</code> 函数应该适用于任何结构体，因此它接收 <code>interface&#123;&#125;</code> 作为参数。为了简单起见，我们只处理包含 <code>string</code> 和 <code>int</code> 类型字段的结构体，但可以扩展为包含任何类型的字段。</p>
<p><code>createQuery</code> 函数应该适用于所有的结构体。因此，要编写这个函数，就必须在运行时检查传递过来的结构体参数的类型，找到结构体字段，接着创建查询。这时就需要用到反射了。在本教程的下一步，我们将会学习如何使用 <code>reflect</code> 包来实现它。</p>
<h2 id="reflect-包"><a href="#reflect-包" class="headerlink" title="reflect 包"></a>reflect 包</h2><p>在 Go 语言中，<code>reflect</code>实现了运行时反射。<code>reflect</code> 包会帮助识别 <code>interface&#123;&#125;</code>变量的底层具体类型和具体值。这正是我们所需要的。<code>createQuery</code> 函数接收 <code>interface&#123;&#125;</code> 参数，根据它的具体类型和具体值，创建 SQL 查询。这正是 <code>reflect</code> 包能够帮助我们的地方。</p>
<p>在编写我们通用的查询生成器之前，我们首先需要了解 <code>reflect</code> 包中的几种类型和方法。让我们来逐个了解。</p>
<h3 id="reflect-Type-和-reflect-Value"><a href="#reflect-Type-和-reflect-Value" class="headerlink" title="reflect.Type 和 reflect.Value"></a>reflect.Type 和 reflect.Value</h3><p><code>reflect.Type</code> 表示 <code>interface&#123;&#125;</code> 的具体类型，而 <code>reflect.Value</code> 表示它的具体值。<code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> 两个函数可以分别返回 <code>reflect.Type</code> 和 <code>reflect.Value</code>。这两种类型是我们创建查询生成器的基础。我们现在用一个简单的例子来理解这两种类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    t := reflect.TypeOf(q)</span><br><span class="line">    v := reflect.ValueOf(q)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Type &quot;</span>, t)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Value &quot;</span>, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，第 13 行的 <code>createQuery</code> 函数接收 <code>interface&#123;&#125;</code> 作为参数。在第 14 行，<code>reflect.TypeOf</code> 接收了参数 <code>interface&#123;&#125;</code>，返回了<code>reflect.Type</code>，它包含了传入的 <code>interface&#123;&#125;</code> 参数的具体类型。同样地，在第 15 行，<code>reflect.ValueOf</code>函数接收参数 <code>interface&#123;&#125;</code>，并返回了 <code>reflect.Value</code>，它包含了传来的 <code>interface&#123;&#125;</code> 的具体值。</p>
<p>上述程序会打印：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyType  main.<span class="keyword">order</span></span><br><span class="line"><span class="title">Value</span>  &#123;<span class="number">456</span> <span class="number">56</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从输出我们可以看到，程序打印了接口的具体类型和具体值。</p>
<h3 id="relfect-Kind"><a href="#relfect-Kind" class="headerlink" title="relfect.Kind"></a>relfect.Kind</h3><p><code>reflect</code> 包中还有一个重要的类型：<code>Kind</code>。</p>
<p>在反射包中，<code>Kind</code> 和 <code>Type</code> 的类型可能看起来很相似，但在下面程序中，可以很清楚地看出它们的不同之处。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    t := reflect.TypeOf(q)</span><br><span class="line">    k := t.Kind()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Type &quot;</span>, t)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Kind &quot;</span>, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序会输出：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyType  main.<span class="keyword">order</span></span><br><span class="line"><span class="title">Kind</span>  struct</span><br></pre></td></tr></table></figure>

<p>我想你应该很清楚两者的区别了。<code>Type</code> 表示 <code>interface&#123;&#125;</code> 的实际类型（在这里是 <strong>main.Order</strong>)，而 <code>Kind</code> 表示该类型的特定类别（在这里是 <strong>struct</strong>）。</p>
<h3 id="NumField-和-Field-方法"><a href="#NumField-和-Field-方法" class="headerlink" title="NumField() 和 Field() 方法"></a>NumField() 和 Field() 方法</h3><p><code>NumField()</code>方法返回结构体中字段的数量，而 <code>Field(i int)</code>方法返回字段 <code>i</code> 的 <code>reflect.Value</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;</span><br><span class="line">        v := reflect.ValueOf(q)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Number of fields&quot;</span>, v.NumField())</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Field:%d type:%T value:%v\n&quot;</span>, i, v.Field(i), v.Field(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，因为 <code>NumField</code> 方法只能在结构体上使用，我们在第 14 行首先检查了 <code>q</code> 的类别是 <code>struct</code>。程序的其他代码很容易看懂，不作解释。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyNumber</span> of fields <span class="number">2</span></span><br><span class="line"><span class="attribute">Field</span>:<span class="number">0</span> type:reflect.Value value:<span class="number">456</span></span><br><span class="line"><span class="attribute">Field</span>:<span class="number">1</span> type:reflect.Value value:<span class="number">56</span></span><br></pre></td></tr></table></figure>

<h3 id="Int-和-String-方法"><a href="#Int-和-String-方法" class="headerlink" title="Int() 和 String() 方法"></a>Int() 和 String() 方法</h3><p><code>Int</code>和 <code>String</code>可以帮助我们分别取出 <code>reflect.Value</code> 作为 <code>int64</code> 和 <code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">56</span></span><br><span class="line">    x := reflect.ValueOf(a).Int()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, x, x)</span><br><span class="line">    b := <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    y := reflect.ValueOf(b).String()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type:%T value:%v\n&quot;</span>, y, y)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 10 行，我们取出 <code>reflect.Value</code>，并转换为 <code>int64</code>，而在第 13 行，我们取出 <code>reflect.Value</code> 并将其转换为 <code>string</code>。该程序会输出：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copytype<span class="operator">:</span><span class="type">int64</span> value<span class="operator">:</span>56</span><br><span class="line"><span class="keyword">type</span><span class="operator">:</span><span class="type">string</span> value<span class="operator">:</span>Naveen</span><br></pre></td></tr></table></figure>

<h2 id="完整的程序"><a href="#完整的程序" class="headerlink" title="完整的程序"></a>完整的程序</h2><p>现在我们已经具备足够多的知识，来完成我们的查询生成器了，我们来实现它把。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> order <span class="keyword">struct</span> &#123;</span><br><span class="line">    ordId      <span class="type">int</span></span><br><span class="line">    customerId <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name    <span class="type">string</span></span><br><span class="line">    id      <span class="type">int</span></span><br><span class="line">    address <span class="type">string</span></span><br><span class="line">    salary  <span class="type">int</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createQuery</span><span class="params">(q <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> reflect.ValueOf(q).Kind() == reflect.Struct &#123;</span><br><span class="line">        t := reflect.TypeOf(q).Name()</span><br><span class="line">        query := fmt.Sprintf(<span class="string">&quot;insert into %s values(&quot;</span>, t)</span><br><span class="line">        v := reflect.ValueOf(q)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">            <span class="keyword">switch</span> v.Field(i).Kind() &#123;</span><br><span class="line">            <span class="keyword">case</span> reflect.Int:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">&quot;%s%d&quot;</span>, query, v.Field(i).Int())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">&quot;%s, %d&quot;</span>, query, v.Field(i).Int())</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> reflect.String:</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">&quot;%s\&quot;%s\&quot;&quot;</span>, query, v.Field(i).String())</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    query = fmt.Sprintf(<span class="string">&quot;%s, \&quot;%s\&quot;&quot;</span>, query, v.Field(i).String())</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fmt.Println(<span class="string">&quot;Unsupported type&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        query = fmt.Sprintf(<span class="string">&quot;%s)&quot;</span>, query)</span><br><span class="line">        fmt.Println(query)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;unsupported type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    o := order&#123;</span><br><span class="line">        ordId:      <span class="number">456</span>,</span><br><span class="line">        customerId: <span class="number">56</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(o)</span><br><span class="line"></span><br><span class="line">    e := employee&#123;</span><br><span class="line">        name:    <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        id:      <span class="number">565</span>,</span><br><span class="line">        address: <span class="string">&quot;Coimbatore&quot;</span>,</span><br><span class="line">        salary:  <span class="number">90000</span>,</span><br><span class="line">        country: <span class="string">&quot;India&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    createQuery(e)</span><br><span class="line">    i := <span class="number">90</span></span><br><span class="line">    createQuery(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 22 行，我们首先检查了传来的参数是否是一个结构体。在第 23 行，我们使用了 <code>Name()</code> 方法，从该结构体的 <code>reflect.Type</code> 获取了结构体的名字。接下来一行，我们用 <code>t</code> 来创建查询。</p>
<p>在第 28 行，<code>case 语句</code>检查了当前字段是否为 <code>reflect.Int</code>，如果是的话，我们会取到该字段的值，并使用 <code>Int()</code> 方法转换为 <code>int64</code>。if else 语句用于处理边界情况。请添加日志来理解为什么需要它。在第 34 行，我们用来相同的逻辑来取到 <code>string</code>。</p>
<p>我们还作了额外的检查，以防止 <code>createQuery</code> 函数传入不支持的类型时，程序发生崩溃。程序的其他代码是自解释性的。我建议你在合适的地方添加日志，检查输出，来更好地理解这个程序。</p>
<p>该程序会输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">order</span> <span class="keyword">values</span>(<span class="number">456</span>, <span class="number">56</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(&quot;Naveen&quot;, <span class="number">565</span>, &quot;Coimbatore&quot;, <span class="number">90000</span>, &quot;India&quot;)</span><br><span class="line">unsupported type</span><br></pre></td></tr></table></figure>

<p>至于向输出的查询中添加字段名，我们把它留给读者作为练习。请尝试着修改程序，打印出以下格式的查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Copy</span><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">order</span>(ordId, customerId) <span class="keyword">values</span>(<span class="number">456</span>, <span class="number">56</span>)</span><br></pre></td></tr></table></figure>

<h2 id="我们应该使用反射吗？"><a href="#我们应该使用反射吗？" class="headerlink" title="我们应该使用反射吗？"></a>我们应该使用反射吗？</h2><p>我们已经展示了反射的实际应用，现在考虑一个很现实的问题。我们应该使用反射吗？我想引用 <code>Rob Pike</code>关于使用反射的格言，来回答这个问题。</p>
<blockquote>
<p>清晰优于聪明。而反射并不是一目了然的。</p>
</blockquote>
<p>反射是 Go 语言中非常强大和高级的概念，我们应该小心谨慎地使用它。使用反射编写清晰和可维护的代码是十分困难的。你应该尽可能避免使用它，只在必须用到它时，才使用反射。</p>
<h1 id="35-读取文件"><a href="#35-读取文件" class="headerlink" title="35. 读取文件"></a>35. 读取文件</h1><p>文件读取是所有编程语言中最常见的操作之一。本教程我们会学习如何使用 Go 读取文件。</p>
<p>本教程分为如下小节。</p>
<ul>
<li>将整个文件读取到内存<ul>
<li>使用绝对文件路径</li>
<li>使用命令行标记来传递文件路径</li>
<li>将文件绑定在二进制文件中</li>
</ul>
</li>
<li>分块读取文件</li>
<li>逐行读取文件</li>
</ul>
<h2 id="将整个文件读取到内存"><a href="#将整个文件读取到内存" class="headerlink" title="将整个文件读取到内存"></a>将整个文件读取到内存</h2><p>将整个文件读取到内存是最基本的文件操作之一。这需要使用 <code>ioutil</code>]包中的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/io/ioutil/#ReadFile"><code>ReadFile</code></a> 函数。</p>
<p>让我们在 Go 程序所在的目录中，读取一个文件。我已经在 GOPATH（译注：原文是 GOROOT，应该是笔误）中创建了文件夹，在该文件夹内部，有一个文本文件 <code>test.txt</code>，我们会使用 Go 程序 <code>filehandling.go</code> 来读取它。<code>test.txt</code> 包含文本 “Hello World. Welcome to file handling in Go”。我的文件夹结构如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copysrc</span><br><span class="line">    filehandling</span><br><span class="line">        filehandling.go</span><br><span class="line">        <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>

<p>接下来我们来看看代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;File reading error&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Contents of file:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于无法在 playground 上读取文件，因此请在你的本地环境运行这个程序。</p>
<p>在上述程序的第 9 行，程序会读取文件，并返回一个字节<a target="_blank" rel="noopener" href="https://studygolang.com/articles/12121">切片</a>，而这个切片保存在 <code>data</code> 中。在第 14 行，我们将 <code>data</code> 转换为 <code>string</code>，显示出文件的内容。</p>
<p>请在 <strong>test.txt</strong> 所在的位置运行该程序。</p>
<p>例如，对于 <strong>linux/mac</strong>，如果 <strong>test.txt</strong> 位于 <strong>/home/naveen/go/src/filehandling</strong>，可以使用下列步骤来运行程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy$ <span class="built_in">cd</span> /home/naveen/go/src/filehandling/</span><br><span class="line">$ go install filehandling</span><br><span class="line">$ workspacepath/bin/filehandling</span><br></pre></td></tr></table></figure>

<p>对于 <strong>windows</strong>，如果 <strong>test.txt</strong> 位于 <strong>C:\Users\naveen.r\go\src\filehandling</strong>，则使用下列步骤。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy&gt; <span class="built_in">cd</span> C:\Users\naveen.r\go\src\filehandling</span><br><span class="line">&gt; go install filehandling</span><br><span class="line">&gt; workspacepath\bin\filehandling.exe</span><br></pre></td></tr></table></figure>

<p>该程序会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyContents of file: Hello World. Welcome to file handling in Go.</span><br></pre></td></tr></table></figure>

<p>如果在其他位置运行这个程序（比如 <code>/home/userdirectory</code>），会打印下面的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyFile reading error open test.txt: The system cannot find the file specified.</span><br></pre></td></tr></table></figure>

<p>这是因为 Go 是编译型语言。<code>go install</code> 会根据源代码创建一个二进制文件。二进制文件独立于源代码，可以在任何位置上运行。由于在运行二进制文件的位置上没有找到 <code>test.txt</code>，因此程序会报错，提示无法找到指定的文件。</p>
<p>有三种方法可以解决这个问题。</p>
<ol>
<li>使用绝对文件路径</li>
<li>使用命令行标记来传递文件路径</li>
<li>将文件绑定在二进制文件中</li>
</ol>
<p>让我们来依次介绍。</p>
<h3 id="1-使用绝对文件路径"><a href="#1-使用绝对文件路径" class="headerlink" title="1. 使用绝对文件路径"></a>1. 使用绝对文件路径</h3><p>要解决问题，最简单的方法就是传入绝对文件路径。我已经修改了程序，把路径改成了绝对路径。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">&quot;/home/naveen/go/src/filehandling/test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;File reading error&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Contents of file:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以在任何位置上运行程序，打印出 <code>test.txt</code> 的内容。</p>
<p>例如，可以在我的家目录运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copy$ <span class="built_in">cd</span> <span class="variable">$HOME</span></span><br><span class="line">$ go install filehandling</span><br><span class="line">$ workspacepath/bin/filehandling</span><br></pre></td></tr></table></figure>

<p>该程序打印出了 <code>test.txt</code> 的内容。</p>
<p>看似这是一个简单的方法，但它的缺点是：文件必须放在程序指定的路径中，否则就会出错。</p>
<h3 id="2-使用命令行标记来传递文件路径"><a href="#2-使用命令行标记来传递文件路径" class="headerlink" title="2. 使用命令行标记来传递文件路径"></a>2. 使用命令行标记来传递文件路径</h3><p>另一种解决方案是使用命令行标记来传递文件路径。使用 <a target="_blank" rel="noopener" href="https://golang.org/pkg/flag/">flag</a> 包，我们可以从输入的命令行获取到文件路径，接着读取文件内容。</p>
<p>首先我们来看看 <code>flag</code> 包是如何工作的。<code>flag</code> 包有一个名为 <a target="_blank" rel="noopener" href="https://golang.org/pkg/flag/#String"><code>String</code></a> 的<a target="_blank" rel="noopener" href="https://studygolang.com/articles/11892">函数</a>。该函数接收三个参数。第一个参数是标记名，第二个是默认值，第三个是标记的简短描述。</p>
<p>让我们来编写程序，从命令行读取文件名。将 <code>filehandling.go</code> 的内容替换如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fptr := flag.String(<span class="string">&quot;fpath&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;file path to read from&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of fpath is&quot;</span>, *fptr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中第 8 行，通过 <code>String</code> 函数，创建了一个字符串标记，名称是 <code>fpath</code>，默认值是 <code>test.txt</code>，描述为 <code>file path to read from</code>。这个函数返回存储 flag 值的字符串<a target="_blank" rel="noopener" href="https://studygolang.com/articles/11756">变量</a>的地址。</p>
<p>在程序访问 flag 之前，必须先调用 <code>flag.Parse()</code>。</p>
<p>在第 10 行，程序会打印出 flag 值。</p>
<p>使用下面命令运行程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copywrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span><br></pre></td></tr></table></figure>

<p>我们传入 <code>/path-of-file/test.txt</code>，赋值给了 <code>fpath</code> 标记。</p>
<p>该程序输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyvalue of fpath is /path-of-file/test.txt</span><br></pre></td></tr></table></figure>

<p>这是因为 <code>fpath</code> 的默认值是 <code>test.txt</code>。</p>
<p>现在我们知道如何从命令行读取文件路径了，让我们继续完成我们的文件读取程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fptr := flag.String(<span class="string">&quot;fpath&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;file path to read from&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    data, err := ioutil.ReadFile(*fptr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;File reading error&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Contents of file:&quot;</span>, <span class="type">string</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序里，命令行传入文件路径，程序读取了该文件的内容。使用下面命令运行该程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copywrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span><br></pre></td></tr></table></figure>

<p>请将 <code>/path-of-file/</code> 替换为 <code>test.txt</code> 的真实路径。该程序将打印：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyContents of file: Hello World. Welcome to file handling in Go.</span><br></pre></td></tr></table></figure>

<h3 id="3-将文件绑定在二进制文件中"><a href="#3-将文件绑定在二进制文件中" class="headerlink" title="3. 将文件绑定在二进制文件中"></a>3. 将文件绑定在二进制文件中</h3><p>虽然从命令行获取文件路径的方法很好，但还有一种更好的解决方法。如果我们能够将文本文件捆绑在二进制文件，岂不是很棒？这就是我们下面要做的事情。</p>
<p>有很多<a target="_blank" rel="noopener" href="https://studygolang.com/articles/11893">包</a>可以帮助我们实现。我们会使用 <a target="_blank" rel="noopener" href="https://github.com/gobuffalo/packr">packr</a>，因为它很简单，并且我在项目中使用它时，没有出现任何问题。</p>
<p>第一步就是安装 <code>packr</code> 包。</p>
<p>在命令提示符中输入下面命令，安装 <code>packr</code> 包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copygo get -u github.com/gobuffalo/packr/...</span><br></pre></td></tr></table></figure>

<p><code>packr</code> 会把静态文件（例如 <code>.txt</code> 文件）转换为 <code>.go</code> 文件，接下来，<code>.go</code> 文件会直接嵌入到二进制文件中。<code>packer</code> 非常智能，在开发过程中，可以从磁盘而非二进制文件中获取静态文件。在开发过程中，当仅仅静态文件变化时，可以不必重新编译。</p>
<p>我们通过程序来更好地理解它。用以下内容来替换 <code>handling.go</code> 文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gobuffalo/packr&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    box := packr.NewBox(<span class="string">&quot;../filehandling&quot;</span>)</span><br><span class="line">    data := box.String(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Contents of file:&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 10 行，我们创建了一个新盒子（New Box）。盒子表示一个文件夹，其内容会嵌入到二进制中。在这里，我指定了 <code>filehandling</code> 文件夹，其内容包含 <code>test.txt</code>。在下一行，我们读取了文件内容，并打印出来。</p>
<p>在开发阶段时，我们可以使用 <code>go install</code> 命令来运行程序。程序可以正常运行。<code>packr</code> 非常智能，在开发阶段可以从磁盘加载文件。</p>
<p>使用下面命令来运行程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copygo install filehandling</span><br><span class="line">workspacepath/bin/filehandling</span><br></pre></td></tr></table></figure>

<p>该命令可以在其他位置运行。<code>packr</code> 很聪明，可以获取传递给 <code>NewBox</code> 命令的目录的绝对路径。</p>
<p>该程序会输出：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyContents of file: Hello World. Welcome to file handling in Go.</span><br></pre></td></tr></table></figure>

<p>你可以试着改变 <code>test.txt</code> 的内容，然后再运行 <code>filehandling</code>。可以看到，无需再次编译，程序打印出了 <code>test.txt</code> 的更新内容。完美！</p>
<p>现在我们来看看如何将 <code>test.txt</code> 打包到我们的二进制文件中。我们使用 <code>packr</code> 命令来实现。</p>
<p>运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackr install -v filehandling</span><br></pre></td></tr></table></figure>

<p>它会打印：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copybuilding box ../filehandling</span><br><span class="line">packing file filehandling.go</span><br><span class="line">packed file filehandling.go</span><br><span class="line">packing file test.txt</span><br><span class="line">packed file test.txt</span><br><span class="line">built box ../filehandling with [<span class="string">&quot;filehandling.go&quot;</span> <span class="string">&quot;test.txt&quot;</span>]</span><br><span class="line">filehandling</span><br></pre></td></tr></table></figure>

<p>该命令将静态文件绑定到了二进制文件中。</p>
<p>在运行上述命令之后，使用命令 <code>workspacepath/bin/filehandling</code> 来运行程序。程序会打印出 <code>test.txt</code> 的内容。于是从二进制文件中，我们读取了 <code>test.txt</code> 的内容。</p>
<p>如果你不知道文件到底是由二进制还是磁盘来提供，我建议你删除 <code>test.txt</code>，并在此运行 <code>filehandling</code> 命令。你将看到，程序打印出了 <code>test.txt</code> 的内容。太棒了:D。我们已经成功将静态文件嵌入到了二进制文件中。</p>
<h2 id="分块读取文件"><a href="#分块读取文件" class="headerlink" title="分块读取文件"></a>分块读取文件</h2><p>在前面的章节，我们学习了如何把整个文件读取到内存。当文件非常大时，尤其在 RAM 存储量不足的情况下，把整个文件都读入内存是没有意义的。更好的方法是分块读取文件。这可以使用 <a target="_blank" rel="noopener" href="https://golang.org/pkg/bufio">bufio</a> 包来完成。</p>
<p>让我们来编写一个程序，以 3 个字节的块为单位读取 <code>test.txt</code> 文件。如下所示，替换 <code>filehandling.go</code> 的内容。 <a href="Go-2.%E8%BF%9B%E9%98%B6.md">Go-2.进阶.md</a> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fptr := flag.String(<span class="string">&quot;fpath&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;file path to read from&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(*fptr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    r := bufio.NewReader(f)</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        _, err := r.Read(b)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Error reading file:&quot;</span>, err)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="type">string</span>(b))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 15 行，我们使用命令行标记传递的路径，打开文件。</p>
<p>在第 19 行，我们延迟了文件的关闭操作。</p>
<p>在上面程序的第 24 行，我们新建了一个缓冲读取器（buffered reader）。在下一行，我们创建了长度和容量为 3 的字节切片，程序会把文件的字节读取到切片中。</p>
<p>第 27 行的 <code>Read</code> <a target="_blank" rel="noopener" href="https://studygolang.com/articles/12264">方法</a>会读取 len(b) 个字节（达到 3 字节），并返回所读取的字节数。当到达文件最后时，它会返回一个 EOF 错误。程序的其他地方比较简单，不做解释。</p>
<p>如果我们使用下面命令来运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy$ go install filehandling</span><br><span class="line">$ wrkspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span><br></pre></td></tr></table></figure>

<p>会得到以下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CopyHel</span><br><span class="line">lo</span><br><span class="line">Wor</span><br><span class="line">ld.</span><br><span class="line"> We</span><br><span class="line">lco</span><br><span class="line">me</span><br><span class="line">to</span><br><span class="line">fil</span><br><span class="line">e h</span><br><span class="line">and</span><br><span class="line">lin</span><br><span class="line">g i</span><br><span class="line">n G</span><br><span class="line">o.</span><br><span class="line">Error reading file: EOF</span><br></pre></td></tr></table></figure>

<h2 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h2><p>本节我们讨论如何使用 Go 逐行读取文件。这可以使用 <a target="_blank" rel="noopener" href="https://golang.org/pkg/bufio/">bufio</a> 来实现。</p>
<p>请将 <code>test.txt</code> 替换为以下内容。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyHello World. Welcome <span class="built_in">to</span> <span class="built_in">file</span> handling <span class="keyword">in</span> Go.</span><br><span class="line">This is <span class="keyword">the</span> <span class="keyword">second</span> <span class="built_in">line</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="built_in">file</span>.</span><br><span class="line">We have reached <span class="keyword">the</span> <span class="function"><span class="keyword">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">file</span>.</span></span><br></pre></td></tr></table></figure>

<p>逐行读取文件涉及到以下步骤。</p>
<ol>
<li>打开文件；</li>
<li>在文件上新建一个 scanner；</li>
<li>扫描文件并且逐行读取。</li>
</ol>
<p>将 <code>filehandling.go</code> 替换为以下内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fptr := flag.String(<span class="string">&quot;fpath&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;file path to read from&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    f, err := os.Open(*fptr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = f.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    s := bufio.NewScanner(f)</span><br><span class="line">    <span class="keyword">for</span> s.Scan() &#123;</span><br><span class="line">        fmt.Println(s.Text())</span><br><span class="line">    &#125;</span><br><span class="line">    err = s.Err()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 15 行，我们用命令行标记传入的路径，打开文件。在第 24 行，我们用文件创建了一个新的 scanner。第 25 行的 <code>Scan()</code> 方法读取文件的下一行，如果可以读取，就可以使用 <code>Text()</code> 方法。</p>
<p>当 <code>Scan</code> 返回 false 时，除非已经到达文件末尾（此时 <code>Err()</code> 返回 <code>nil</code>），否则 <code>Err()</code> 就会返回扫描过程中出现的错误。</p>
<p>如果我使用下面命令来运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy$ go install filehandling</span><br><span class="line">$ workspacepath/bin/filehandling -fpath=/path-of-file/test.txt</span><br></pre></td></tr></table></figure>

<p>程序会输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyHello World. Welcome to file handling <span class="keyword">in</span> Go.</span><br><span class="line">This is the second line of the file.</span><br><span class="line">We have reached the end of the file.</span><br></pre></td></tr></table></figure>

<h2 id="将字符串写入文件"><a href="#将字符串写入文件" class="headerlink" title="将字符串写入文件"></a>将字符串写入文件</h2><p>最常见的写文件就是将字符串写入文件。这个写起来非常的简单。这个包含以下几个阶段。</p>
<ol>
<li>创建文件</li>
<li>将字符串写入文件</li>
</ol>
<p>我们将得到如下代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    l, err := f.WriteString(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(l, <span class="string">&quot;bytes written successfully&quot;</span>)</span><br><span class="line">    err = f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 9 行使用 <code>create</code> 创建一个名字为 <code>test.txt</code> 的文件。如果这个文件已经存在，那么 <code>create</code> 函数将截断这个文件。该函数返回一个文件描述符。</p>
<p>在第 14 行，我们使用 <code>WriteString</code> 将字符串 <strong>Hello World</strong> 写入到文件里面。这个方法将返回相应写入的字节数，如果有错误则返回错误。</p>
<p>最后，在第 21 行我们将文件关闭。</p>
<p>上面程序将打印：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy11 <span class="built_in">bytes</span> written successfully</span><br></pre></td></tr></table></figure>

<p>运行完成之后你会在程序运行的目录下发现创建了一个 <strong>test.txt</strong> 的文件。如果你使用文本编辑器打开这个文件，你可以看到文件里面有一个 <strong>Hello World</strong> 的字符串。</p>
<h2 id="将字节写入文件"><a href="#将字节写入文件" class="headerlink" title="将字节写入文件"></a>将字节写入文件</h2><p>将字节写入文件和写入字符串非常的类似。我们将使用 Write]方法将字节写入到文件。下面的程序将一个字节的切片写入文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">&quot;/home/naveen/bytes&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    d2 := []<span class="type">byte</span>&#123;<span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">119</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>&#125;</span><br><span class="line">    n2, err := f.Write(d2)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(n2, <span class="string">&quot;bytes written successfully&quot;</span>)</span><br><span class="line">    err = f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，第 15 行使用了 <strong>Write</strong> 方法将字节切片写入到 <code>bytes</code> 这个文件里。这个文本在目录 <code>/home/naveen</code> 里面。你也可以将这个目录换成其他的目录。剩余的程序自带解释。如果执行成功，这个程序将打印 <code>11 bytes written successfully</code>。并且创建一个 <code>bytes</code> 的文件。打开文件，你会发现该文件包含了文本 <strong>hello bytes</strong>。</p>
<h2 id="将字符串一行一行的写入文件"><a href="#将字符串一行一行的写入文件" class="headerlink" title="将字符串一行一行的写入文件"></a>将字符串一行一行的写入文件</h2><p>另外一个常用的操作就是将字符串一行一行的写入到文件。这一部分我们将写一个程序，该程序创建并写入如下内容到文件里。</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyWelcome to the world of Go.</span><br><span class="line">Go <span class="keyword">is</span> a compiled language.</span><br><span class="line">It <span class="keyword">is</span> easy to learn Go.</span><br></pre></td></tr></table></figure>

<p>让我们看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">&quot;lines&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        f.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    d := []<span class="type">string</span>&#123;<span class="string">&quot;Welcome to the world of Go1.&quot;</span>, <span class="string">&quot;Go is a compiled language.&quot;</span>,</span><br><span class="line"><span class="string">&quot;It is easy to learn Go.&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">        fmt.Fprintln(f, v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err = f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;file written successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 9 行，我们先创建一个名字叫做 <strong>lines</strong> 的文件。在第 17 行，我们用迭代并使用 <code>for rang</code> 循环这个数组，并使用 Fprintln，<strong>Fprintln</strong> 函数 将 <code>io.writer</code> 做为参数，并且添加一个新的行，这个正是我们想要的。如果执行成功将打印 <code>file written successfully</code>，并且在当前目录将创建一个 <code>lines</code> 的文件。<code>lines</code> 这个文件的内容如下所示：</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyWelcome to the world of Go1.</span><br><span class="line">Go <span class="keyword">is</span> a compiled language.</span><br><span class="line">It <span class="keyword">is</span> easy to learn Go.</span><br></pre></td></tr></table></figure>

<h2 id="追加到文件"><a href="#追加到文件" class="headerlink" title="追加到文件"></a>追加到文件</h2><p>这一部分我们将追加一行到上节创建的 <code>lines</code> 文件中。我们将追加 <strong>File handling is easy</strong> 到 <code>lines</code> 这个文件。</p>
<p>这个文件将以追加和写的方式打开。这些标志将通过 Open方法实现。当文件以追加的方式打开，我们添加新的行到文件里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.OpenFile(<span class="string">&quot;lines&quot;</span>, os.O_APPEND|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    newLine := <span class="string">&quot;File handling is easy.&quot;</span></span><br><span class="line">    _, err = fmt.Fprintln(f, newLine)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">                f.Close()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    err = f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;file appended successfully&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 9 行，我们以写的方式打开文件并将一行添加到文件里。当成功打开文件之后，在程序第 15 行，我们添加一行到文件里。程序成功将打印 <code>file appended successfully</code>。运行程序，新的行就加到文件里面去了。</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyWelcome to the world of Go1.</span><br><span class="line">Go <span class="keyword">is</span> a compiled language.</span><br><span class="line">It <span class="keyword">is</span> easy to learn Go.</span><br><span class="line">File handling <span class="keyword">is</span> easy.</span><br></pre></td></tr></table></figure>

<h2 id="并发写文件"><a href="#并发写文件" class="headerlink" title="并发写文件"></a>并发写文件</h2><p>当多个 goroutines 同时（并发）写文件时，我们会遇到竞争条件(race condition)。因此，当发生同步写的时候需要一个 channel 作为一致写入的条件。</p>
<p>我们将写一个程序，该程序创建 100 个 goroutinues。每个 goroutinue 将并发产生一个随机数，届时将有 100 个随机数产生。这些随机数将被写入到文件里面。我们将用下面的方法解决这个问题 .</p>
<ol>
<li>创建一个 channel 用来读和写这个随机数。</li>
<li>创建 100 个生产者 goroutine。每个 goroutine 将产生随机数并将随机数写入到 channel 里。</li>
<li>创建一个消费者 goroutine 用来从 channel 读取随机数并将它写入文件。这样的话我们就只有一个 goroutinue 向文件中写数据，从而避免竞争条件。</li>
<li>一旦完成则关闭文件。</li>
</ol>
<p>我们开始写产生随机数的 <code>produce</code> 函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc produce(data <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup) &#123;</span><br><span class="line">    n := rand.Intn(<span class="number">999</span>)</span><br><span class="line">    data &lt;- n</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法产生随机数并且将 <code>data</code> 写入到 channel 中，之后通过调用 <code>waitGroup</code> 的 <code>Done</code> 方法来通知任务已经完成。</p>
<p>让我们看看将数据写到文件的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc consume(data <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span> <span class="type">bool</span>) &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">&quot;concurrent&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> d := <span class="keyword">range</span> data &#123;</span><br><span class="line">        _, err = fmt.Fprintln(f, d)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            f.Close()</span><br><span class="line">            done &lt;- <span class="literal">false</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err = f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        done &lt;- <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>consume</code> 的函数创建了一个名为 <code>concurrent</code> 的文件。然后从 channel 中读取随机数并且写到文件中。一旦读取完成并且将随机数写入文件后，通过往 <code>done</code> 这个 cahnnel 中写入 <code>true</code> 来通知任务已完成。</p>
<p>下面我们写 <code>main</code> 函数，并完成这个程序。下面是我提供的完整程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">(data <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    n := rand.Intn(<span class="number">999</span>)</span><br><span class="line">    data &lt;- n</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consume</span><span class="params">(data <span class="keyword">chan</span> <span class="type">int</span>, done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">&quot;concurrent&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> d := <span class="keyword">range</span> data &#123;</span><br><span class="line">        _, err = fmt.Fprintln(f, d)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            f.Close()</span><br><span class="line">            done &lt;- <span class="literal">false</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    err = f.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        done &lt;- <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> produce(data, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> consume(data, done)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(data)</span><br><span class="line">    &#125;()</span><br><span class="line">    d := &lt;-done</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">true</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;File written successfully&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;File writing failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main</code> 函数在第 41 行创建写入和读取数据的 channel，在第 42 行创建 <code>done</code> 这个 channel，此 channel 用于消费者 goroutinue 完成任务之后通知 <code>main</code> 函数。第 43 行创建 Waitgroup 的实例 <code>wg</code>，用于等待所有生产随机数的 goroutine 完成任务。</p>
<p>在第 44 行使用 <code>for</code> 循环创建 100 个 goroutines。在第 49 行调用 waitgroup 的 <code>wait()</code> 方法等待所有的 goroutines 完成随机数的生成。然后关闭 channel。当 channel 关闭时，消费者 <code>consume</code> goroutine 已经将所有的随机数写入文件，在第 37 行 将 <code>true</code> 写入 <code>done</code> 这个 channel 中，这个时候 <code>main</code> 函数解除阻塞并且打印 <code>File written successfully</code>。</p>

    </div>

    
    
    

    <footer class="post-footer"><div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Michaeldong 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="Michaeldong 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/18/Go-1.%E5%9F%BA%E7%A1%80/" rel="prev" title="Go-基础">
                  <i class="fa fa-chevron-left"></i> Go-基础
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/25/Go-3.%E9%AB%98%E7%BA%A7/" rel="next" title="Go-高级">
                  Go-高级 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Michaeldong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:09</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":"9D92XKxDbxTrStQPr"}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>





  





  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":300,"vOffset":300},"mobile":{"show":true},"dialog":{"enable":true,"hitokoto":true}});</script></body>
</html>
