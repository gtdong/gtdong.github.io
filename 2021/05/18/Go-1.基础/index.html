<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gtdong.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"gitalk","active":true,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. 介绍与安装Golang 是什么Go 亦称为 Golang（按照 Rob Pike 说法，语言叫做 Go，Golang 只是官方网站的网址），是由谷歌开发的一个开源的编译型的静态语言。 Golang 的主要关注点是使得高可用性和可扩展性的 Web 应用的开发变得简便容易。（Go 的定位是系统编程语言，只是对 Web 开发支持较好）">
<meta property="og:type" content="article">
<meta property="og:title" content="Go-基础">
<meta property="og:url" content="https://gtdong.github.io/2021/05/18/Go-1.%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="TsukiBlog">
<meta property="og:description" content="1. 介绍与安装Golang 是什么Go 亦称为 Golang（按照 Rob Pike 说法，语言叫做 Go，Golang 只是官方网站的网址），是由谷歌开发的一个开源的编译型的静态语言。 Golang 的主要关注点是使得高可用性和可扩展性的 Web 应用的开发变得简便容易。（Go 的定位是系统编程语言，只是对 Web 开发支持较好）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232851087-863913389.png">
<meta property="article:published_time" content="2021-05-18T05:05:00.000Z">
<meta property="article:modified_time" content="2022-04-30T16:12:01.094Z">
<meta property="article:author" content="Michaeldong">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232851087-863913389.png">


<link rel="canonical" href="https://gtdong.github.io/2021/05/18/Go-1.%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gtdong.github.io/2021/05/18/Go-1.%E5%9F%BA%E7%A1%80/","path":"2021/05/18/Go-1.基础/","title":"Go-基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go-基础 | TsukiBlog</title>
  




<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TsukiBlog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="nav-number">1.</span> <span class="nav-text">1. 介绍与安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Golang-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.1.</span> <span class="nav-text">Golang 是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9-Golang"><span class="nav-number">1.2.</span> <span class="nav-text">为何选择 Golang</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mac-OS"><span class="nav-number">1.3.1.</span> <span class="nav-text">Mac OS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows"><span class="nav-number">1.3.2.</span> <span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux"><span class="nav-number">1.3.3.</span> <span class="nav-text">Linux</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Hello-World"><span class="nav-number">2.</span> <span class="nav-text">2. Hello World</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B-Go-%E5%B7%A5%E4%BD%9C%E5%8C%BA"><span class="nav-number">2.1.</span> <span class="nav-text">建立 Go 工作区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C-Go-%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">运行 Go 程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-hello-world-%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">简述 hello world 程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E5%8F%98%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">3. 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.0.1.</span> <span class="nav-text">变量是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%8D%95%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="nav-number">3.0.2.</span> <span class="nav-text">声明单个变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.0.3.</span> <span class="nav-text">声明变量并初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%EF%BC%88Type-Inference%EF%BC%89"><span class="nav-number">3.0.4.</span> <span class="nav-text">类型推断（Type Inference）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="nav-number">3.0.5.</span> <span class="nav-text">声明多个变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E7%9F%AD%E5%A3%B0%E6%98%8E"><span class="nav-number">3.0.6.</span> <span class="nav-text">简短声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">4. 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bool"><span class="nav-number">4.0.1.</span> <span class="nav-text">bool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B"><span class="nav-number">4.0.2.</span> <span class="nav-text">有符号整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%9E%8B"><span class="nav-number">4.0.3.</span> <span class="nav-text">无符号整型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="nav-number">4.0.4.</span> <span class="nav-text">浮点型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.0.5.</span> <span class="nav-text">复数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.0.6.</span> <span class="nav-text">其他数字类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string-%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.0.7.</span> <span class="nav-text">string 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.0.8.</span> <span class="nav-text">类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%B8%B8%E9%87%8F"><span class="nav-number">5.</span> <span class="nav-text">5. 常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">5.0.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">5.0.2.</span> <span class="nav-text">字符串常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%B8%B8%E9%87%8F"><span class="nav-number">5.0.3.</span> <span class="nav-text">布尔常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%B8%B8%E9%87%8F"><span class="nav-number">5.0.4.</span> <span class="nav-text">数字常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.0.5.</span> <span class="nav-text">数字表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%87%BD%E6%95%B0%EF%BC%88Function%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">6. 函数（Function）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">函数是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">6.2.</span> <span class="nav-text">函数的声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">示例函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.4.</span> <span class="nav-text">多返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.5.</span> <span class="nav-text">命名返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E7%99%BD%E7%AC%A6"><span class="nav-number">6.6.</span> <span class="nav-text">空白符</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%8C%85"><span class="nav-number">7.</span> <span class="nav-text">7. 包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8C%85%EF%BC%9F"><span class="nav-number">7.0.1.</span> <span class="nav-text">什么是包，为什么使用包？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-%E5%87%BD%E6%95%B0%E5%92%8C-main-%E5%8C%85"><span class="nav-number">7.0.2.</span> <span class="nav-text">main 函数和 main 包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%85"><span class="nav-number">7.0.3.</span> <span class="nav-text">创建自定义的包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="nav-number">7.0.4.</span> <span class="nav-text">导入自定义包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E5%90%8D%E5%AD%97%EF%BC%88Exported-Names%EF%BC%89"><span class="nav-number">7.0.5.</span> <span class="nav-text">导出名字（Exported Names）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#init-%E5%87%BD%E6%95%B0"><span class="nav-number">7.0.6.</span> <span class="nav-text">init 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%A9%BA%E7%99%BD%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88Blank-Identifier%EF%BC%89"><span class="nav-number">7.0.7.</span> <span class="nav-text">使用空白标识符（Blank Identifier）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-if-else-%E8%AF%AD%E5%8F%A5"><span class="nav-number">8.</span> <span class="nav-text">8. if-else 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">8.0.1.</span> <span class="nav-text">一个注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.</span> <span class="nav-text">9. 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">for 循环语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">9.2.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break"><span class="nav-number">9.3.</span> <span class="nav-text">break</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#continue"><span class="nav-number">9.4.</span> <span class="nav-text">continue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E4%BE%8B%E5%AD%90"><span class="nav-number">9.5.</span> <span class="nav-text">更多例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.6.</span> <span class="nav-text">无限循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-switch-%E8%AF%AD%E5%8F%A5"><span class="nav-number">10.</span> <span class="nav-text">10. switch 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%EF%BC%88Default-Case%EF%BC%89"><span class="nav-number">10.1.</span> <span class="nav-text">默认情况（Default Case）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%A4%E6%96%AD"><span class="nav-number">10.2.</span> <span class="nav-text">多表达式判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84-switch"><span class="nav-number">10.3.</span> <span class="nav-text">无表达式的 switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fallthrough-%E8%AF%AD%E5%8F%A5"><span class="nav-number">10.4.</span> <span class="nav-text">Fallthrough 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">10.5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">10.5.1.</span> <span class="nav-text">数组的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.5.2.</span> <span class="nav-text">数组是值类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">10.5.3.</span> <span class="nav-text">数组的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-range-%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84"><span class="nav-number">10.5.4.</span> <span class="nav-text">使用 range 迭代数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">10.5.5.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%87%E7%89%87"><span class="nav-number">10.6.</span> <span class="nav-text">切片</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%87%E7%89%87"><span class="nav-number">10.6.1.</span> <span class="nav-text">创建一个切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-number">10.6.2.</span> <span class="nav-text">切片的修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F"><span class="nav-number">10.6.3.</span> <span class="nav-text">切片的长度和容量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-make-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%88%87%E7%89%87"><span class="nav-number">10.6.4.</span> <span class="nav-text">使用 make 创建一个切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0%E5%88%87%E7%89%87%E5%85%83%E7%B4%A0"><span class="nav-number">10.6.5.</span> <span class="nav-text">追加切片元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">10.6.6.</span> <span class="nav-text">切片的函数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E5%88%87%E7%89%87"><span class="nav-number">10.6.7.</span> <span class="nav-text">多维切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="nav-number">10.6.8.</span> <span class="nav-text">内存优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">12. 可变参数函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">什么是可变参数函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">11.2.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="nav-number">11.3.</span> <span class="nav-text">通过一些例子理解可变参数函数如何工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E4%BC%A0%E5%85%A5%E5%88%87%E7%89%87"><span class="nav-number">11.4.</span> <span class="nav-text">给可变参数函数传入切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E7%9B%B4%E8%A7%82%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">11.5.</span> <span class="nav-text">不直观的错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">12.</span> <span class="nav-text">14. 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">什么是字符串？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%8B%AC%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="nav-number">12.2.</span> <span class="nav-text">单独获取字符串的每一个字节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rune"><span class="nav-number">12.3.</span> <span class="nav-text">rune</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84-for-range-%E5%BE%AA%E7%8E%AF"><span class="nav-number">12.4.</span> <span class="nav-text">字符串的 for range 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%AD%97%E8%8A%82%E5%88%87%E7%89%87%E6%9E%84%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">12.5.</span> <span class="nav-text">用字节切片构造字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-rune-%E5%88%87%E7%89%87%E6%9E%84%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">12.6.</span> <span class="nav-text">用 rune 切片构造字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">12.7.</span> <span class="nav-text">字符串的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">12.8.</span> <span class="nav-text">字符串是不可变的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E6%8C%87%E9%92%88"><span class="nav-number">13.</span> <span class="nav-text">15. 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%9F"><span class="nav-number">13.0.1.</span> <span class="nav-text">什么是指针？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">13.0.2.</span> <span class="nav-text">指针的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E9%9B%B6%E5%80%BC%EF%BC%88Zero-Value%EF%BC%89"><span class="nav-number">13.0.3.</span> <span class="nav-text">指针的零值（Zero Value）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="nav-number">13.0.4.</span> <span class="nav-text">指针的解引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0"><span class="nav-number">13.0.5.</span> <span class="nav-text">向函数传递指针参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%A6%81%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E8%80%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%88%87%E7%89%87"><span class="nav-number">13.0.6.</span> <span class="nav-text">不要向函数传递数组的指针，而应该使用切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-%E4%B8%8D%E6%94%AF%E6%8C%81%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="nav-number">13.0.7.</span> <span class="nav-text">Go 不支持指针运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">13.1.</span> <span class="nav-text">16.结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9F"><span class="nav-number">13.1.1.</span> <span class="nav-text">什么是结构体？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">13.1.2.</span> <span class="nav-text">结构体的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">13.1.3.</span> <span class="nav-text">创建命名的结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">13.1.4.</span> <span class="nav-text">创建匿名结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E9%9B%B6%E5%80%BC%EF%BC%88Zero-Value%EF%BC%89"><span class="nav-number">13.1.5.</span> <span class="nav-text">结构体的零值（Zero Value）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="nav-number">13.1.6.</span> <span class="nav-text">访问结构体的字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">13.1.7.</span> <span class="nav-text">结构体的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="nav-number">13.1.8.</span> <span class="nav-text">匿名字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88Nested-Structs%EF%BC%89"><span class="nav-number">13.1.9.</span> <span class="nav-text">嵌套结构体（Nested Structs）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8D%87%E5%AD%97%E6%AE%B5%EF%BC%88Promoted-Fields%EF%BC%89"><span class="nav-number">13.1.10.</span> <span class="nav-text">提升字段（Promoted Fields）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E5%87%BA%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%AD%97%E6%AE%B5"><span class="nav-number">13.1.11.</span> <span class="nav-text">导出结构体和字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9B%B8%E7%AD%89%E6%80%A7%EF%BC%88Structs-Equality%EF%BC%89"><span class="nav-number">13.1.12.</span> <span class="nav-text">结构体相等性（Structs Equality）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.</span> <span class="nav-text">17.方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">13.2.1.</span> <span class="nav-text">什么是方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">13.2.2.</span> <span class="nav-text">方法示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E6%9C%89%E5%87%BD%E6%95%B0%E4%BA%86%E8%BF%98%E9%9C%80%E8%A6%81%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="nav-number">13.2.3.</span> <span class="nav-text">为什么我们已经有函数了还需要方法呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8%E4%B8%8E%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-number">13.2.4.</span> <span class="nav-text">指针接收器与值接收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">13.2.5.</span> <span class="nav-text">那么什么时候使用指针接收器，什么时候使用值接收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.6.</span> <span class="nav-text">匿名字段的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E6%8E%A5%E6%94%B6%E5%99%A8-%E4%B8%8E-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%8F%82%E6%95%B0"><span class="nav-number">13.2.7.</span> <span class="nav-text">在方法中使用值接收器 与 在函数中使用值参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8-%E4%B8%8E-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0"><span class="nav-number">13.2.8.</span> <span class="nav-text">在方法中使用指针接收器 与 在函数中使用指针参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%9D%9E%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.9.</span> <span class="nav-text">在非结构体上的方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E6%8E%A5%E5%8F%A3-%E4%B8%80"><span class="nav-number">13.3.</span> <span class="nav-text">18.接口(一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="nav-number">13.3.1.</span> <span class="nav-text">什么是接口？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">13.3.2.</span> <span class="nav-text">接口的声明与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E9%99%85%E7%94%A8%E9%80%94"><span class="nav-number">13.3.3.</span> <span class="nav-text">接口的实际用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%86%85%E9%83%A8%E8%A1%A8%E7%A4%BA"><span class="nav-number">13.3.4.</span> <span class="nav-text">接口的内部表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E6%8E%A5%E5%8F%A3"><span class="nav-number">13.3.5.</span> <span class="nav-text">空接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="nav-number">13.3.6.</span> <span class="nav-text">类型断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9%EF%BC%88Type-Switch%EF%BC%89"><span class="nav-number">13.3.7.</span> <span class="nav-text">类型选择（Type Switch）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">14.</span> <span class="nav-text">19. 接口（二）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%8C%87%E9%92%88%E6%8E%A5%E5%8F%97%E8%80%85%E4%B8%8E%E5%80%BC%E6%8E%A5%E5%8F%97%E8%80%85"><span class="nav-number">14.0.1.</span> <span class="nav-text">实现接口：指针接受者与值接受者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="nav-number">14.0.2.</span> <span class="nav-text">实现多个接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-number">14.0.3.</span> <span class="nav-text">接口的嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9B%B6%E5%80%BC"><span class="nav-number">14.0.4.</span> <span class="nav-text">接口的零值</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Michaeldong"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Michaeldong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated">
    <button><i class="fa fa-comment"></i>
      Chat
    </button>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gtdong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gtdong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/gtdong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gtdong.github.io/2021/05/18/Go-1.%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Michaeldong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TsukiBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go-基础 | TsukiBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go-基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-18 13:05:00" itemprop="dateCreated datePublished" datetime="2021-05-18T13:05:00+08:00">2021-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 00:12:01" itemprop="dateModified" datetime="2022-05-01T00:12:01+08:00">2022-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Go%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">Go语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>89k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:21</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="1-介绍与安装"><a href="#1-介绍与安装" class="headerlink" title="1. 介绍与安装"></a>1. 介绍与安装</h1><h2 id="Golang-是什么"><a href="#Golang-是什么" class="headerlink" title="Golang 是什么"></a>Golang 是什么</h2><p>Go 亦称为 Golang（按照 Rob Pike 说法，语言叫做 Go，Golang 只是官方网站的网址），是由谷歌开发的一个开源的编译型的静态语言。</p>
<p>Golang 的主要关注点是使得高可用性和可扩展性的 Web 应用的开发变得简便容易。（Go 的定位是系统编程语言，只是对 Web 开发支持较好）</p>
<span id="more"></span>

<h2 id="为何选择-Golang"><a href="#为何选择-Golang" class="headerlink" title="为何选择 Golang"></a>为何选择 Golang</h2><p>既然有很多其他编程语言可以做同样的工作，如 Python，Ruby，Nodejs 等，为什么要选择 Golang 作为服务端编程语言？</p>
<p>以下是我使用 Go 语言时发现的一些优点：</p>
<ul>
<li>并发是语言的一部分（并非通过标准库实现），所以编写多线程程序会是一件很容易的事。后续教程将会讨论到，并发是通过 Goroutines 和 channels 机制实现的。</li>
<li>Golang 是一种编译型语言。源代码会编译为二进制机器码。而在解释型语言中没有这个过程，如 Nodejs 中的 JavaScript。</li>
<li>语言规范十分简洁。所有规范都在一个页面展示，你甚至都可以用它来编写你自己的编译器呢。</li>
<li>Go 编译器支持静态链接。所有 Go 代码都可以静态链接为一个大的二进制文件（相对现在的磁盘空间，其实根本不大），并可以轻松部署到云服务器，而不必担心各种依赖性。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Golang 支持三个平台：Mac，Windows 和 Linux（译注：不只是这三个，也支持其他主流平台）。你可以在 <a target="_blank" rel="noopener" href="https://golang.org/dl/">https://golang.org/dl/</a> 中下载相应平台的二进制文件。（因为众所周知的原因，如果下载不了，请到 <a target="_blank" rel="noopener" href="https://studygolang.com/dl">https://studygolang.com/dl</a> 下载）</p>
<h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><p>在 <a target="_blank" rel="noopener" href="https://golang.org/dl/">https://golang.org/dl/</a> 下载安装程序。双击开始安装并且遵循安装提示，会将 Golang 安装到 <code>/usr/local/go</code> 目录下，同时 <code>/usr/local/go/bin</code> 文件夹也会被添加到 <code>PATH</code> 环境变量中。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 <a target="_blank" rel="noopener" href="https://golang.org/dl/">https://golang.org/dl/</a> 下载 MSI 安装程序。双击开始安装并且遵循安装提示，会将 Golang 安装到 <code>C:\Go</code> 目录下，同时 <code>c:\Go\bin</code> 目录也会被添加到你的 <code>PATH</code> 环境变量中。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在 <a target="_blank" rel="noopener" href="https://golang.org/dl/">https://golang.org/dl/</a> 下载 tar 文件，并解压到 <code>/usr/local</code>。</p>
<p>请添加 <code>/usr/local/go/bin</code> 到 <code>PATH</code> 环境变量中。Go 就已经成功安装在 <code>Linux</code> 上了。</p>
<h1 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h1><h2 id="建立-Go-工作区"><a href="#建立-Go-工作区" class="headerlink" title="建立 Go 工作区"></a>建立 Go 工作区</h2><p>在编写代码之前，我们首先应该建立 Go 的工作区（Workspace）。</p>
<p>在 <strong>Mac 或 Linux</strong> 操作系统下，Go 工作区应该设置在 <strong>𝐻𝑂𝑀𝐸/𝑔𝑜∗∗。所以我们要在∗∗HOME/go∗∗。所以我们要在∗∗HOME</strong> 目录下创建 <strong>go</strong> 目录。</p>
<p>而在 <strong>Windows</strong> 下，工作区应该设置在 <strong>C:\Users\YourName\go</strong>。所以请将 <strong>go</strong> 目录放置在 <strong>C:\Users\YourName</strong>。</p>
<p>其实也可以通过设置 GOPATH 环境变量，用其他目录来作为工作区。但为了简单起见，我们采用上面提到的放置方法。</p>
<p>所有 Go 源文件都应该放置在工作区里的 <strong>src</strong> 目录下。请在刚添加的 <strong>go</strong> 目录下面创建目录 <strong>src</strong>。</p>
<p>所有 Go 项目都应该依次在 src 里面设置自己的子目录。我们在 src 里面创建一个目录 <strong>hello</strong> 来放置整个 hello world 项目。</p>
<p>创建上述目录之后，其目录结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copygo</span><br><span class="line">  <span class="attribute">src</span></span><br><span class="line">    hello</span><br></pre></td></tr></table></figure>

<p>在我们刚刚创建的 hello 目录下，在 <strong>helloworld.go</strong> 文件里保存下面的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建该程序之后，其目录结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copygo</span><br><span class="line">  <span class="attribute">src</span></span><br><span class="line">    hello</span><br><span class="line">      helloworld<span class="selector-class">.go</span></span><br></pre></td></tr></table></figure>

<h2 id="运行-Go-程序"><a href="#运行-Go-程序" class="headerlink" title="运行 Go 程序"></a>运行 Go 程序</h2><p>运行 Go 程序有多种方式，我们下面依次介绍。</p>
<p>1.使用 <strong>go run</strong> 命令 - 在命令提示符旁，输入 <code>go run workspacepath/src/hello/helloworld.go</code>。</p>
<p>上述命令中的 <strong>workspacepath</strong> 应该替换为你自己的工作区路径（Windows 下的 <strong>C:/Users/YourName/go</strong>，Linux 或 Mac 下的 <strong>$HOME/go</strong>）。</p>
<p>在控制台上会看见 <code>Hello World</code> 的输出。</p>
<p>2.使用 <strong>go install</strong> 命令 - 运行 <code>go install hello</code>，接着可以用 <code>workspacepath/bin/hello</code> 来运行该程序。</p>
<p>上述命令中的 <strong>workspacepath</strong> 应该替换为你自己的工作区路径（Windows 下的 <strong>C:/Users/YourName/go</strong>，Linux 或 Mac 下的 <strong>$HOME/go</strong>）。</p>
<p>当你输入 <strong>go install hello</strong> 时，go 工具会在工作区中搜索 hello 包（hello 称之为包，我们后面会更加详细地讨论包）。接下来它会在工作区的 bin 目录下，创建一个名为 <code>hello</code>（Windows 下名为 <code>hello.exe</code>）的二进制文件。运行 <strong>go install hello</strong> 后，其目录结构如下所示：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copygo</span><br><span class="line">  bin</span><br><span class="line">    hello</span><br><span class="line">  <span class="attribute">src</span></span><br><span class="line">    hello</span><br><span class="line">      helloworld<span class="selector-class">.go</span></span><br></pre></td></tr></table></figure>

<p>3.第 3 种运行程序的好方法是使用 go playground。尽管它有自身的限制，但该方法对于运行简单的程序非常方便。我已经在 playground 上创建了一个 hello world 程序。<a target="_blank" rel="noopener" href="https://play.golang.org/p/VtXafkQHYe">点击这里</a> 在线运行程序。 你可以使用 <a target="_blank" rel="noopener" href="https://play.golang.org/">go playground</a> 与其他人分享你的源代码。</p>
<h3 id="简述-hello-world-程序"><a href="#简述-hello-world-程序" class="headerlink" title="简述 hello world 程序"></a>简述 hello world 程序</h3><p>下面就是我们刚写下的 hello world 程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span> <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; <span class="comment">//3  </span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>) <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在简单介绍每一行大概都做了些什么，在以后的教程中还会深入探讨每个部分。</p>
<p><strong>package main - 每一个 Go 文件都应该在开头进行 package name 的声明</strong>（译注：只有可执行程序的包名应当为 main）。包（Packages）用于代码的封装与重用，这里的包名称是<code>main</code>。</p>
<p><strong>import “fmt”</strong> - 我们引入了 fmt 包，用于在 main 函数里面打印文本到标准输出。</p>
<p><strong>func main()</strong> - main 是一个特殊的函数。整个程序就是从 main 函数开始运行的。<strong>main 函数必须放置在 main 包中</strong>。<code>&#123;</code> 和 <code>&#125;</code> 分别表示 main 函数的开始和结束部分。</p>
<p><strong>fmt.Println(“Hello World”)</strong> - <strong>fmt</strong> 包中的 <strong>Println</strong> 函数用于把文本写入标准输出。</p>
<h1 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h1><h3 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么"></a>变量是什么</h3><p>变量指定了某存储单元（Memory Location）的名称，该存储单元会存储特定类型的值。在 Go 中，有多种语法用于声明变量。</p>
<h3 id="声明单个变量"><a href="#声明单个变量" class="headerlink" title="声明单个变量"></a>声明单个变量</h3><p><strong>var name type</strong> 是声明单个变量的语法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span> <span class="comment">// 变量声明</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;my age is&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句 <code>var age int</code> 声明了一个 int 类型的变量，名字为 age。我们还没有给该变量赋值。如果变量未被赋值，Go 会自动地将其初始化，赋值该变量类型的零值（Zero Value）。本例中 age 就被赋值为 0。如果你运行该程序，你会看到如下输出：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copymy age <span class="keyword">is</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>变量可以赋值为本类型的任何值。上一程序中的 age 可以赋值为任何整型值（Integer Value）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span> <span class="comment">// 变量声明</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;my age is&quot;</span>, age)</span><br><span class="line">    age = <span class="number">29</span> <span class="comment">// 赋值</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;my age is&quot;</span>, age)</span><br><span class="line">    age = <span class="number">54</span> <span class="comment">// 赋值</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;my new age is&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序会有如下输出：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copymy age <span class="keyword">is</span>  <span class="number">0</span>  </span><br><span class="line"><span class="keyword">my</span> age <span class="keyword">is</span> <span class="number">29</span>  </span><br><span class="line"><span class="keyword">my</span> new age <span class="keyword">is</span> <span class="number">54</span></span><br></pre></td></tr></table></figure>

<h3 id="声明变量并初始化"><a href="#声明变量并初始化" class="headerlink" title="声明变量并初始化"></a>声明变量并初始化</h3><p>声明变量的同时可以给定初始值。 <strong>var name type = initialvalue</strong> 的语法用于声明变量并初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age <span class="type">int</span> = <span class="number">29</span> <span class="comment">// 声明变量并初始化</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;my age is&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，age 是具有初始值 29 的 int 类型变量。如果你运行上面的程序，你可以看见下面的输出，证实 age 已经被初始化为 29。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copymy age <span class="keyword">is</span> <span class="number">29</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推断（Type-Inference）"><a href="#类型推断（Type-Inference）" class="headerlink" title="类型推断（Type Inference）"></a>类型推断（Type Inference）</h3><p>如果变量有初始值，那么 Go 能够自动推断具有初始值的变量的类型。因此，如果变量有初始值，就可以在变量声明中省略 <code>type</code>。</p>
<p>如果变量声明的语法是 <strong>var name = initialvalue</strong>，Go 能够根据初始值自动推断变量的类型。</p>
<p>在下面的例子中，你可以看到在第 6 行，我们省略了变量 <code>age</code> 的 <code>int</code> 类型，Go 依然推断出了它是 int 类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">29</span> <span class="comment">// 可以推断类型</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;my age is&quot;</span>, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="声明多个变量"><a href="#声明多个变量" class="headerlink" title="声明多个变量"></a>声明多个变量</h3><p>Go 能够通过一条语句声明多个变量。</p>
<p>声明多个变量的语法是 <strong>var name1, name2 type = initialvalue1, initialvalue2</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> width, height <span class="type">int</span> = <span class="number">100</span>, <span class="number">50</span> <span class="comment">// 声明多个变量</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;width is&quot;</span>, width, <span class="string">&quot;height is&quot;</span>, heigh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序将在标准输出打印 <code>width is 100 height is 50</code>。</p>
<p>你可能已经想到，如果 width 和 height 省略了初始化，它们的初始值将赋值为 0。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;      <span class="keyword">var</span> width, height <span class="type">int</span>    fmt.Println(<span class="string">&quot;width is&quot;</span>, width, <span class="string">&quot;height is&quot;</span>, height)    width = <span class="number">100</span>    height = <span class="number">50</span>    fmt.Println(<span class="string">&quot;new width is&quot;</span>, width, <span class="string">&quot;new height is &quot;</span>, height)&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将会打印：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copywidth <span class="built_in">is</span> <span class="number">0</span> <span class="built_in">height</span> <span class="built_in">is</span> <span class="number">0</span>  <span class="built_in">new</span> <span class="built_in">width</span> <span class="built_in">is</span> <span class="number">100</span> <span class="built_in">new</span> <span class="built_in">height</span> <span class="built_in">is</span>  <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>在有些情况下，我们可能会想要在一个语句中声明不同类型的变量。其语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyvar (      name1 = initialvalue1,    name2 = initialvalue2)</span><br></pre></td></tr></table></figure>

<p>使用上述语法，下面的程序声明不同类型的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="keyword">var</span> (        name   = <span class="string">&quot;naveen&quot;</span>        age    = <span class="number">29</span>        height <span class="type">int</span>    )    fmt.Println(<span class="string">&quot;my name is&quot;</span>, name, <span class="string">&quot;, age is&quot;</span>, age, <span class="string">&quot;and height is&quot;</span>, height)&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们声明了 <strong>string 类型的 name、int 类型的 age 和 height</strong>（我们将会在下一教程中讨论 golang 所支持的变量类型）。运行上面的程序会产生输出 <code>my name is naveen , age is 29 and height is 0</code>。</p>
<h3 id="简短声明"><a href="#简短声明" class="headerlink" title="简短声明"></a>简短声明</h3><p>Go 也支持一种声明变量的简洁形式，称为简短声明（Short Hand Declaration），该声明使用了 <strong>:=</strong> 操作符。</p>
<p>声明变量的简短语法是 <strong>name := initialvalue</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;      name, age := <span class="string">&quot;naveen&quot;</span>, <span class="number">29</span> <span class="comment">// 简短声明    fmt.Println(&quot;my name is&quot;, name, &quot;age is&quot;, age)&#125;</span></span><br></pre></td></tr></table></figure>

<p>运行上面的程序，可以看到输出为 <code>my name is naveen age is 29</code>。</p>
<p>简短声明要求 <strong>:=</strong> 操作符左边的所有变量都有初始值。下面程序将会抛出错误 <code>cannot assign 1 values to 2 variables</code>，这是因为 <strong>age 没有被赋值</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;      name, age := <span class="string">&quot;naveen&quot;</span> <span class="comment">//error    fmt.Println(&quot;my name is&quot;, name, &quot;age is&quot;, age)&#125;</span></span><br></pre></td></tr></table></figure>

<p>简短声明的语法要求 <strong>:=</strong> 操作符的左边至少有一个变量是尚未声明的。考虑下面的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    a, b := <span class="number">20</span>, <span class="number">30</span> <span class="comment">// 声明变量a和b    fmt.Println(&quot;a is&quot;, a, &quot;b is&quot;, b)    b, c := 40, 50 // b已经声明，但c尚未声明    fmt.Println(&quot;b is&quot;, b, &quot;c is&quot;, c)    b, c = 80, 90 // 给已经声明的变量b和c赋新值    fmt.Println(&quot;changed b is&quot;, b, &quot;c is&quot;, c)&#125;</span></span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 8 行，由于 b 已经被声明，而 c 尚未声明，因此运行成功并且输出：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copya <span class="keyword">is</span> <span class="number">20</span> b <span class="keyword">is</span> <span class="number">30</span>  b <span class="keyword">is</span> <span class="number">40</span> c <span class="keyword">is</span> <span class="number">50</span>  changed b <span class="keyword">is</span> <span class="number">80</span> c <span class="keyword">is</span> <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p>但是如果我们运行下面的程序:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport <span class="string">&quot;fmt&quot;</span><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;      a, b := <span class="number">20</span>, <span class="number">30</span> <span class="comment">// 声明a和b    fmt.Println(&quot;a is&quot;, a, &quot;b is&quot;, b)    a, b := 40, 50 // 错误，没有尚未声明的变量&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面运行后会抛出 <code>no new variables on left side of :=</code> 的错误，这是因为 a 和 b 的变量已经声明过了，**:=** 的左边并没有尚未声明的变量。</p>
<p>变量也可以在运行时进行赋值。考虑下面的程序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport (      <span class="string">&quot;fmt&quot;</span>    <span class="string">&quot;math&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;      a, b := <span class="number">145.8</span>, <span class="number">543.8</span>    c := math.Min(a, b)    fmt.Println(<span class="string">&quot;minimum value is &quot;</span>, c)&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，c 的值是运行过程中计算得到的，即 a 和 b 的最小值。上述程序会打印：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyminimum</span> value is  <span class="number">145</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>由于 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。下面的程序会抛出错误 <code>cannot use &quot;naveen&quot; (type string) as type int in assignment</code>，这是因为 age 本来声明为 int 类型，而我们却尝试给它赋字符串类型的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainfunc main() &#123;      age := <span class="number">29</span>      <span class="comment">// age是int类型    age = &quot;naveen&quot; // 错误，尝试赋值一个字符串给int类型变量&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-类型"><a href="#4-类型" class="headerlink" title="4. 类型"></a>4. 类型</h1><p>下面是 Go 支持的基本类型：</p>
<ul>
<li>bool</li>
<li>数字类型<ul>
<li>int8, int16, int32, int64, int</li>
<li>uint8, uint16, uint32, uint64, uint</li>
<li>float32, float64</li>
<li>complex64, complex128</li>
<li>byte</li>
<li>rune</li>
</ul>
</li>
<li>string</li>
</ul>
<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>bool 类型表示一个布尔值，值为 true 或者 false。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="literal">true</span></span><br><span class="line">    b := <span class="literal">false</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a:&quot;</span>, a, <span class="string">&quot;b:&quot;</span>, b)</span><br><span class="line">    c := a &amp;&amp; b</span><br><span class="line">    fmt.Println(<span class="string">&quot;c:&quot;</span>, c)</span><br><span class="line">    d := a || b</span><br><span class="line">    fmt.Println(<span class="string">&quot;d:&quot;</span>, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，a 赋值为 true，b 赋值为 false。</p>
<p>c 赋值为 a &amp;&amp; b。仅当 a 和 b 都为 true 时，操作符 &amp;&amp; 才返回 true。因此，在这里 c 为 false。</p>
<p>当 a 或者 b 为 true 时，操作符 || 返回 true。在这里，由于 a 为 true，因此 d 也为 true。我们将得到程序的输出如下。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Copya:</span> <span class="literal">true</span> b: <span class="literal">false</span>  </span><br><span class="line"><span class="symbol">c:</span> <span class="literal">false</span>  </span><br><span class="line"><span class="symbol">d:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="有符号整型"><a href="#有符号整型" class="headerlink" title="有符号整型"></a>有符号整型</h3><p><strong>int8</strong>：表示 8 位有符号整型<br><strong>大小</strong>：8 位<br><strong>范围</strong>：-128～127</p>
<p><strong>int16</strong>：表示 16 位有符号整型<br><strong>大小</strong>：16 位<br><strong>范围</strong>：-32768～32767</p>
<p><strong>int32</strong>：表示 32 位有符号整型<br><strong>大小</strong>：32 位<br><strong>范围</strong>：-2147483648～2147483647</p>
<p><strong>int64</strong>：表示 64 位有符号整型<br><strong>大小</strong>：64 位<br><strong>范围</strong>：-9223372036854775808～9223372036854775807</p>
<p><strong>int</strong>：根据不同的底层平台（Underlying Platform），表示 32 或 64 位整型。除非对整型的大小有特定的需求，否则你通常应该使用 <em>int</em> 表示整型。<br><strong>大小</strong>：在 32 位系统下是 32 位，而在 64 位系统下是 64 位。<br><strong>范围</strong>：在 32 位系统下是 -2147483648～2147483647，而在 64 位系统是 -9223372036854775808～9223372036854775807。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">89</span></span><br><span class="line">    b := <span class="number">95</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a is&quot;</span>, a, <span class="string">&quot;and b is&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://play.golang.org/p/NyDPsjkma3">在线运行程序</a></p>
<p>上面程序会输出 <code>value of a is 89 and b is 95</code>。</p>
<p>在上述程序中，a 是 int 类型，而 b 的类型通过赋值（95）推断得出。上面我们提到，int 类型的大小在 32 位系统下是 32 位，而在 64 位系统下是 64 位。接下来我们会证实这种说法。</p>
<p>在 Printf 方法中，使用 <strong>%T</strong> 格式说明符（Format Specifier），可以打印出变量的类型。Go 的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/unsafe/">unsafe</a> 包提供了一个 <a target="_blank" rel="noopener" href="https://golang.org/pkg/unsafe/#Sizeof">Sizeof</a> 函数，该函数接收变量并返回它的字节大小。<em>unsafe</em> 包应该小心使用，因为使用 unsafe 包可能会带来可移植性问题。不过出于本教程的目的，我们是可以使用的。</p>
<p>下面程序会输出变量 a 和 b 的类型和大小。格式说明符 <code>%T</code> 用于打印类型，而 <code>%d</code> 用于打印字节大小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">89</span></span><br><span class="line">    b := <span class="number">95</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a is&quot;</span>, a, <span class="string">&quot;and b is&quot;</span>, b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a is %T, size of a is %d&quot;</span>, a, unsafe.Sizeof(a)) <span class="comment">// a 的类型和大小</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\ntype of b is %T, size of b is %d&quot;</span>, b, unsafe.Sizeof(b)) <span class="comment">// b 的类型和大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://play.golang.org/p/mFsmjVk5oc">在线运行程序</a></p>
<p>以上程序会输出：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyvalue <span class="keyword">of</span> a <span class="keyword">is</span> <span class="number">89</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="number">95</span>  </span><br><span class="line"><span class="keyword">type</span> <span class="type">of </span>a <span class="keyword">is</span> int, size <span class="keyword">of</span> a <span class="keyword">is</span> <span class="number">4</span>  </span><br><span class="line"><span class="keyword">type</span> <span class="type">of </span>b <span class="keyword">is</span> int, size <span class="keyword">of</span> b <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出，我们可以推断出 a 和 b 为 <em>int</em> 类型，且大小都是 32 位（4 字节）。如果你在 64 位系统上运行上面的代码，会有不同的输出。在 64 位系统下，a 和 b 会占用 64 位（8 字节）的大小。</p>
<h3 id="无符号整型"><a href="#无符号整型" class="headerlink" title="无符号整型"></a>无符号整型</h3><p><strong>uint8</strong>：表示 8 位无符号整型<br><strong>大小</strong>：8 位<br><strong>范围</strong>：0～255</p>
<p><strong>uint16</strong>：表示 16 位无符号整型<br><strong>大小</strong>：16 位<br><strong>范围</strong>：0～65535</p>
<p><strong>uint32</strong>：表示 32 位无符号整型<br><strong>大小</strong>：32 位<br><strong>范围</strong>：0～4294967295</p>
<p><strong>uint64</strong>：表示 64 位无符号整型<br><strong>大小</strong>：64 位<br><strong>范围</strong>：0～18446744073709551615</p>
<p><strong>uint</strong>：根据不同的底层平台，表示 32 或 64 位无符号整型。<br><strong>大小</strong>：在 32 位系统下是 32 位，而在 64 位系统下是 64 位。<br><strong>范围</strong>：在 32 位系统下是 0～4294967295，而在 64 位系统是 0～18446744073709551615。</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p><strong>float32</strong>：32 位浮点数<br><strong>float64</strong>：64 位浮点数</p>
<p>下面一个简单程序演示了整型和浮点型的运用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a, b := <span class="number">5.67</span>, <span class="number">8.97</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of a %T b %T\n&quot;</span>, a, b)</span><br><span class="line">    sum := a + b</span><br><span class="line">    diff := a - b</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum&quot;</span>, sum, <span class="string">&quot;diff&quot;</span>, diff)</span><br><span class="line"></span><br><span class="line">    no1, no2 := <span class="number">56</span>, <span class="number">89</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;sum&quot;</span>, no1+no2, <span class="string">&quot;diff&quot;</span>, no1-no2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a 和 b 的类型根据赋值推断得出。在这里，a 和 b 的类型为 float64（float64 是浮点数的默认类型）。我们把 a 和 b 的和赋值给变量 sum，把 b 和 a 的差赋值给 diff，接下来打印 sum 和 diff。no1 和 no2 也进行了相同的计算。上述程序将会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copytype</span> of a float64 b float64  </span><br><span class="line"><span class="attribute">sum</span> <span class="number">14</span>.<span class="number">64</span> diff -<span class="number">3</span>.<span class="number">3000000000000007</span>  </span><br><span class="line"><span class="attribute">sum</span> <span class="number">145</span> diff -<span class="number">33</span></span><br></pre></td></tr></table></figure>

<h3 id="复数类型"><a href="#复数类型" class="headerlink" title="复数类型"></a>复数类型</h3><p><strong>complex64</strong>：实部和虚部都是 float32 类型的的复数。<br><strong>complex128</strong>：实部和虚部都是 float64 类型的的复数。</p>
<p>内建函数 <strong>complex</strong>用于创建一个包含实部和虚部的复数。complex 函数的定义如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc <span class="built_in">complex</span>(r, i FloatType) ComplexType</span><br></pre></td></tr></table></figure>

<p>该函数的参数分别是实部和虚部，并返回一个复数类型。实部和虚部应该是相同类型，也就是 float32 或 float64。如果实部和虚部都是 float32 类型，则函数会返回一个 complex64 类型的复数。如果实部和虚部都是 float64 类型，则函数会返回一个 complex128 类型的复数。</p>
<p>还可以使用简短语法来创建复数：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyc</span> := <span class="number">6</span> + <span class="number">7</span>i</span><br></pre></td></tr></table></figure>

<p>下面我们编写一个简单的程序来理解复数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    c1 := <span class="built_in">complex</span>(<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line">    c2 := <span class="number">8</span> + <span class="number">27i</span></span><br><span class="line">    cadd := c1 + c2</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, cadd)</span><br><span class="line">    cmul := c1 * c2</span><br><span class="line">    fmt.Println(<span class="string">&quot;product:&quot;</span>, cmul)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序里，c1 和 c2 是两个复数。c1的实部为 5，虚部为 7。c2 的实部为8，虚部为 27。c1 和 c2 的和赋值给 <code>cadd</code> ，而 c1 和 c2 的乘积赋值给 <code>cmul</code>。该程序将输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copysum</span>: (<span class="number">13</span>+<span class="number">34</span>i)  </span><br><span class="line"><span class="attribute">product</span>: (-<span class="number">149</span>+<span class="number">191</span>i)</span><br></pre></td></tr></table></figure>

<h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><p><strong>byte</strong> 是 uint8 的别名。<br><strong>rune</strong> 是 int32 的别名。</p>
<p>在学习字符串的时候，我们会详细讨论 byte 和 rune。</p>
<h3 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h3><p>在 Golang 中，字符串是字节的集合。如果你现在还不理解这个定义，也没有关系。我们可以暂且认为一个字符串就是由很多字符组成的。我们后面会在一个教程中深入学习字符串。 下面编写一个使用字符串的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    first := <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    last := <span class="string">&quot;Ramanathan&quot;</span></span><br><span class="line">    name := first +<span class="string">&quot; &quot;</span>+ last</span><br><span class="line">    fmt.Println(<span class="string">&quot;My name is&quot;</span>,name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中，first 赋值为字符串 “Naveen”，last 赋值为字符串 “Ramanathan”。+ 操作符可以用于拼接字符串。我们拼接了 first、空格和 last，并将其赋值给 name。上述程序将打印输出 <code>My name is Naveen Ramanathan</code>。</p>
<p>还有许多应用于字符串上面的操作，我们将会在一个单独的教程里看见它们。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Go 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。我们通过一个例子说明这意味着什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">55</span>      <span class="comment">//int</span></span><br><span class="line">    j := <span class="number">67.8</span>    <span class="comment">//float64</span></span><br><span class="line">    sum := i + j <span class="comment">//不允许 int + float64</span></span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在 C 语言中是完全合法的，然而在 Go 中，却是行不通的。i 的类型是 int ，而 j 的类型是 float64 ，我们正试图把两个不同类型的数相加，Go 不允许这样的操作。如果运行程序，你会得到 <code>main.go:10: invalid operation: i + j (mismatched types int and float64)</code>。</p>
<p>要修复这个错误，i 和 j 应该是相同的类型。在这里，我们把 j 转换为 int 类型。把 v 转换为 T 类型的语法是 T(v)。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">55</span>      <span class="comment">//int</span></span><br><span class="line">    j := <span class="number">67.8</span>    <span class="comment">//float64</span></span><br><span class="line">    sum := i + <span class="type">int</span>(j) <span class="comment">//j is converted to int</span></span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当你运行上面的程序时，会看见输出 <code>122</code>。</p>
<p>赋值的情况也是如此。把一个变量赋值给另一个不同类型的变量，需要显式的类型转换。下面程序说明了这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> j <span class="type">float64</span> = <span class="type">float64</span>(i) <span class="comment">// 若没有显式转换，该语句会报错</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;j&quot;</span>, j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 9 行，i 转换为 float64 类型，接下来赋值给 j。如果不进行类型转换，当你试图把 i 赋值给 j 时，编译器会抛出错误。</p>
<h1 id="5-常量"><a href="#5-常量" class="headerlink" title="5. 常量"></a>5. 常量</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在 Go 语言中，术语”常量”用于表示固定的值。比如 <code>5</code> 、<code>-89</code>、 <code>I love Go</code>、<code>67.89</code> 等等。</p>
<p>看看下面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyvar a <span class="type">int</span> = <span class="number">50</span>  </span><br><span class="line"><span class="keyword">var</span> b <span class="type">string</span> = <span class="string">&quot;I love Go&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>在上面的代码中，变量 a 和 b 分别被赋值为常量 50 和 I love GO</strong>。关键字 <code>const</code> 被用于表示常量，比如 <code>50</code> 和 <code>I love Go</code>。即使在上面的代码中我们没有明确的使用关键字 <code>const</code>，但是在 Go 的内部，它们是常量。</p>
<p>顾名思义，常量不能再重新赋值为其他的值。因此下面的程序将不能正常工作，它将出现一个编译错误: <code>cannot assign to a.</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">55</span> <span class="comment">// 允许</span></span><br><span class="line">    a = <span class="number">89</span>       <span class="comment">// 不允许重新赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量的值会在编译的时候确定。因为函数调用发生在运行时，所以不能将函数的返回值赋值给常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, playground&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> a = math.Sqrt(<span class="number">4</span>)   <span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">const</span> b = math.Sqrt(<span class="number">4</span>) <span class="comment">// 不允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，因为 <code>a</code> 是变量，因此我们可以将函数 <code>math.Sqrt(4)</code> 的返回值赋值给它（我们将在单独的地方详细讨论函数）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b<span class="string">` 是一个常量，它的值需要在编译的时候就确定。函数 `</span>math.Sqrt(<span class="number">4</span>)<span class="string">` 只会在运行的时候计算，因此 `</span><span class="keyword">const</span> b = math.Sqrt(<span class="number">4</span>)<span class="string">` 将会抛出错误 `</span><span class="type">error</span> main.<span class="keyword">go</span>:<span class="number">11</span>: <span class="keyword">const</span> initializer math.Sqrt(<span class="number">4</span>) is not a constant)</span><br></pre></td></tr></table></figure>

<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>双引号中的任何值都是 Go 中的字符串常量。例如像 <code>Hello World</code> 或 <code>Sam</code> 等字符串在 Go 中都是常量。</p>
<p>什么类型的字符串属于常量？答案是他们是无类型的。</p>
<p>像 <code>Hello World</code> 这样的字符串常量没有任何类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyconst hello = <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，我们把 <code>Hello World</code> 分配给常量 <code>hello</code>。现在常量 <code>hello</code> 有类型吗？答案是没有。常量仍然没有类型。</p>
<p>Go 是一门强类型语言，所有的变量必须有明确的类型。那么, 下面的程序是如何将无类型的常量 <code>Sam</code> 赋值给变量 <code>name</code> 的呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Sam&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type %T value %v&quot;</span>, name, name)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案是无类型的常量有一个与它们相关联的默认类型，并且当且仅当一行代码需要时才提供它。在声明中 var name = “Sam” ， name 需要一个类型，它从字符串常量 Sam 的默认类型中获取。</strong></p>
<p>有没有办法创建一个带类型的常量？答案是可以的。以下代码创建一个有类型常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyconst typedhello <span class="type">string</span> = <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中， <code>typedhello</code> 就是一个 <code>string</code> 类型的常量。</p>
<p>Go 是一个强类型的语言，在分配过程中混合类型是不允许的。让我们通过以下程序看看这句话是什么意思。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">        <span class="keyword">var</span> defaultName = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">        <span class="keyword">type</span> myString <span class="type">string</span></span><br><span class="line">        <span class="keyword">var</span> customName myString = <span class="string">&quot;Sam&quot;</span> <span class="comment">// 允许</span></span><br><span class="line">        customName = defaultName <span class="comment">// 不允许</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先创建一个变量 <code>defaultName</code> 并分配一个常量 <code>Sam</code> 。<strong>常量 Sam 的默认类型是 string ，所以在赋值后 defaultName 是 string 类型的。</strong></p>
<p>下一行，我们将创建一个新类型 <code>myString</code>，它是 <code>string</code> 的别名。</p>
<p>然后我们创建一个 <code>myString</code> 的变量 <code>customName</code> 并且给他赋值一个常量 <code>Sam</code> 。因为常量 <code>Sam</code> 是无类型的，它可以分配给任何字符串变量。因此这个赋值是允许的，<code>customName</code> 的类型是 <code>myString</code>。</p>
<p>现在，我们有一个类型为 <code>string</code> 的变量 <code>defaultName</code> 和另一个类型为 <code>myString</code> 的变量 <code>customName</code>。即使我们知道这个 <code>myString</code> 是 <code>string</code> 类型的别名。Go 的类型策略不允许将一种类型的变量赋值给另一种类型的变量。因此将 <code>defaultName</code> 赋值给 <code>customName</code> 是不允许的，编译器会抛出一个错误 <code>main.go:7:20: cannot use defaultName (type string) as type myString in assignmen</code>。</p>
<h3 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h3><p>布尔常量和字符串常量没有什么不同。他们是两个无类型的常量 <code>true</code> 和 <code>false</code>。字符串常量的规则适用于布尔常量，所以在这里我们不再重复。以下是解释布尔常量的简单程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainfunc main() &#123;      <span class="keyword">const</span> trueConst = <span class="literal">true</span>    <span class="keyword">type</span> myBool <span class="type">bool</span>    <span class="keyword">var</span> defaultBool = trueConst <span class="comment">// 允许    var customBool myBool = trueConst // 允许    defaultBool = customBool // 不允许&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的程序是自我解释的。</p>
<h3 id="数字常量"><a href="#数字常量" class="headerlink" title="数字常量"></a>数字常量</h3><p>数字常量包含整数、浮点数和复数的常量。数字常量中有一些微妙之处。</p>
<p>让我们看一些例子来说清楚。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage mainimport (      <span class="string">&quot;fmt&quot;</span>)<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;      <span class="keyword">const</span> a = <span class="number">5</span>    <span class="keyword">var</span> intVar <span class="type">int</span> = a    <span class="keyword">var</span> int32Var <span class="type">int32</span> = a    <span class="keyword">var</span> float64Var <span class="type">float64</span> = a    <span class="keyword">var</span> complex64Var <span class="type">complex64</span> = a    fmt.Println(<span class="string">&quot;intVar&quot;</span>,intVar, <span class="string">&quot;\nint32Var&quot;</span>, int32Var, <span class="string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="string">&quot;\ncomplex64Var&quot;</span>,complex64Var)&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序，常量 <code>a</code> 是没有类型的，它的值是 <code>5</code> 。您可能想知道 <code>a</code> 的默认类型是什么，如果它确实有一个的话, 那么我们如何将它分配给不同类型的变量。答案在于 <code>a</code> 的语法。下面的程序将使事情更加清晰。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> f = <span class="number">5.6</span></span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">5</span> + <span class="number">6i</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;i&#x27;s type %T, f&#x27;s type %T, c&#x27;s type %T&quot;</span>, i, f, c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，每个变量的类型由数字常量的语法决定。<code>5</code> 在语法中是整数， <code>5.6</code> 是浮点数，<code>5+6i</code> 的语法是复数。当我们运行上面的程序，它会打印出 <code>i&#39;s type int, f&#39;s type float64, c&#39;s type complex128</code>。</p>
<p>现在我希望下面的程序能够正确的工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> intVar <span class="type">int</span> = a</span><br><span class="line">    <span class="keyword">var</span> int32Var <span class="type">int32</span> = a</span><br><span class="line">    <span class="keyword">var</span> float64Var <span class="type">float64</span> = a</span><br><span class="line">    <span class="keyword">var</span> complex64Var <span class="type">complex64</span> = a</span><br><span class="line">    fmt.Println(<span class="string">&quot;intVar&quot;</span>,intVar, <span class="string">&quot;\nint32Var&quot;</span>, int32Var, <span class="string">&quot;\nfloat64Var&quot;</span>, float64Var, <span class="string">&quot;\ncomplex64Var&quot;</span>,complex64Var)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中， <code>a</code> 的值是 <code>5</code> ，<code>a</code> 的语法是通用的（它可以代表一个浮点数、整数甚至是一个没有虚部的复数），因此可以将其分配给任何兼容的类型。这些常量的默认类型可以被认为是根据上下文在运行中生成的。 <code>var intVar int = a</code> 要求 <code>a</code> 是 <code>int</code>，所以它变成一个 <code>int</code> 常量。 <code>var complex64Var complex64 = a</code> 要求 <code>a</code> 是 <code>complex64</code>，因此它变成一个复数类型。很简单的:)。</p>
<h3 id="数字表达式"><a href="#数字表达式" class="headerlink" title="数字表达式"></a>数字表达式</h3><p>数字常量可以在表达式中自由混合和匹配，只有当它们被分配给变量或者在需要类型的代码中的任何地方使用时，才需要类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">5.9</span>/<span class="number">8</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a&#x27;s type %T value %v&quot;</span>,a, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中， <code>5.9</code> 在语法中是浮点型，<code>8</code> 是整型，<code>5.9/8</code> 是允许的，因为两个都是数字常量。除法的结果是 <code>0.7375</code> 是一个浮点型，所以 <code>a</code> 的类型是浮点型。这个程序的输出结果是: <code>a&#39;s type float64 value 0.7375</code>。</p>
<h1 id="6-函数（Function）"><a href="#6-函数（Function）" class="headerlink" title="6. 函数（Function）"></a>6. 函数（Function）</h1><h2 id="函数是什么？"><a href="#函数是什么？" class="headerlink" title="函数是什么？"></a>函数是什么？</h2><p>函数是一块执行特定任务的代码。一个函数是在输入源基础上，通过执行一系列的算法，生成预期的输出。</p>
<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><p>在 Go 语言中，函数声明通用语法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc functionname(parametername <span class="keyword">type</span>) returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体实现的功能）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的声明以关键词 <code>func</code> 开始，后面紧跟自定义的函数名 <code>functionname (函数名)</code>。函数的参数列表定义在 <code>(</code> 和 <code>)</code> 之间，返回值的类型则定义在之后的 <code>returntype (返回值类型)</code>处。声明一个参数的语法采用 <strong>参数名</strong> <strong>参数类型</strong> 的方式，任意多个参数采用类似 <code>(parameter1 type, parameter2 type) 即(参数1 参数1的类型,参数2 参数2的类型)</code>的形式指定。之后包含在 <code>&#123;</code> 和 <code>&#125;</code> 之间的代码，就是函数体。</p>
<p>函数中的参数列表和返回值并非是必须的，所以下面这个函数的声明也是有效的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc functionname() &#123;  </span><br><span class="line">    <span class="comment">// 译注: 表示这个函数不需要输入参数，且没有返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h2><p>我们以写一个计算商品价格的函数为例，输入参数是单件商品的价格和商品的个数，两者的乘积为商品总价，作为函数的输出值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc calculateBill(price <span class="type">int</span>, no <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> totalPrice = price * no <span class="comment">// 商品总价 = 商品单价 * 数量</span></span><br><span class="line">    <span class="keyword">return</span> totalPrice <span class="comment">// 返回总价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数有两个整型的输入 <code>price</code> 和 <code>no</code>，返回值 <code>totalPrice</code> 为 <code>price</code> 和 <code>no</code> 的乘积，也是整数类型。</p>
<p><strong>如果有连续若干个参数，它们的类型一致，那么我们无须一一罗列，只需在最后一个参数后添加该类型。</strong> 例如，<code>price int, no int</code> 可以简写为 <code>price, no int</code>，所以示例函数也可写成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc calculateBill(price, no <span class="type">int</span>) <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> totalPrice = price * no</span><br><span class="line">    <span class="keyword">return</span> totalPrice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经定义了一个函数，我们要在代码中尝试着调用它。调用函数的语法为 <code>functionname(parameters)</code>。调用示例函数的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopycalculateBill(<span class="number">10</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>完成了示例函数声明和调用后，我们就能写出一个完整的程序，并把商品总价打印在控制台上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calculateBill</span><span class="params">(price, no <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> totalPrice = price * no</span><br><span class="line">    <span class="keyword">return</span> totalPrice</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    price, no := <span class="number">90</span>, <span class="number">6</span> <span class="comment">// 定义 price 和 no,默认类型为 int</span></span><br><span class="line">    totalPrice := calculateBill(price, no)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Total price is&quot;</span>, totalPrice) <span class="comment">// 打印到控制台上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序在控制台上打印的结果为</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyTotal price <span class="keyword">is</span> <span class="number">540</span></span><br></pre></td></tr></table></figure>

<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p>Go 语言支持一个函数可以有多个返回值。我们来写个以矩形的长和宽为输入参数，计算并返回矩形面积和周长的函数 <code>rectProps</code>。矩形的面积是长度和宽度的乘积, 周长是长度和宽度之和的两倍。即：</p>
<ul>
<li><code>面积 = 长 * 宽</code></li>
<li><code>周长 = 2 * ( 长 + 宽 )</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span>(<span class="type">float64</span>, <span class="type">float64</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> area = length * width</span><br><span class="line">    <span class="keyword">var</span> perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> area, perimeter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    area, perimeter := rectProps(<span class="number">10.8</span>, <span class="number">5.6</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area %f Perimeter %f&quot;</span>, area, perimeter) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数有多个返回值，那么这些返回值必须用 <code>(</code> 和 <code>)</code> 括起来。<code>func rectProps(length, width float64)(float64, float64)</code> 示例函数有两个 float64 类型的输入参数 <code>length</code> 和 <code>width</code>，并返回两个 float64 类型的值。该程序在控制台上打印结果为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyArea</span> <span class="number">60</span>.<span class="number">480000</span> Perimeter <span class="number">32</span>.<span class="number">800000</span></span><br></pre></td></tr></table></figure>

<h2 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h2><p>从函数中可以返回一个命名值。一旦命名了返回值，可以认为这些值在函数第一行就被声明为变量了。</p>
<p>上面的 rectProps 函数也可用这个方式写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc rectProps(length, width <span class="type">float64</span>)(area, perimeter <span class="type">float64</span>) &#123;  </span><br><span class="line">    area = length * width</span><br><span class="line">    perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 不需要明确指定返回值，默认返回 area, perimeter 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意, 函数中的 return 语句没有显式返回任何值。由于 <strong>area</strong> 和 <strong>perimeter</strong> 在函数声明中指定为返回值, 因此当遇到 return 语句时, 它们将自动从函数返回。</p>
<h2 id="空白符"><a href="#空白符" class="headerlink" title="空白符"></a>空白符</h2><p><strong>_</strong> 在 Go 中被用作空白符，可以用作表示任何类型的任何值。</p>
<p>我们继续以 <code>rectProps</code> 函数为例，该函数计算的是面积和周长。假使我们只需要计算面积，而并不关心周长的计算结果，该怎么调用这个函数呢？这时，空白符 <strong>_</strong> 就上场了。</p>
<p>下面的程序我们只用到了函数 <code>rectProps</code> 的一个返回值 <code>area</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">float64</span>) &#123;  </span><br><span class="line">    <span class="keyword">var</span> area = length * width</span><br><span class="line">    <span class="keyword">var</span> perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> area, perimeter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    area, _ := rectProps(<span class="number">10.8</span>, <span class="number">5.6</span>) <span class="comment">// 返回值周长被丢弃</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area %f &quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在程序的 <code>area, _ := rectProps(10.8, 5.6)</code> 这一行，我们看到空白符 <code>_</code> 用来跳过不要的计算结果。</p>
</blockquote>
<h1 id="7-包"><a href="#7-包" class="headerlink" title="7. 包"></a>7. 包</h1><h3 id="什么是包，为什么使用包？"><a href="#什么是包，为什么使用包？" class="headerlink" title="什么是包，为什么使用包？"></a>什么是包，为什么使用包？</h3><p>到目前为止，我们看到的 Go 程序都只有一个文件，文件里包含一个 main 函数和几个其他的函数。在实际中，这种把所有源代码编写在一个文件的方法并不好用。以这种方式编写，代码的重用和维护都会很困难。而包（Package）解决了这样的问题。</p>
<p><strong>包用于组织 Go 源代码，提供了更好的可重用性与可读性</strong>。由于包提供了代码的封装，因此使得 Go 应用程序易于维护。</p>
<p>例如，假如我们正在开发一个 Go 图像处理程序，它提供了图像的裁剪、锐化、模糊和彩色增强等功能。一种组织程序的方式就是根据不同的特性，把代码放到不同的包中。比如裁剪可以是一个单独的包，而锐化是另一个包。这种方式的优点是，由于彩色增强可能需要一些锐化的功能，因此彩色增强的代码只需要简单地导入（我们会在随后讨论）锐化功能的包，就可以使用锐化的功能了。这样的方式使得代码易于重用。</p>
<p>我们会逐步构建一个计算矩形的面积和对角线的应用程序。</p>
<p>通过这个程序，我们会更好地理解包。</p>
<h3 id="main-函数和-main-包"><a href="#main-函数和-main-包" class="headerlink" title="main 函数和 main 包"></a>main 函数和 main 包</h3><p>所有可执行的 Go 程序都必须包含一个 main 函数。这个函数是程序运行的入口。main 函数应该放置于 main 包中。</p>
<p><strong>package packagename 这行代码指定了某一源文件属于一个包。它应该放在每一个源文件的第一行。</strong></p>
<p>下面开始为我们的程序创建一个 main 函数和 main 包。<strong>在 Go 工作区内的 src 文件夹中创建一个文件夹，命名为 geometry</strong>。在 <code>geometry</code> 文件夹中创建一个 <code>geometry.go</code> 文件。</p>
<p>在 geometry.go 中编写下面代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// geometry.go</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;Geometrical shape properties&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>package main</code> 这一行指定该文件属于 main 包。<code>import &quot;packagename&quot;</code> 语句用于导入一个已存在的包。在这里我们导入了 <code>fmt</code> 包，包内含有 Println 方法。接下来是 main 函数，它会打印 <code>Geometrical shape properties</code>。</p>
<p>键入 <code>go install geometry</code>，编译上述程序。该命令会在 <code>geometry</code> 文件夹内搜索拥有 main 函数的文件。在这里，它找到了 <code>geometry.go</code>。接下来，它编译并产生一个名为 <code>geometry</code> （在 windows 下是 <code>geometry.exe</code>）的二进制文件，该二进制文件放置于工作区的 bin 文件夹。现在，工作区的目录结构会是这样：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copysrc</span><br><span class="line">    <span class="built_in">geometry</span></span><br><span class="line">        gemometry.go</span><br><span class="line">bin</span><br><span class="line">    <span class="built_in">geometry</span></span><br></pre></td></tr></table></figure>

<p>键入 <code>workspacepath/bin/geometry</code>，运行该程序。请用你自己的 Go 工作区来替换 <code>workspacepath</code>。这个命令会执行 bin 文件夹里的 <code>geometry</code> 二进制文件。你应该会输出 <code>Geometrical shape properties</code>。</p>
<h3 id="创建自定义的包"><a href="#创建自定义的包" class="headerlink" title="创建自定义的包"></a>创建自定义的包</h3><p>我们将组织代码，使得所有与矩形有关的功能都放入 <code>rectangle</code> 包中。</p>
<p>我们会创建一个自定义包 <code>rectangle</code>，它有一个计算矩形的面积和对角线的函数。</p>
<p><strong>属于某一个包的源文件都应该放置于一个单独命名的文件夹里。按照 Go 的惯例，应该用包名命名该文件夹。</strong></p>
<p>因此，我们在 <code>geometry</code> 文件夹中，创建一个命名为 <code>rectangle</code> 的文件夹。在 <code>rectangle</code> 文件夹中，所有文件都会以 <code>package rectangle</code> 作为开头，因为它们都属于 rectangle 包。</p>
<p>在我们之前创建的 rectangle 文件夹中，再创建一个名为 <code>rectprops.go</code> 的文件，添加下列代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// rectprops.go</span></span><br><span class="line"><span class="keyword">package</span> rectangle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Area</span><span class="params">(<span class="built_in">len</span>, wid <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    area := <span class="built_in">len</span> * wid</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Diagonal</span><span class="params">(<span class="built_in">len</span>, wid <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    diagonal := math.Sqrt((<span class="built_in">len</span> * <span class="built_in">len</span>) + (wid * wid))</span><br><span class="line">    <span class="keyword">return</span> diagonal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们创建了两个函数用于计算 <code>Area</code> 和 <code>Diagonal</code>。矩形的面积是长和宽的乘积。矩形的对角线是长与宽平方和的平方根。<code>math</code> 包下面的 <code>Sqrt</code> 函数用于计算平方根。</p>
<p>注意到函数 Area 和 Diagonal 都是以大写字母开头的。这是有必要的，我们将会很快解释为什么需要这样做。</p>
<h3 id="导入自定义包"><a href="#导入自定义包" class="headerlink" title="导入自定义包"></a>导入自定义包</h3><p>为了使用自定义包，我们必须要先导入它。导入自定义包的语法为 <code>import path</code>。我们必须指定自定义包相对于工作区内 <code>src</code> 文件夹的相对路径。我们目前的文件夹结构是：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copysrc</span><br><span class="line">    geometry</span><br><span class="line">        geometry.<span class="built_in">go</span></span><br><span class="line">        <span class="built_in">rectangle</span></span><br><span class="line">            rectprops.<span class="built_in">go</span></span><br></pre></td></tr></table></figure>

<p><code>import &quot;geometry/rectangle&quot;</code> 这一行会导入 rectangle 包。</p>
<p>在 <code>geometry.go</code> 里面添加下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// geometry.go</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;geometry/rectangle&quot;</span> <span class="comment">// 导入自定义包</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> rectLen, rectWidth <span class="type">float64</span> = <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Geometrical shape properties&quot;</span>)</span><br><span class="line">    <span class="comment">/*Area function of rectangle package used*/</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;area of rectangle %.2f\n&quot;</span>, rectangle.Area(rectLen, rectWidth))</span><br><span class="line">    <span class="comment">/*Diagonal function of rectangle package used*/</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;diagonal of the rectangle %.2f &quot;</span>, rectangle.Diagonal(rectLen, rectWidth))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码导入了 <code>rectangle</code> 包，并调用了里面的 Area 和 Diagonal 函数，得到矩形的面积和对角线。Printf 内的格式说明符 <code>%.2f</code> 会将浮点数截断到小数点两位。应用程序的输出为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyGeometrical</span> shape properties  </span><br><span class="line"><span class="attribute">area</span> of rectangle <span class="number">42</span>.<span class="number">00</span>  </span><br><span class="line"><span class="attribute">diagonal</span> of the rectangle <span class="number">9</span>.<span class="number">22</span></span><br></pre></td></tr></table></figure>

<h3 id="导出名字（Exported-Names）"><a href="#导出名字（Exported-Names）" class="headerlink" title="导出名字（Exported Names）"></a>导出名字（Exported Names）</h3><p>我们将 rectangle 包中的函数 Area 和 Diagonal 首字母大写。在 Go 中这具有特殊意义。在 Go 中，任何以大写字母开头的变量或者函数都是被导出的名字。其它包只能访问被导出的函数和变量。在这里，我们需要在 main 包中访问 Area 和 Diagonal 函数，因此会将它们的首字母大写。</p>
<p>在 <code>rectprops.go</code> 中，如果函数名从 <code>Area(len, wid float64)</code> 变为 <code>area(len, wid float64)</code>，并且在 <code>geometry.go</code> 中， <code>rectangle.Area(rectLen, rectWidth)</code> 变为 <code>rectangle.area(rectLen, rectWidth)</code>， 则该程序运行时，编译器会抛出错误 <code>geometry.go:11: cannot refer to unexported name rectangle.area</code>。因为如果想在包外访问一个函数，它应该首字母大写。</p>
<h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h3><p>所有包都可以包含一个 <code>init</code> 函数。init 函数不应该有任何返回值类型和参数，在我们的代码中也不能显式地调用它。init 函数的形式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc init() &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init 函数可用于执行初始化任务，也可用于在开始执行之前验证程序的正确性。</p>
<p>包的初始化顺序如下：</p>
<ol>
<li>首先初始化包级别（Package Level）的变量</li>
<li>紧接着调用 init 函数。包可以有多个 init 函数（在一个文件或分布于多个文件中），它们按照编译器解析它们的顺序进行调用。</li>
</ol>
<p>如果一个包导入了另一个包，会先初始化被导入的包。</p>
<p>尽管一个包可能会被导入多次，但是它只会被初始化一次。</p>
<p>为了理解 init 函数，我们接下来对程序做了一些修改。</p>
<p>首先在 <code>rectprops.go</code> 文件中添加了一个 init 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// rectprops.go</span></span><br><span class="line"><span class="keyword">package</span> rectangle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * init function added</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;rectangle package initialized&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Area</span><span class="params">(<span class="built_in">len</span>, wid <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    area := <span class="built_in">len</span> * wid</span><br><span class="line">    <span class="keyword">return</span> area</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Diagonal</span><span class="params">(<span class="built_in">len</span>, wid <span class="type">float64</span>)</span></span> <span class="type">float64</span> &#123;  </span><br><span class="line">    diagonal := math.Sqrt((<span class="built_in">len</span> * <span class="built_in">len</span>) + (wid * wid))</span><br><span class="line">    <span class="keyword">return</span> diagonal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们添加了一个简单的 init 函数，它仅打印 <code>rectangle package initialized</code>。</p>
<p>现在我们来修改 main 包。我们知道矩形的长和宽都应该大于 0，我们将在 <code>geometry.go</code> 中使用 init 函数和包级别的变量来检查矩形的长和宽。</p>
<p>修改 <code>geometry.go</code> 文件如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// geometry.gopackage main import (      &quot;fmt&quot;    &quot;geometry/rectangle&quot; // 导入自定义包    &quot;log&quot;)/* * 1. 包级别变量*/var rectLen, rectWidth float64 = 6, 7 /**2. init 函数会检查长和宽是否大于0*/func init() &#123;      println(&quot;main package initialized&quot;)    if rectLen &lt; 0 &#123;        log.Fatal(&quot;length is less than zero&quot;)    &#125;    if rectWidth &lt; 0 &#123;        log.Fatal(&quot;width is less than zero&quot;)    &#125;&#125;func main() &#123;      fmt.Println(&quot;Geometrical shape properties&quot;)    fmt.Printf(&quot;area of rectangle %.2f\n&quot;, rectangle.Area(rectLen, rectWidth))    fmt.Printf(&quot;diagonal of the rectangle %.2f &quot;,rectangle.Diagonal(rectLen, rectWidth))&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们对 <code>geometry.go</code> 做了如下修改：</p>
<ol>
<li>变量 <strong>rectLen</strong> 和 <strong>rectWidth</strong> 从 main 函数级别移到了包级别。</li>
<li>添加了 init 函数。当 rectLen 或 rectWidth 小于 0 时，init 函数使用 <strong>log.Fatal</strong> 函数打印一条日志，并终止了程序。</li>
</ol>
<p>main 包的初始化顺序为：</p>
<ol>
<li>首先初始化被导入的包。因此，首先初始化了 rectangle 包。</li>
<li>接着初始化了包级别的变量 <strong>rectLen</strong> 和 <strong>rectWidth</strong>。</li>
<li>调用 init 函数。</li>
<li>最后调用 main 函数。</li>
</ol>
<p>当运行该程序时，会有如下输出。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyrectangle</span> package initialized  main package initialized  Geometrical shape properties  area of rectangle <span class="number">42</span>.<span class="number">00</span>  diagonal of the rectangle <span class="number">9</span>.<span class="number">22</span></span><br></pre></td></tr></table></figure>

<p>果然，程序会首先调用 rectangle 包的 init 函数，然后，会初始化包级别的变量 <strong>rectLen</strong> 和 <strong>rectWidth</strong>。接着调用 main 包里的 init 函数，该函数检查 rectLen 和 rectWidth 是否小于 0，如果条件为真，则终止程序。我们会在单独的教程里深入学习 if 语句。现在你可以认为 <code>if rectLen &lt; 0</code> 能够检查 <code>rectLen</code> 是否小于 0，并且如果是，则终止程序。<code>rectWidth</code> 条件的编写也是类似的。在这里两个条件都为假，因此程序继续执行。最后调用了 main 函数。</p>
<p>让我们接着稍微修改这个程序来学习使用 init 函数。</p>
<p>将 <code>geometry.go</code> 中的 <code>var rectLen, rectWidth float64 = 6, 7</code> 改为 <code>var rectLen, rectWidth float64 = -6, 7</code>。我们把 <code>rectLen</code> 初始化为负数。</p>
<p>现在当运行程序时，会得到：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copyrectangle</span> package initialized  main package initialized  <span class="number">2017</span>/<span class="number">04</span>/<span class="number">04</span> <span class="number">00</span>:<span class="number">28</span>:<span class="number">20</span> length is less than zero</span><br></pre></td></tr></table></figure>

<p>像往常一样， 会首先初始化 rectangle 包，然后是 main 包中的包级别的变量 rectLen 和 rectWidth。rectLen 为负数，因此当运行 init 函数时，程序在打印 <code>length is less than zero</code> 后终止。</p>
<h3 id="使用空白标识符（Blank-Identifier）"><a href="#使用空白标识符（Blank-Identifier）" class="headerlink" title="使用空白标识符（Blank Identifier）"></a>使用空白标识符（Blank Identifier）</h3><p>导入了包，却不在代码中使用它，这在 Go 中是非法的。当这么做时，编译器是会报错的。其原因是为了避免导入过多未使用的包，从而导致编译时间显著增加。将 <code>geometry.go</code> 中的代码替换为如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// geometry.go</span></span><br><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;geometry/rectangle&quot;</span> <span class="comment">// 导入自定的包</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将会抛出错误 <code>geometry.go:6: imported and not used: &quot;geometry/rectangle&quot;</code>。</p>
<p>然而，在程序开发的活跃阶段，又常常会先导入包，而暂不使用它。遇到这种情况就可以使用空白标识符 <code>_</code>。</p>
<p>下面的代码可以避免上述程序的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;geometry/rectangle&quot;</span> </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = rectangle.Area <span class="comment">// 错误屏蔽器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>var _ = rectangle.Area</code> 这一行屏蔽了错误。我们应该了解这些错误屏蔽器（Error Silencer）的动态，在程序开发结束时就移除它们，包括那些还没有使用过的包。由此建议在 import 语句下面的包级别范围中写上错误屏蔽器。</p>
<p>有时候我们导入一个包，只是为了确保它进行了初始化，而无需使用包中的任何函数或变量。例如，我们或许需要确保调用了 rectangle 包的 init 函数，而不需要在代码中使用它。这种情况也可以使用空白标识符，如下所示。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main <span class="keyword">import</span> (    _ <span class="string">&quot;geometry/rectangle&quot;</span> )<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，会输出 <code>rectangle package initialized</code>。尽管在所有代码里，我们都没有使用这个包，但还是成功初始化了它。</p>
<h1 id="8-if-else-语句"><a href="#8-if-else-语句" class="headerlink" title="8. if-else 语句"></a>8. if-else 语句</h1><p>if 是条件语句。if 语句的语法是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyif condition &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>condition</code> 为真，则执行 <code>&#123;</code> 和 <code>&#125;</code> 之间的代码。</p>
<p>不同于其他语言，例如 C 语言，Go 语言里的 <code>&#123; &#125;</code> 是必要的，即使在 <code>&#123; &#125;</code> 之间只有一条语句。</p>
<p>if 语句还有可选的 <code>else if</code> 和 <code>else</code> 部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyif condition &#123;  </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if-else 语句之间可以有任意数量的 <code>else if</code>。条件判断顺序是从上到下。如果 <code>if</code> 或 <code>else if</code> 条件判断的结果为真，则执行相应的代码块。 如果没有条件为真，则 <code>else</code> 代码块被执行。</p>
<p>让我们编写一个简单的程序来检测一个数字是奇数还是偶数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> &#123; <span class="comment">//checks if number is even</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;the number is even&quot;</span>) </span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;the number is odd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if num％2 == 0</code> 语句检测 num 取 2 的余数是否为零。 如果是为零则打印输出 “the number is even”，如果不为零则打印输出 “the number is odd”。在上面的这个程序中，打印输出的是 <code>the number is even</code>。</p>
<p><code>if</code> 还有另外一种形式，它包含一个 <code>statement</code> 可选语句部分，该组件在条件判断之前运行。它的语法是</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyif statement; condition &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们重写程序，使用上面的语法来查找数字是偶数还是奇数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> num := <span class="number">10</span>; num % <span class="number">2</span> == <span class="number">0</span> &#123; <span class="comment">//checks if number is even</span></span><br><span class="line">        fmt.Println(num,<span class="string">&quot;is even&quot;</span>) </span><br><span class="line">    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(num,<span class="string">&quot;is odd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>num</code> 在 <code>if</code> 语句中进行初始化，<code>num</code> 只能从 <code>if</code> 和 <code>else</code> 中访问。也就是说 <code>num</code> 的范围仅限于 <code>if</code> <code>else</code> 代码块。如果我们试图从其他外部的 <code>if</code> 或者 <code>else</code> 访问 <code>num</code>,编译器会不通过。</p>
<p>让我们再写一个使用 <code>else if</code> 的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    num := <span class="number">99</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">50</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;number is less than or equal to 50&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt;= <span class="number">51</span> &amp;&amp; num &lt;= <span class="number">100</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;number is between 51 and 100&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;number is greater than 100&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，如果 <code>else if num &gt;= 51 &amp;&amp; num &lt;= 100</code> 为真，程序将输出 <code>number is between 51 and 100</code>。</p>
<h3 id="一个注意点"><a href="#一个注意点" class="headerlink" title="一个注意点"></a>一个注意点</h3><p><code>else</code> 语句应该在 <code>if</code> 语句的大括号 <code>&#125;</code> 之后的同一行中。如果不是，编译器会不通过。</p>
<p>让我们通过以下程序来理解它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> &#123; <span class="comment">//checks if number is even</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;the number is even&quot;</span>) </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;the number is odd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>else</code> 语句不是从 <code>if</code> 语句结束后的 <code>&#125;</code> 同一行开始。而是从下一行开始。这是不允许的。如果运行这个程序，编译器会输出错误，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copymain.<span class="keyword">go</span>:<span class="number">12</span>:<span class="number">5</span>: syntax <span class="type">error</span>: unexpected <span class="keyword">else</span>, expecting &#125;</span><br></pre></td></tr></table></figure>

<p>出错的原因是 Go 语言的分号是自动插入。</p>
<p>在 Go 语言规则中，它指定在 <code>&#125;</code> 之后插入一个分号，如果这是该行的最终标记。因此，在if语句后面的 <code>&#125;</code> 会自动插入一个分号。</p>
<p>实际上我们的程序变成了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copyif num%<span class="number">2</span> == <span class="number">0</span> &#123;  </span><br><span class="line">      fmt.Println(<span class="string">&quot;the number is even&quot;</span>) </span><br><span class="line">&#125;;  <span class="comment">//semicolon inserted by Go</span></span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">      fmt.Println(<span class="string">&quot;the number is odd&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分号插入之后。从上面代码片段可以看出第三行插入了分号。</p>
<p>由于 <code>if&#123;…&#125; else &#123;…&#125;</code> 是一个单独的语句，它的中间不应该出现分号。因此，需要将 <code>else</code> 语句放置在 <code>&#125;</code> 之后处于同一行中。</p>
<p>我已经重写了程序，将 else 语句移动到 if 语句结束后 <code>&#125;</code> 的后面，以防止分号的自动插入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    num := <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span> &#123; <span class="comment">//checks if number is even</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;the number is even&quot;</span>) </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;the number is odd&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在编译器会很开心，我们也一样 ?。</p>
<h1 id="9-循环"><a href="#9-循环" class="headerlink" title="9. 循环"></a>9. 循环</h1><p>循环语句是用来重复执行某一段代码。</p>
<p><code>for</code> 是 Go 语言唯一的循环语句。Go 语言中并没有其他语言比如 C 语言中的 <code>while</code> 和 <code>do while</code> 循环。</p>
<h2 id="for-循环语法"><a href="#for-循环语法" class="headerlink" title="for 循环语法"></a>for 循环语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyfor initialisation; condition; post &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化语句只执行一次。循环初始化后，将检查循环条件。如果条件的计算结果为 <code>true</code> ，则 <code>&#123;&#125;</code> 内的循环体将执行，接着执行 post 语句。post 语句将在每次成功循环迭代后执行。在执行 post 语句后，条件将被再次检查。如果为 <code>true</code>, 则循环将继续执行，否则 for 循环将终止。（译注：这是典型的 for 循环三个表达式，第一个为初始化表达式或赋值语句；第二个为循环条件判定表达式；第三个为循环变量修正表达式，即此处的 post ）</p>
<p>这三个组成部分，即初始化，条件和 post 都是可选的。让我们看一个例子来更好地理解循环。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>让我们用 <code>for</code> 循环写一个打印出从 1 到 10 的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot; %d&quot;</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，i 变量被初始化为 1。条件语句会检查 i 是否小于 10。如果条件成立，i 就会被打印出来，否则循环就会终止。循环语句会在每一次循环完成后自增 1。一旦 i 变得比 10 要大，循环中止。</p>
<p>上面的程序会打印出 <code>1 2 3 4 5 6 7 8 9 10</code> 。</p>
<p>在 <code>for</code> 循环中声明的变量只能在循环体内访问，因此 i 不能够在循环体外访问。</p>
<h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p><code>break</code> 语句用于在完成正常执行之前突然终止 for 循环，之后程序将会在 for 循环下一行代码开始执行。</p>
<p>让我们写一个从 1 打印到 5 并且使用 <code>break</code> 跳出循环的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">//loop is terminated if i &gt; 5</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nline after for loop&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，在循环过程中 i 的值会被判断。如果 i 的值大于 5 然后 <code>break</code> 语句就会执行，循环就会被终止。打印语句会在 <code>for</code> 循环结束后执行，上面程序会输出为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>  </span><br><span class="line"><span class="attribute">line</span> after for loop</span><br></pre></td></tr></table></figure>

<h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p><code>continue</code> 语句用来跳出 <code>for</code> 循环中当前循环。在 <code>continue</code> 语句后的所有的 <code>for</code> 循环语句都不会在本次循环中执行。循环体会在一下次循环中继续执行。</p>
<p>让我们写一个打印出 1 到 10 并且使用 <code>continue</code> 的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，这行代码 <code>if i%2==0</code> 会判断 i 除以 2 的余数是不是 0，如果是 0，这个数字就是偶数然后执行 <code>continue</code> 语句，从而控制程序进入下一个循环。因此在 <code>continue</code> 后面的打印语句不会被调用而程序会进入一下个循环。上面程序会输出 <code>1 3 5 7 9</code>。</p>
<h2 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h2><p>让我们写更多的代码来演示 <code>for</code> 循环的多样性吧</p>
<p>下面这个程序打印出从 0 到 10 所有的偶数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> ;i &lt;= <span class="number">10</span>; &#123; <span class="comment">// initialisation and post are omitted</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如我们已经知道的那样，<code>for</code> 循环的三部分，初始化语句、条件语句、post 语句都是可选的。在上面的程序中，初始化语句和 post 语句都被省略了。i 在 <code>for</code> 循环外被初始化成了 0。只要 <code>i&lt;=10</code> 循环就会被执行。在循环中，i 以 2 的增量自增。上面的程序会输出 <code>0 2 4 6 8 10</code>。</p>
<p>上面程序中 <code>for</code> 循环中的分号也可以省略。这个格式的 <code>for</code> 循环可以看作是二选一的 <code>for while</code> 循环。上面的程序可以被重写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;= <span class="number">10</span> &#123; <span class="comment">//semicolons are ommitted and only condition is present</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>for</code> 循环中可以声明和操作多个变量。让我们写一个使用声明多个变量来打印下面序列的程序。</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Copy10 *<span class="number"> 1 </span>=<span class="number"> 10 </span> </span><br><span class="line">11 *<span class="number"> 2 </span>=<span class="number"> 22 </span> </span><br><span class="line">12 *<span class="number"> 3 </span>=<span class="number"> 36 </span> </span><br><span class="line">13 *<span class="number"> 4 </span>=<span class="number"> 52 </span> </span><br><span class="line">14 *<span class="number"> 5 </span>=<span class="number"> 70 </span> </span><br><span class="line">15 *<span class="number"> 6 </span>=<span class="number"> 90 </span> </span><br><span class="line">16 *<span class="number"> 7 </span>=<span class="number"> 112 </span> </span><br><span class="line">17 *<span class="number"> 8 </span>=<span class="number"> 136 </span> </span><br><span class="line">18 *<span class="number"> 9 </span>=<span class="number"> 162 </span> </span><br><span class="line">19 *<span class="number"> 10 </span>= 190</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (  </span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;  </span><br><span class="line">    for no, i := 10, 1; i &lt;=<span class="number"> 10 </span>&amp;&amp; no &lt;= 19; i, no = i+1, no+1 &#123; //multiple initialisation and increment</span><br><span class="line">        fmt.Printf(&quot;%d * %d = %d\n&quot;, no, i, no*i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中 <code>no</code> 和 <code>i</code> 被声明然后分别被初始化为 10 和 1 。在每一次循环结束后 <code>no</code> 和 <code>i</code> 都自增 1 。布尔型操作符 <code>&amp;&amp;</code> 被用来确保 i 小于等于 10 并且 <code>no</code> 小于等于 19 。</p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>无限循环的语法是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyfor &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一个程序就会一直打印<code>Hello World</code>不会停止。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在你本地系统上运行，来无限的打印 “Hello World” 。</p>
<p>这里还有一个 <code>range</code> 结构，它可以被用来在 <code>for</code> 循环中操作数组对象。当我们学习数组时我们会补充这方面内容。</p>
<h1 id="10-switch-语句"><a href="#10-switch-语句" class="headerlink" title="10. switch 语句"></a>10. switch 语句</h1><p>switch 是一个条件语句，用于将表达式的值与可能匹配的选项列表进行比较，并根据匹配情况执行相应的代码块。它可以被认为是替代多个 <code>if else</code> 子句的常用方式。</p>
<p>看代码比文字更容易理解。让我们从一个简单的例子开始，它将把一个手指的编号作为输入，然后输出该手指对应的名字。比如 0 是拇指，1 是食指等等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Ring&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Pinky&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中，<code>switch finger</code> 将 <code>finger</code> 的值与每个 <code>case</code> 语句进行比较。通过从上到下对每一个值进行对比，并执行与选项值匹配的第一个逻辑。在上述样例中， <code>finger</code> 值为 4，因此打印的结果是 <code>Ring</code> 。</p>
<p>在选项列表中，<code>case</code> 不允许出现重复项。如果您尝试运行下面的程序，编译器会报这样的错误: <code>main.go：18：2：在tmp / sandbox887814166 / main.go：16：7</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    finger := <span class="number">4</span></span><br><span class="line">    <span class="keyword">switch</span> finger &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Ring&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//重复项</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;Another Ring&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Pinky&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认情况（Default-Case）"><a href="#默认情况（Default-Case）" class="headerlink" title="默认情况（Default Case）"></a>默认情况（Default Case）</h2><p>我们每个人一只手只有 5 个手指。如果我们输入了不正确的手指编号会发生什么？这个时候就应该是属于默认情况。当其他情况都不匹配时，将运行默认情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> finger := <span class="number">8</span>; finger &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Thumb&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Index&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Middle&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Ring&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;Pinky&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// 默认情况</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;incorrect finger number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中 <code>finger</code> 的值是 8，它不符合其中任何情况，因此会打印 <code>incorrect finger number</code>。default 不一定只能出现在 switch 语句的最后，它可以放在 switch 语句的任何地方。</p>
<p>您可能也注意到我们稍微改变了 <code>finger</code> 变量的声明方式。<code>finger</code> 声明在了 switch 语句内。在表达式求值之前，switch 可以选择先执行一个语句。在这行 <code>switch finger：= 8; finger</code> 中， 先声明了<code>finger</code> 变量，随即在表达式中使用了它。在这里，<code>finger</code> 变量的作用域仅限于这个 switch 内。</p>
<h2 id="多表达式判断"><a href="#多表达式判断" class="headerlink" title="多表达式判断"></a>多表达式判断</h2><p>通过用逗号分隔，可以在一个 case 中包含多个表达式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    letter := <span class="string">&quot;i&quot;</span></span><br><span class="line">    <span class="keyword">switch</span> letter &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;a&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;u&quot;</span>: <span class="comment">// 一个选项多个表达式</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;vowel&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;not a vowel&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>case &quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;:</code> 这一行中，列举了所有的元音。只要匹配该项，则将输出 <code>vowel</code>。</p>
<h2 id="无表达式的-switch"><a href="#无表达式的-switch" class="headerlink" title="无表达式的 switch"></a>无表达式的 switch</h2><p>在 switch 语句中，表达式是可选的，可以被省略。如果省略表达式，则表示这个 switch 语句等同于 <code>switch true</code>，并且每个 <code>case</code> 表达式都被认定为有效，相应的代码块也会被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := <span class="number">75</span></span><br><span class="line">    <span class="keyword">switch</span> &#123; <span class="comment">// 表达式被省略了</span></span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">50</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 0 and less than 50&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">51</span> &amp;&amp; num &lt;= <span class="number">100</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 51 and less than 100&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">101</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;num is greater than 100&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，switch 中缺少表达式，因此默认它为 true，true 值会和每一个 case 的求值结果进行匹配。<code>case num &gt;= 51 &amp;&amp; &lt;= 100:</code> 为 true，所以程序输出 <code>num is greater than 51 and less than 100</code>。这种类型的 switch 语句可以替代多个 <code>if else</code> 子句。</p>
<h2 id="Fallthrough-语句"><a href="#Fallthrough-语句" class="headerlink" title="Fallthrough 语句"></a>Fallthrough 语句</h2><p>在 Go 中，每执行完一个 case 后，会从 switch 语句中跳出来，不再做后续 case 的判断和执行。使用 <code>fallthrough</code> 语句可以在已经执行完成的 case 之后，把控制权转移到下一个 case 的执行代码中。</p>
<p>让我们写一个程序来理解 fallthrough。我们的程序将检查输入的数字是否小于 50、100 或 200。例如我们输入 75，程序将输出<code>75 is lesser than 100</code> 和 <code>75 is lesser than 200</code>。我们用 fallthrough 来实现了这个功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">number</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    num := <span class="number">15</span> * <span class="number">5</span> </span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> num := number(); &#123; <span class="comment">// num is not a constant</span></span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">50</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d is lesser than 50\n&quot;</span>, num)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">100</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d is lesser than 100\n&quot;</span>, num)</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">200</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d is lesser than 200&quot;</span>, num)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch 和 case 的表达式不一定是常量。它们也可以在运行过程中通过计算得到。在上面的程序中，num 被初始化为函数 <code>number()</code> 的返回值。程序运行到 switch 中时，会计算出 case 的值。<code>case num &lt; 100：</code> 的结果为 true，所以程序输出 <code>75 is lesser than 100</code>。当执行到下一句 <code>fallthrough</code> 时，程序控制直接跳转到下一个 case 的第一个执行逻辑中，所以打印出 <code>75 is lesser than 200</code>。最后这个程序的输出会是</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copy75 <span class="keyword">is</span> lesser than <span class="number">100</span>  </span><br><span class="line"><span class="number">75</span> <span class="keyword">is</span> lesser than <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><strong>fallthrough 语句应该是 case 子句的最后一个语句。如果它出现在了 case 语句的中间，编译器将会报错：fallthrough statement out of place</strong>11. 数组和切片</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是同一类型元素的集合。例如，整数集合 5,8,9,79,76 形成一个数组。Go 语言中不允许混合不同类型的元素，例如包含字符串和整数的数组。（译者注：当然，如果是 interface{} 类型数组，可以包含任意类型）</p>
<h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><p>一个数组的表示形式为 <code>[n]T</code>。<code>n</code> 表示数组中元素的数量，<code>T</code> 代表每个元素的类型。元素的数量 <code>n</code> 也是该类型的一部分（稍后我们将详细讨论这一点）。</p>
<p>可以使用不同的方式来声明数组，让我们一个一个的来看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span> <span class="comment">//int array with length 3</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>var a[3]int</strong> 声明了一个长度为 3 的整型数组。<strong>数组中的所有元素都被自动赋值为数组类型的零值。</strong> 在这种情况下，<code>a</code> 是一个整型数组，因此 <code>a</code> 的所有元素都被赋值为 <code>0</code>，即 int 型的零值。运行上述程序将 <strong>输出</strong> <code>[0 0 0]</code>。</p>
<p>数组的索引从 <code>0</code> 开始到 <code>length - 1</code> 结束。让我们给上面的数组赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span> <span class="comment">//int array with length 3</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">12</span> <span class="comment">// array index starts at 0</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">78</span></span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">50</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a[0] 将值赋给数组的第一个元素。该程序将 <strong>输出</strong> <code>[12 78 50]</code>。</p>
<p>让我们使用 <strong>简略声明</strong> 来创建相同的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// short hand declaration to create array</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将会打印相同的 <strong>输出</strong> <code>[12 78 50]</code>。</p>
<p>在简略声明中，不需要将数组中所有的元素赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">12</span>&#125; </span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中的第 8 行 <code>a := [3]int&#123;12&#125;</code> 声明一个长度为 3 的数组，但只提供了一个值 <code>12</code>，剩下的 2 个元素自动赋值为 <code>0</code>。这个程序将<strong>输出</strong> <code>[12 0 0]</code>。</p>
<p>你甚至可以忽略声明数组的长度，并用 <code>...</code> 代替，让编译器为你自动计算长度，这在下面的程序中实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">78</span>, <span class="number">50</span>&#125; <span class="comment">// ... makes the compiler determine the length</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组的大小是类型的一部分</strong>。因此 <code>[5]int</code> 和 <code>[25]int</code> 是不同类型。数组不能调整大小，不要担心这个限制，因为 <code>slices</code> 的存在能解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">78</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    b = a <span class="comment">// not possible since [3]int and [5]int are distinct types</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 6 行中, 我们试图将类型 <code>[3]int</code> 的变量赋给类型为 <code>[5]int</code> 的变量，这是不允许的，因此编译器将抛出错误 main.go:6: cannot use a (type [3]int) as type [5]int in assignment。</p>
<h3 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h3><p>Go 中的数组是值类型而不是引用类型。这意味着当数组赋值给一个新的变量时，该变量会得到一个原始数组的一个副本。如果对新变量进行更改，则不会影响原始数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;China&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;France&quot;</span>&#125;</span><br><span class="line">    b := a <span class="comment">// a copy of a is assigned to b</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&quot;Singapore&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b is &quot;</span>, b) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 7 行，<code>a</code> 的副本被赋给 <code>b</code>。在第 8 行中，<code>b</code> 的第一个元素改为 <code>Singapore</code>。这不会在原始数组 <code>a</code> 中反映出来。该程序将 <strong>输出</strong>,</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copya <span class="keyword">is</span> <span class="comment">[USA China India Germany France]</span>  </span><br><span class="line">b <span class="keyword">is</span> <span class="comment">[Singapore China India Germany France]</span></span><br></pre></td></tr></table></figure>

<p>同样，当数组作为参数传递给函数时，它们是按值传递，而原始数组保持不变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeLocal</span><span class="params">(num [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">55</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;inside function &quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num := [...]<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;before passing to function &quot;</span>, num)</span><br><span class="line">    changeLocal(num) <span class="comment">//num is passed by value</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after passing to function &quot;</span>, num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的 13 行中, 数组 <code>num</code> 实际上是通过值传递给函数 <code>changeLocal</code>，数组不会因为函数调用而改变。这个程序将输出,</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copybefore <span class="keyword">passing</span> <span class="keyword">to</span> <span class="keyword">function</span>  [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line">inside <span class="keyword">function</span>  [<span class="number">55</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span>]</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">passing</span> <span class="keyword">to</span> <span class="keyword">function</span>  [<span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h3 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h3><p>通过将数组作为参数传递给 <code>len</code> 函数，可以得到数组的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;length of a is&quot;</span>,<span class="built_in">len</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序输出为 <code>length of a is 4</code>。</p>
<h3 id="使用-range-迭代数组"><a href="#使用-range-迭代数组" class="headerlink" title="使用 range 迭代数组"></a>使用 range 迭代数组</h3><p><code>for</code> 循环可用于遍历数组中的元素。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123; <span class="comment">// looping from 0 to the length of the array</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d th element of a is %.2f\n&quot;</span>, i, a[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序使用 <code>for</code> 循环遍历数组中的元素，从索引 <code>0</code> 到 <code>length of the array - 1</code>。这个程序运行后打印出，</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy0</span> th element of a is <span class="number">67</span>.<span class="number">70</span>  </span><br><span class="line"><span class="attribute">1</span> th element of a is <span class="number">89</span>.<span class="number">80</span>  </span><br><span class="line"><span class="attribute">2</span> th element of a is <span class="number">21</span>.<span class="number">00</span>  </span><br><span class="line"><span class="attribute">3</span> th element of a is <span class="number">78</span>.<span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>Go 提供了一种更好、更简洁的方法，通过使用 <code>for</code> 循环的 <strong>range</strong> 方法来遍历数组。<code>range</code> 返回索引和该索引处的值。让我们使用 range 重写上面的代码。我们还可以获取数组中所有元素的总和。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [...]<span class="type">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    sum := <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;<span class="comment">//range returns both the index and value</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d the element of a is %.2f\n&quot;</span>, i, v)</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nsum of all elements of a&quot;</span>,sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的第 8 行 <code>for i, v := range a</code> 利用的是 for 循环 range 方式。 它将返回索引和该索引处的值。 我们打印这些值，并计算数组 <code>a</code> 中所有元素的总和。 程序的 <strong>输出是</strong>，</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copy0 <span class="keyword">the</span> <span class="keyword">element</span> <span class="keyword">of</span> <span class="keyword">a</span> is <span class="number">67.70</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">the</span> <span class="keyword">element</span> <span class="keyword">of</span> <span class="keyword">a</span> is <span class="number">89.80</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">the</span> <span class="keyword">element</span> <span class="keyword">of</span> <span class="keyword">a</span> is <span class="number">21.00</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">the</span> <span class="keyword">element</span> <span class="keyword">of</span> <span class="keyword">a</span> is <span class="number">78.00</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> <span class="keyword">of</span> all elements <span class="keyword">of</span> <span class="keyword">a</span> <span class="number">256.5</span></span><br></pre></td></tr></table></figure>

<p>如果你只需要值并希望忽略索引，则可以通过用 <code>_</code> 空白标识符替换索引来执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyfor _, v := <span class="keyword">range</span> a &#123; <span class="comment">// ignores index  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 for 循环忽略索引，同样值也可以被忽略。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>到目前为止我们创建的数组都是一维的，Go 语言可以创建多维数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printarray</span><span class="params">(a [3][2]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> _, v1 := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s &quot;</span>, v2)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span>&#123;</span><br><span class="line">        &#123;<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pigeon&quot;</span>, <span class="string">&quot;peacock&quot;</span>&#125;, <span class="comment">// this comma is necessary. The compiler will complain if you omit this comma</span></span><br><span class="line">    &#125;</span><br><span class="line">    printarray(a)</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">3</span>][<span class="number">2</span>]<span class="type">string</span></span><br><span class="line">    b[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&quot;apple&quot;</span></span><br><span class="line">    b[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&quot;samsung&quot;</span></span><br><span class="line">    b[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&quot;microsoft&quot;</span></span><br><span class="line">    b[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">&quot;google&quot;</span></span><br><span class="line">    b[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&quot;AT&amp;T&quot;</span></span><br><span class="line">    b[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&quot;T-Mobile&quot;</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    printarray(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 17 行，用简略语法声明一个二维字符串数组 a 。20 行末尾的逗号是必需的。这是因为根据 Go 语言的规则自动插入分号。至于为什么这是必要的，如果你想了解更多，请阅读<a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html#semicolons%E3%80%82">https://golang.org/doc/effective_go.html#semicolons。</a></p>
<p>另外一个二维数组 b 在 23 行声明，字符串通过每个索引一个一个添加。这是另一种初始化二维数组的方法。</p>
<p>第 7 行的 printarray 函数使用两个 range 循环来打印二维数组的内容。上述程序的 <strong>输出是</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copylion tiger</span><br><span class="line">cat dog</span><br><span class="line">pigeon peacock</span><br><span class="line"></span><br><span class="line">apple samsung</span><br><span class="line">microsoft google</span><br><span class="line">AT&amp;<span class="built_in">T</span> <span class="built_in">T</span>-Mobile</span><br></pre></td></tr></table></figure>

<p>这就是数组，尽管数组看上去似乎足够灵活，但是它们具有固定长度的限制，不可能增加数组的长度。这就要用到 <strong>切片</strong> 了。事实上，在 Go 中，切片比传统数组更常见。</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。切片本身不拥有任何数据。它们只是对现有数组的引用。</p>
<h3 id="创建一个切片"><a href="#创建一个切片" class="headerlink" title="创建一个切片"></a>创建一个切片</h3><p>带有 T 类型元素的切片由 <code>[]T</code> 表示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">int</span> = a[<span class="number">1</span>:<span class="number">4</span>] <span class="comment">// creates a slice from a[1] to a[3]</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用语法 <code>a[start:end]</code> 创建一个从 <code>a</code> 数组索引 <code>start</code> 开始到 <code>end - 1</code> 结束的切片。因此，在上述程序的第 9 行中, <code>a[1:4]</code> 从索引 1 到 3 创建了 <code>a</code> 数组的一个切片表示。因此, 切片 <code>b</code> 的值为 <code>[77 78 79]</code>。</p>
<p>让我们看看另一种创建切片的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    c := []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125; <span class="comment">// creates and array and returns a slice reference</span></span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 9 行，<code>c：= [] int &#123;6，7，8&#125;</code> 创建一个有 3 个整型元素的数组，并返回一个存储在 c 中的切片引用。</p>
<h3 id="切片的修改"><a href="#切片的修改" class="headerlink" title="切片的修改"></a>切片的修改</h3><p>切片自己不拥有任何数据。它只是底层数组的一种表示。对切片所做的任何修改都会反映在底层数组中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    darr := [...]<span class="type">int</span>&#123;<span class="number">57</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">82</span>, <span class="number">100</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">69</span>, <span class="number">59</span>&#125;</span><br><span class="line">    dslice := darr[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;array before&quot;</span>, darr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> dslice &#123;</span><br><span class="line">        dslice[i]++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;array after&quot;</span>, darr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 9 行，我们根据数组索引 2,3,4 创建一个切片 <code>dslice</code>。for 循环将这些索引中的值逐个递增。当我们使用 for 循环打印数组时，我们可以看到对切片的更改反映在数组中。该程序的输出是</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyarray before [57 89 90 82 100 78 67 69 59]  <span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>after [57 89 91 83 101 78 67 69 59]</span><br></pre></td></tr></table></figure>

<p>当多个切片共用相同的底层数组时，每个切片所做的更改将反映在数组中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numa := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">78</span>, <span class="number">79</span> ,<span class="number">80</span>&#125;</span><br><span class="line">    nums1 := numa[:] <span class="comment">// creates a slice which contains all elements of the array</span></span><br><span class="line">    nums2 := numa[:]</span><br><span class="line">    fmt.Println(<span class="string">&quot;array before change 1&quot;</span>, numa)</span><br><span class="line">    nums1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array after modification to slice nums1&quot;</span>, numa)</span><br><span class="line">    nums2[<span class="number">1</span>] = <span class="number">101</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;array after modification to slice nums2&quot;</span>, numa)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 9 行中，<code>numa [:]</code> 缺少开始和结束值。开始和结束的默认值分别为 <code>0</code> 和 <code>len (numa)</code>。两个切片 <code>nums1</code> 和 <code>nums2</code> 共享相同的数组。该程序的输出是</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyarray before change 1 [78 79 80]  <span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>after modification to slice nums1 [100 79 80]  <span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>after modification to slice nums2 [100 101 80]</span><br></pre></td></tr></table></figure>

<p>从输出中可以清楚地看出，当切片共享同一个数组时，每个所做的修改都会反映在数组中。</p>
<h3 id="切片的长度和容量"><a href="#切片的长度和容量" class="headerlink" title="切片的长度和容量"></a>切片的长度和容量</h3><p>切片的长度是切片中的元素数。<strong>切片的容量是从创建切片索引开始的底层数组中元素数。</strong></p>
<p>让我们写一段代码来更好地理解这点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;water melon&quot;</span>, <span class="string">&quot;pine apple&quot;</span>, <span class="string">&quot;chikoo&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;length of slice %d capacity %d&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// length of is 2 and capacity is 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>fruitslice</code> 是从 <code>fruitarray</code> 的索引 1 和 2 创建的。 因此，<code>fruitlice</code> 的长度为 <code>2</code>。</p>
<p><code>fruitarray</code> 的长度是 7。<code>fruiteslice</code> 是从 <code>fruitarray</code> 的索引 <code>1</code> 创建的。因此, <code>fruitslice</code> 的容量是从 <code>fruitarray</code> 索引为 <code>1</code> 开始，也就是说从 <code>orange</code> 开始，该值是 <code>6</code>。因此, <code>fruitslice</code> 的容量为 6。该[程序]输出切片的 <strong>长度为 2 容量为 6</strong> 。</p>
<p>切片可以重置其容量。任何超出这一点将导致程序运行时抛出错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruitarray := [...]<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;grape&quot;</span>, <span class="string">&quot;mango&quot;</span>, <span class="string">&quot;water melon&quot;</span>, <span class="string">&quot;pine apple&quot;</span>, <span class="string">&quot;chikoo&quot;</span>&#125;</span><br><span class="line">    fruitslice := fruitarray[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;length of slice %d capacity %d\n&quot;</span>, <span class="built_in">len</span>(fruitslice), <span class="built_in">cap</span>(fruitslice)) <span class="comment">// length of is 2 and capacity is 6</span></span><br><span class="line">    fruitslice = fruitslice[:<span class="built_in">cap</span>(fruitslice)] <span class="comment">// re-slicing furitslice till its capacity</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;After re-slicing length is&quot;</span>,<span class="built_in">len</span>(fruitslice), <span class="string">&quot;and capacity is&quot;</span>,<span class="built_in">cap</span>(fruitslice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 11 行中，<code>fruitslice</code> 的容量是重置的。以上程序输出为，</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copylength</span> of slice <span class="number">2</span> capacity <span class="number">6</span> </span><br><span class="line"><span class="attribute">After</span> re-slicing length is <span class="number">6</span> and capacity is <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-make-创建一个切片"><a href="#使用-make-创建一个切片" class="headerlink" title="使用 make 创建一个切片"></a>使用 make 创建一个切片</h3><p>func make（[]T，len，cap）[]T 通过传递类型，长度和容量来创建切片。容量是可选参数, 默认值为切片长度。make 函数创建一个数组，并返回引用该数组的切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 make 创建切片时默认情况下这些值为零。上述程序的输出为 <code>[0 0 0 0 0]</code>。</p>
<h3 id="追加切片元素"><a href="#追加切片元素" class="headerlink" title="追加切片元素"></a>追加切片元素</h3><p>正如我们已经知道数组的长度是固定的，它的长度不能增加。 切片是动态的，使用 <code>append</code> 可以将新元素追加到切片上。append 函数的定义是 <code>func append（s[]T，x ... T）[]T</code>。</p>
<p><strong>x … T</strong> 在函数定义中表示该函数接受参数 x 的个数是可变的。这些类型的函数被称为[可变函数]。</p>
<p>有一个问题可能会困扰你。如果切片由数组支持，并且数组本身的长度是固定的，那么切片如何具有动态长度。以及内部发生了什么，当新的元素被添加到切片时，会创建一个新的数组。现有数组的元素被复制到这个新数组中，并返回这个新数组的新切片引用。现在新切片的容量是旧切片的两倍。下面的程序会让你清晰理解。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cars := []<span class="type">string</span>&#123;<span class="string">&quot;Ferrari&quot;</span>, <span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Ford&quot;</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cars:&quot;</span>, cars, <span class="string">&quot;has old length&quot;</span>, <span class="built_in">len</span>(cars), <span class="string">&quot;and capacity&quot;</span>, <span class="built_in">cap</span>(cars)) <span class="comment">// capacity of cars is 3</span></span><br><span class="line">    cars = <span class="built_in">append</span>(cars, <span class="string">&quot;Toyota&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cars:&quot;</span>, cars, <span class="string">&quot;has new length&quot;</span>, <span class="built_in">len</span>(cars), <span class="string">&quot;and capacity&quot;</span>, <span class="built_in">cap</span>(cars)) <span class="comment">// capacity of cars is doubled to 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中，<code>cars</code> 的容量最初是 3。在第 10 行，我们给 cars 添加了一个新的元素，并把 <code>append(cars, &quot;Toyota&quot;)</code> 返回的切片赋值给 cars。现在 cars 的容量翻了一番，变成了 6。上述程序的输出是</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copycars: [Ferrari Honda Ford] <span class="keyword">has</span> <span class="keyword">old</span> length <span class="number">3</span> <span class="keyword">and</span> capacity <span class="number">3</span>  </span><br><span class="line">cars: [Ferrari Honda Ford Toyota] <span class="keyword">has</span> <span class="keyword">new</span> length <span class="number">4</span> <span class="keyword">and</span> capacity <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>切片类型的零值为 <code>nil</code>。一个 <code>nil</code> 切片的长度和容量为 0。可以使用 append 函数将值追加到 <code>nil</code> 切片。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> names []<span class="type">string</span> <span class="comment">//zero value of a slice is nil</span></span><br><span class="line">    <span class="keyword">if</span> names == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;slice is nil going to append&quot;</span>)</span><br><span class="line">        names = <span class="built_in">append</span>(names, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Sebastian&quot;</span>, <span class="string">&quot;Vinay&quot;</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;names contents:&quot;</span>,names)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序 <code>names</code> 是 nil，我们已经添加 3 个字符串给 <code>names</code>。该程序的输出是</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyslice <span class="keyword">is</span> nil going <span class="keyword">to</span> append  </span><br><span class="line">names <span class="built_in">contents</span>: [John Sebastian Vinay]</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>...</code> 运算符将一个切片添加到另一个切片。 你可以在[可变参数函数]教程中了解有关此运算符的更多信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    veggies := []<span class="type">string</span>&#123;<span class="string">&quot;potatoes&quot;</span>, <span class="string">&quot;tomatoes&quot;</span>, <span class="string">&quot;brinjal&quot;</span>&#125;</span><br><span class="line">    fruits := []<span class="type">string</span>&#123;<span class="string">&quot;oranges&quot;</span>, <span class="string">&quot;apples&quot;</span>&#125;</span><br><span class="line">    food := <span class="built_in">append</span>(veggies, fruits...)</span><br><span class="line">    fmt.Println(<span class="string">&quot;food:&quot;</span>,food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 10 行，food 是通过 append(veggies, fruits…) 创建。程序的输出为 <code>food: [potatoes tomatoes brinjal oranges apples]</code>。</p>
<h3 id="切片的函数传递"><a href="#切片的函数传递" class="headerlink" title="切片的函数传递"></a>切片的函数传递</h3><p>我们可以认为，切片在内部可由一个结构体类型表示。这是它的表现形式，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copytype slice <span class="keyword">struct</span> &#123;  </span><br><span class="line">    Length        <span class="type">int</span></span><br><span class="line">    Capacity      <span class="type">int</span></span><br><span class="line">    ZerothElement *<span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切片包含长度、容量和指向数组第零个元素的指针。当切片传递给函数时，即使它通过值传递，指针变量也将引用相同的底层数组。因此，当切片作为参数传递给函数时，函数内所做的更改也会在函数外可见。让我们写一个程序来检查这点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subtactOne</span><span class="params">(numbers []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">        numbers[i] -= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nos := []<span class="type">int</span>&#123;<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice before function call&quot;</span>, nos)</span><br><span class="line">    subtactOne(nos)                               <span class="comment">// function modifies the slice</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;slice after function call&quot;</span>, nos) <span class="comment">// modifications are visible outside</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序的行号 17 中，调用函数将切片中的每个元素递减 2。在函数调用后打印切片时，这些更改是可见的。如果你还记得，这是不同于数组的，对于函数中一个数组的变化在函数外是不可见的。上述[程序]的输出是，</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyarray before function call [8 7 6]  <span class="built_in"></span></span><br><span class="line"><span class="built_in">array </span>after function call [6 5 4]</span><br></pre></td></tr></table></figure>

<h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>类似于数组，切片可以有多个维度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     pls := [][]<span class="type">string</span> &#123;</span><br><span class="line">            &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;C++&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;JavaScript&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>&#125;,</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> _, v1 := <span class="keyword">range</span> pls &#123;</span><br><span class="line">        <span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;%s &quot;</span>, v2)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出为，</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">CopyC C</span><span class="literal">++</span>  </span><br><span class="line"><span class="comment">JavaScript</span>  </span><br><span class="line"><span class="comment">Go Rust</span></span><br></pre></td></tr></table></figure>

<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>切片持有对底层数组的引用。只要切片在内存中，数组就不能被垃圾回收。在内存管理方面，这是需要注意的。让我们假设我们有一个非常大的数组，我们只想处理它的一小部分。然后，我们由这个数组创建一个切片，并开始处理切片。这里需要重点注意的是，在切片引用时数组仍然存在内存中。</p>
<p>一种解决方法是使用 [copy] 函数 <code>func copy(dst，src[]T)int</code> 来生成一个切片的副本。这样我们可以使用新的切片，原始数组可以被垃圾回收。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countries</span><span class="params">()</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    countries := []<span class="type">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;Singapore&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Australia&quot;</span>&#125;</span><br><span class="line">    neededCountries := countries[:<span class="built_in">len</span>(countries)<span class="number">-2</span>]</span><br><span class="line">    countriesCpy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(neededCountries))</span><br><span class="line">    <span class="built_in">copy</span>(countriesCpy, neededCountries) <span class="comment">//copies neededCountries to countriesCpy</span></span><br><span class="line">    <span class="keyword">return</span> countriesCpy</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    countriesNeeded := countries()</span><br><span class="line">    fmt.Println(countriesNeeded)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 9 行，<code>neededCountries := countries[:len(countries)-2</code> 创建一个去掉尾部 2 个元素的切片 <code>countries</code>，在上述程序的 11 行，将 <code>neededCountries</code> 复制到 <code>countriesCpy</code> 同时在函数的下一行返回 countriesCpy。现在 <code>countries</code> 数组可以被垃圾回收, 因为 <code>neededCountries</code> 不再被引用。</p>
<h1 id="12-可变参数函数"><a href="#12-可变参数函数" class="headerlink" title="12. 可变参数函数"></a>12. 可变参数函数</h1><h2 id="什么是可变参数函数"><a href="#什么是可变参数函数" class="headerlink" title="什么是可变参数函数"></a>什么是可变参数函数</h2><p>可变参数函数是一种参数个数可变的函数。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>如果函数最后一个参数被记作 <code>...T</code> ，这时函数可以接受任意个 <code>T</code> 类型参数作为最后一个参数。</p>
<p>请注意只有函数的最后一个参数才允许是可变的。</p>
<h2 id="通过一些例子理解可变参数函数如何工作"><a href="#通过一些例子理解可变参数函数如何工作" class="headerlink" title="通过一些例子理解可变参数函数如何工作"></a>通过一些例子理解可变参数函数如何工作</h2><p>你是否曾经想过 append 函数是如何将任意个参数值加入到切片中的。这样 append 函数可以接受不同数量的参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc <span class="built_in">append</span>(slice []Type, elems ...Type) []Type</span><br></pre></td></tr></table></figure>

<p>上面是 append 函数的定义。在定义中 elems 是可变参数。这样 append 函数可以接受可变化的参数。</p>
<p>让我们创建一个我们自己的可变参数函数。我们将写一段简单的程序，在输入的整数列表里查找某个整数是否存在。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of nums is %T\n&quot;</span>, nums)</span><br><span class="line">    found := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v == num &#123;</span><br><span class="line">            fmt.Println(num, <span class="string">&quot;found at index&quot;</span>, i, <span class="string">&quot;in&quot;</span>, nums)</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !found &#123;</span><br><span class="line">        fmt.Println(num, <span class="string">&quot;not found in &quot;</span>, nums)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    find(<span class="number">89</span>, <span class="number">89</span>, <span class="number">90</span>, <span class="number">95</span>)</span><br><span class="line">    find(<span class="number">45</span>, <span class="number">56</span>, <span class="number">67</span>, <span class="number">45</span>, <span class="number">90</span>, <span class="number">109</span>)</span><br><span class="line">    find(<span class="number">78</span>, <span class="number">38</span>, <span class="number">56</span>, <span class="number">98</span>)</span><br><span class="line">    find(<span class="number">87</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中 <code>func find(num int, nums ...int)</code> 中的 <code>nums</code> 可接受任意数量的参数。在 find 函数中，参数 <code>nums</code> 相当于一个整型切片。</p>
<p><strong>可变参数函数的工作原理是把可变参数转换为一个新的切片。以上面程序中的第 22 行为例，find 函数中的可变参数是 89，90，95 。 find 函数接受一个 int 类型的可变参数。因此这三个参数被编译器转换为一个 int 类型切片 int []int{89, 90, 95} 然后被传入 find函数。</strong></p>
<p>在第 10 行， <code>for</code> 循环遍历 <code>nums</code> 切片,如果 <code>num</code> 在切片中，则打印 <code>num</code> 的位置。如果 <code>num</code> 不在切片中,则打印提示未找到该数字。</p>
<p>上面代码的输出值如下,</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copytype <span class="keyword">of</span> nums <span class="keyword">is</span> []<span class="type">int</span></span><br><span class="line"><span class="number">89</span> <span class="built_in">found</span> at <span class="keyword">index</span> <span class="number">0</span> <span class="keyword">in</span> [<span class="number">89</span> <span class="number">90</span> <span class="number">95</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">of</span> nums <span class="keyword">is</span> []<span class="type">int</span></span><br><span class="line"><span class="number">45</span> <span class="built_in">found</span> at <span class="keyword">index</span> <span class="number">2</span> <span class="keyword">in</span> [<span class="number">56</span> <span class="number">67</span> <span class="number">45</span> <span class="number">90</span> <span class="number">109</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">of</span> nums <span class="keyword">is</span> []<span class="type">int</span></span><br><span class="line"><span class="number">78</span> <span class="keyword">not</span> <span class="built_in">found</span> <span class="keyword">in</span>  [<span class="number">38</span> <span class="number">56</span> <span class="number">98</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">of</span> nums <span class="keyword">is</span> []<span class="type">int</span></span><br><span class="line"><span class="number">87</span> <span class="keyword">not</span> <span class="built_in">found</span> <span class="keyword">in</span>  []</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 25 行，find 函数仅有一个参数。我们没有给可变参数 <code>nums ...int</code> 传入任何参数。这也是合法的，在这种情况下 <code>nums</code> 是一个长度和容量为 0 的 <code>nil</code> 切片。</p>
<h2 id="给可变参数函数传入切片"><a href="#给可变参数函数传入切片" class="headerlink" title="给可变参数函数传入切片"></a>给可变参数函数传入切片</h2><p>下面例子中，我们给可变参数函数传入一个切片，看看会发生什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of nums is %T\n&quot;</span>, nums)</span><br><span class="line">    found := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v == num &#123;</span><br><span class="line">            fmt.Println(num, <span class="string">&quot;found at index&quot;</span>, i, <span class="string">&quot;in&quot;</span>, nums)</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !found &#123;</span><br><span class="line">        fmt.Println(num, <span class="string">&quot;not found in &quot;</span>, nums)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">95</span>&#125;</span><br><span class="line">    find(<span class="number">89</span>, nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 23 行中，我们将一个切片传给一个可变参数函数。</p>
<p>这种情况下无法通过编译，编译器报出错误 <code>main.go:23: cannot use nums (type []int) as type int in argument to find</code> 。</p>
<p>为什么无法工作呢？原因很直接，<code>find</code> 函数的说明如下，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc find(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>由可变参数函数的定义可知，<code>nums ...int</code> 意味它可以接受 <code>int</code> 类型的可变参数。</p>
<p>在上面程序的第 23 行，<code>nums</code> 作为可变参数传入 <code>find</code> 函数。前面我们知道，这些可变参数参数会被转换为 <code>int</code> 类型切片然后在传入 <code>find</code> 函数中。但是在这里 <code>nums</code> 已经是一个 int 类型切片，编译器试图在 <code>nums</code> 基础上再创建一个切片，像下面这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyfind(<span class="number">89</span>, []<span class="type">int</span>&#123;nums&#125;)</span><br></pre></td></tr></table></figure>

<p>这里之所以会失败是因为 <code>nums</code> 是一个 <code>[]int</code>类型 而不是 <code>int</code>类型。</p>
<p>那么有没有办法给可变参数函数传入切片参数呢？答案是肯定的。</p>
<p><strong>有一个可以直接将切片传入可变参数函数的语法糖，你可以在在切片后加上 … 后缀。如果这样做，切片将直接传入函数，不再创建新的切片</strong></p>
<p>在上面的程序中，如果你将第 23 行的 <code>find(89, nums)</code> 替换为 <code>find(89, nums...)</code> ，程序将成功编译并有如下输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copytype of nums is []<span class="type">int</span></span><br><span class="line"><span class="number">89</span> found at index <span class="number">0</span> in [<span class="number">89</span> <span class="number">90</span> <span class="number">95</span>]</span><br></pre></td></tr></table></figure>

<p>下面是完整的程序供您参考。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">find</span><span class="params">(num <span class="type">int</span>, nums ...<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;type of nums is %T\n&quot;</span>, nums)</span><br><span class="line">    found := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v == num &#123;</span><br><span class="line">            fmt.Println(num, <span class="string">&quot;found at index&quot;</span>, i, <span class="string">&quot;in&quot;</span>, nums)</span><br><span class="line">            found = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !found &#123;</span><br><span class="line">        fmt.Println(num, <span class="string">&quot;not found in &quot;</span>, nums)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">95</span>&#125;</span><br><span class="line">    find(<span class="number">89</span>, nums...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不直观的错误"><a href="#不直观的错误" class="headerlink" title="不直观的错误"></a>不直观的错误</h2><p>当你修改可变参数函数中的切片时，请确保你知道你正在做什么。</p>
<p>下面让我们来看一个简单的例子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(s ...<span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&quot;Go&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    welcome := []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">    change(welcome...)</span><br><span class="line">    fmt.Println(welcome)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你认为这段代码将输出什么呢？如果你认为它输出 <code>[Go world]</code> 。恭喜你！你已经理解了可变参数函数和切片。如果你猜错了，那也不要紧，让我来解释下为什么会有这样的输出。</p>
<p>在第 13 行，我们使用了语法糖 <code>...</code> 并且将切片作为可变参数传入 <code>change</code> 函数。</p>
<p>正如前面我们所讨论的，如果使用了 <code>...</code> ，<code>welcome</code> 切片本身会作为参数直接传入，不需要再创建一个新的切片。这样参数 <code>welcome</code> 将作为参数传入 <code>change</code> 函数</p>
<p>在 <code>change</code> 函数中，切片的第一个元素被替换成 <code>Go</code>，这样程序产生了下面的输出值</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="selector-attr">[Go world]</span></span><br></pre></td></tr></table></figure>

<p>这里还有一个例子来理解可变参数函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(s ...<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&quot;Go&quot;</span></span><br><span class="line">    s = <span class="built_in">append</span>(s, <span class="string">&quot;playground&quot;</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    welcome := []<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;</span><br><span class="line">    change(welcome...)</span><br><span class="line">    fmt.Println(welcome)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-字符串"><a href="#14-字符串" class="headerlink" title="14. 字符串"></a>14. 字符串</h1><h2 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a>什么是字符串？</h2><p>Go 语言中的字符串是一个字节切片。把内容放在双引号””之间，我们可以创建一个字符串。让我们来看一个创建并打印字符串的简单示例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序将会输出 <code>Hello World</code>。</p>
<p>Go 中的字符串是兼容 Unicode 编码的，并且使用 UTF-8 进行编码。</p>
<h2 id="单独获取字符串的每一个字节"><a href="#单独获取字符串的每一个字节" class="headerlink" title="单独获取字符串的每一个字节"></a>单独获取字符串的每一个字节</h2><p>由于字符串是一个字节切片，所以我们可以获取字符串的每一个字节。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x &quot;</span>, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    printBytes(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的第 8 行，<strong>len(s) 返回字符串中字节的数量</strong>，然后我们用了一个 for 循环以 16 进制的形式打印这些字节。<code>%x</code> 格式限定符用于指定 16 进制编码。上面的程序输出 <code>48 65 6c 6c 6f 20 57 6f 72 6c 64</code>。这些打印出来的字符是 “Hello World” 以 [Unicode UTF-8 编码]的结果。为了更好的理解 go 中的字符串，需要对 Unicode 和 UTF-8 有基础的理解。我推荐阅读一下 <a target="_blank" rel="noopener" href="https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/">https://naveenr.net/unicode-character-set-and-utf-8-utf-16-utf-32-encoding/</a> 来理解一下什么是 Unicode 和 UTF-8。</p>
<p>让我们稍微修改一下上面的程序，让它打印字符串的每一个字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x &quot;</span>, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printChars</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c &quot;</span>,s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    printBytes(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    printChars(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>printChars</code> 方法(第 16 行中)中，<code>%c</code> 格式限定符用于打印字符串的字符。这个程序输出结果是：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">20</span> <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span>  </span><br><span class="line"><span class="attribute">H</span> e l l o   W o r l d</span><br></pre></td></tr></table></figure>

<p>上面的程序获取字符串的每一个字符，虽然看起来是合法的，但却有一个严重的 bug。让我拆解这个代码来看看我们做错了什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x &quot;</span>, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printChars</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c &quot;</span>,s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    printBytes(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    printChars(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    name = <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printBytes(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    printChars(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码输出的结果是：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">20</span> <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span>  </span><br><span class="line"><span class="attribute">H</span> e l l o   W o r l d  </span><br><span class="line"><span class="attribute">53</span> <span class="number">65</span> c3 b1 <span class="number">6</span>f <span class="number">72</span>  </span><br><span class="line"><span class="attribute">S</span> e Ã ± o r</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 28 行，我们尝试输出 <strong>Señor</strong> 的字符，但却输出了错误的 <strong>S e Ã ± o r</strong>。 为什么程序分割 <code>Hello World</code> 时表现完美，但分割 <code>Señor</code> 就出现了错误呢？这是因为 <code>ñ</code> 的 Unicode 代码点（Code Point）是 <code>U+00F1</code>。它的 [UTF-8 编码]占用了 c3 和 b1 两个字节。它的 UTF-8 编码占用了两个字节 c3 和 b1。而我们打印字符时，却假定每个字符的编码只会占用一个字节，这是错误的。在 UTF-8 编码中，一个代码点可能会占用超过一个字节的空间。那么我们该怎么办呢？rune 能帮我们解决这个难题。</p>
<h2 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h2><p>rune 是 Go 语言的内建类型，它也是 int32 的别称。在 Go 语言中，rune 表示一个代码点。代码点无论占用多少个字节，都可以用一个 rune 来表示。让我们修改一下上面的程序，用 rune 来打印字符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x &quot;</span>, s[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printChars</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    runes := []<span class="type">rune</span>(s)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(runes); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c &quot;</span>,runes[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    printBytes(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    printChars(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n\n&quot;</span>)</span><br><span class="line">    name = <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printBytes(name)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    printChars(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码的第 14 行，字符串被转化为一个 rune 切片。然后我们循环打印字符。程序的输出结果是</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy48</span> <span class="number">65</span> <span class="number">6</span>c <span class="number">6</span>c <span class="number">6</span>f <span class="number">20</span> <span class="number">57</span> <span class="number">6</span>f <span class="number">72</span> <span class="number">6</span>c <span class="number">64</span>  </span><br><span class="line"><span class="attribute">H</span> e l l o   W o r l d </span><br><span class="line"></span><br><span class="line"><span class="attribute">53</span> <span class="number">65</span> c3 b1 <span class="number">6</span>f <span class="number">72</span>  </span><br><span class="line"><span class="attribute">S</span> e ñ o r</span><br></pre></td></tr></table></figure>

<p>上面的输出结果非常完美，就是我们想要的结果:)。</p>
<h2 id="字符串的-for-range-循环"><a href="#字符串的-for-range-循环" class="headerlink" title="字符串的 for range 循环"></a>字符串的 for range 循环</h2><p>上面的程序是一种遍历字符串的好方法，但是 Go 给我们提供了一种更简单的方法来做到这一点：使用 <strong>for range</strong> 循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printCharsAndBytes</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> index, <span class="type">rune</span> := <span class="keyword">range</span> s &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%c starts at byte %d\n&quot;</span>, <span class="type">rune</span>, index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    name := <span class="string">&quot;Señor&quot;</span></span><br><span class="line">    printCharsAndBytes(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第8行，使用 <code>for range</code> 循环遍历了字符串。循环返回的是是当前 rune 的字节位置。程序的输出结果为：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyS starts <span class="keyword">at</span> <span class="keyword">byte</span> <span class="number">0</span>  </span><br><span class="line">e starts <span class="keyword">at</span> <span class="keyword">byte</span> <span class="number">1</span>  </span><br><span class="line">ñ starts <span class="keyword">at</span> <span class="keyword">byte</span> <span class="number">2</span></span><br><span class="line">o starts <span class="keyword">at</span> <span class="keyword">byte</span> <span class="number">4</span>  </span><br><span class="line">r starts <span class="keyword">at</span> <span class="keyword">byte</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>从上面的输出中可以清晰的看到 <code>ñ</code> 占了两个字节:)。</p>
<h2 id="用字节切片构造字符串"><a href="#用字节切片构造字符串" class="headerlink" title="用字节切片构造字符串"></a>用字节切片构造字符串</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    byteSlice := []<span class="type">byte</span>&#123;<span class="number">0x43</span>, <span class="number">0x61</span>, <span class="number">0x66</span>, <span class="number">0xC3</span>, <span class="number">0xA9</span>&#125;</span><br><span class="line">    str := <span class="type">string</span>(byteSlice)</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中 <code>byteSlice</code> 包含字符串 <code>Café</code> 用 UTF-8 编码后的 16 进制字节。程序输出结果是 <code>Café</code>。</p>
<p>如果我们把 16 进制换成对应的 10 进制值会怎么样呢？上面的程序还能工作吗？让我们来试一试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    byteSlice := []<span class="type">byte</span>&#123;<span class="number">67</span>, <span class="number">97</span>, <span class="number">102</span>, <span class="number">195</span>, <span class="number">169</span>&#125;<span class="comment">//decimal equivalent of &#123;&#x27;\x43&#x27;, &#x27;\x61&#x27;, &#x27;\x66&#x27;, &#x27;\xC3&#x27;, &#x27;\xA9&#x27;&#125;</span></span><br><span class="line">    str := <span class="type">string</span>(byteSlice)</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的输出结果也是<code>Café</code></p>
<h2 id="用-rune-切片构造字符串"><a href="#用-rune-切片构造字符串" class="headerlink" title="用 rune 切片构造字符串"></a>用 rune 切片构造字符串</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    runeSlice := []<span class="type">rune</span>&#123;<span class="number">0x0053</span>, <span class="number">0x0065</span>, <span class="number">0x00f1</span>, <span class="number">0x006f</span>, <span class="number">0x0072</span>&#125;</span><br><span class="line">    str := <span class="type">string</span>(runeSlice)</span><br><span class="line">    fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中 <code>runeSlice</code> 包含字符串 <code>Señor</code>的 16 进制的 Unicode 代码点。这个程序将会输出<code>Señor</code>。</p>
<h2 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h2><p>[utf8 package] 包中的 <code>func RuneCountInString(s string) (n int)</code> 方法用来获取字符串的长度。这个方法传入一个字符串参数然后返回字符串中的 rune 的数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">length</span><span class="params">(s <span class="type">string</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;length of %s is %d\n&quot;</span>, s, utf8.RuneCountInString(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    word1 := <span class="string">&quot;Señor&quot;</span> </span><br><span class="line">    length(word1)</span><br><span class="line">    word2 := <span class="string">&quot;Pets&quot;</span></span><br><span class="line">    length(word2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的输出结果是：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copylength <span class="keyword">of</span> Señ<span class="keyword">or</span> <span class="keyword">is</span> <span class="number">5</span>  </span><br><span class="line"><span class="built_in">length</span> <span class="keyword">of</span> Pets <span class="keyword">is</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a>字符串是不可变的</h2><p>Go 中的字符串是不可变的。一旦一个字符串被创建，那么它将无法被修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutate</span><span class="params">(s <span class="type">string</span>)</span></span><span class="type">string</span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span><span class="comment">//any valid unicode character within single quote is a rune </span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(mutate(h))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 8 行，我们试图把这个字符串中的第一个字符修改为 ‘a’。由于字符串是不可变的，因此这个操作是非法的。所以程序抛出了一个错误 **main.go:8: cannot assign to s[0]**。</p>
<p>为了修改字符串，可以把字符串转化为一个 rune 切片。然后这个切片可以进行任何想要的改变，然后再转化为一个字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mutate</span><span class="params">(s []<span class="type">rune</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    h := <span class="string">&quot;hello&quot;</span></span><br><span class="line">    fmt.Println(mutate([]<span class="type">rune</span>(h)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 7 行，<code>mutate</code> 函数接收一个 rune 切片参数，它将切片的第一个元素修改为 <code>&#39;a&#39;</code>，然后将 rune 切片转化为字符串，并返回该字符串。程序的第 13 行调用了该函数。我们把 <code>h</code> 转化为一个 rune 切片，并传递给了 <code>mutate</code>。这个程序输出 <code>aello</code>。</p>
<h1 id="15-指针"><a href="#15-指针" class="headerlink" title="15. 指针"></a>15. 指针</h1><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针是一种存储变量内存地址（Memory Address）的变量。</p>
<p><a target="_blank" rel="noopener" href="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232851087-863913389.png"><img src="https://img2018.cnblogs.com/blog/1825659/201910/1825659-20191023232851087-863913389.png" alt="img"></a></p>
<p>如上图所示，变量 <code>b</code> 的值为 <code>156</code>，而 <code>b</code> 的内存地址为 <code>0x1040a124</code>。变量 <code>a</code> 存储了 <code>b</code> 的地址。我们就称 <code>a</code> 指向了 <code>b</code>。</p>
<h3 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h3><p>指针变量的类型为 *<strong>T</strong>，该指针指向一个 <strong>T</strong> 类型的变量。</p>
<p>接下来我们写点代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    <span class="keyword">var</span> a *<span class="type">int</span> = &amp;b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type of a is %T\n&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>&amp;</strong> 操作符用于获取变量的地址。上面程序的第 9 行我们把 <code>b</code> 的地址赋值给 *<strong>int</strong> 类型的 <code>a</code>。我们称 <code>a</code> 指向了 <code>b</code>。当我们打印 <code>a</code> 的值时，会打印出 <code>b</code> 的地址。程序将输出：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyType of a <span class="keyword">is</span> *<span class="built_in">int</span>  </span><br><span class="line">address of b <span class="keyword">is</span> <span class="number">0x1040a124</span></span><br></pre></td></tr></table></figure>

<p>由于 b 可能处于内存的任何位置，你应该会得到一个不同的地址。</p>
<h3 id="指针的零值（Zero-Value）"><a href="#指针的零值（Zero-Value）" class="headerlink" title="指针的零值（Zero Value）"></a>指针的零值（Zero Value）</h3><p>指针的零值是 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">25</span></span><br><span class="line">    <span class="keyword">var</span> b *<span class="type">int</span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;b is&quot;</span>, b)</span><br><span class="line">        b = &amp;a</span><br><span class="line">        fmt.Println(<span class="string">&quot;b after initialization is&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序中，<code>b</code> 初始化为 <code>nil</code>，接着将 <code>a</code> 的地址赋值给 <code>b</code>。程序会输出：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyb <span class="keyword">is</span> &lt;nil&gt;  </span><br><span class="line">b <span class="keyword">after</span> initialisation <span class="keyword">is</span> <span class="number">0x1040a124</span></span><br></pre></td></tr></table></figure>

<h3 id="指针的解引用"><a href="#指针的解引用" class="headerlink" title="指针的解引用"></a>指针的解引用</h3><p>指针的解引用可以获取指针所指向的变量的值。将 <code>a</code> 解引用的语法是 <code>*a</code>。</p>
<p>通过下面的代码，可以看到如何使用解引用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 10 行，我们将 <code>a</code> 解引用，并打印了它的值。不出所料，我们会打印出 <code>b</code> 的值。程序会输出：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyaddress of b <span class="keyword">is</span> <span class="number">0x1040a124</span>  </span><br><span class="line">value of b <span class="keyword">is</span> <span class="number">255</span></span><br></pre></td></tr></table></figure>

<p>我们再编写一个程序，用指针来修改 b 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := <span class="number">255</span></span><br><span class="line">    a := &amp;b</span><br><span class="line">    fmt.Println(<span class="string">&quot;address of b is&quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of b is&quot;</span>, *a)</span><br><span class="line">    *a++</span><br><span class="line">    fmt.Println(<span class="string">&quot;new value of b is&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 12 行中，我们把 <code>a</code> 指向的值加 1，由于 <code>a</code> 指向了 <code>b</code>，因此 <code>b</code> 的值也发生了同样的改变。于是 <code>b</code> 的值变为 256。程序会输出：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyaddress of b <span class="keyword">is</span> <span class="number">0x1040a124</span>  </span><br><span class="line">value of b <span class="keyword">is</span> <span class="number">255</span>  </span><br><span class="line"><span class="keyword">new</span> value of b <span class="keyword">is</span> <span class="number">256</span></span><br></pre></td></tr></table></figure>

<h3 id="向函数传递指针参数"><a href="#向函数传递指针参数" class="headerlink" title="向函数传递指针参数"></a>向函数传递指针参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(val *<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    *val = <span class="number">55</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">58</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before function call is&quot;</span>,a)</span><br><span class="line">    b := &amp;a</span><br><span class="line">    change(b)</span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a after function call is&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 14 行，我们向函数 <code>change</code> 传递了指针变量 <code>b</code>，而 <code>b</code> 存储了 <code>a</code> 的地址。程序的第 8 行在 <code>change</code> 函数内使用解引用，修改了 a 的值。该程序会输出：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyvalue <span class="keyword">of</span> a before <span class="keyword">function</span> <span class="title">call</span> <span class="keyword">is</span> <span class="number">58</span>  </span><br><span class="line">value <span class="keyword">of</span> a after <span class="keyword">function</span> <span class="title">call</span> <span class="keyword">is</span> <span class="number">55</span></span><br></pre></td></tr></table></figure>

<h3 id="不要向函数传递数组的指针，而应该使用切片"><a href="#不要向函数传递数组的指针，而应该使用切片" class="headerlink" title="不要向函数传递数组的指针，而应该使用切片"></a>不要向函数传递数组的指针，而应该使用切片</h3><p>假如我们想要在函数内修改一个数组，并希望调用函数的地方也能得到修改后的数组，一种解决方案是把一个指向数组的指针传递给这个函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 13 行中，我们将数组的地址传递给了 <code>modify</code> 函数。在第 8 行，我们在 <code>modify</code> 函数里把 <code>arr</code> 解引用，并将 <code>90</code> 赋值给这个数组的第一个元素。程序会输出 <code>[90 90 91]</code>。</p>
<p>**a[x] 是 (*a)[x] 的简写形式，因此上面代码中的 (*arr)[0] 可以替换为 arr[0]**。下面我们用简写形式重写以上代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(&amp;a)</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序也会输出 <code>[90 90 91]</code>。</p>
<p><strong>这种方式向函数传递一个数组指针参数，并在函数内修改数组。尽管它是有效的，但却不是 Go 语言惯用的实现方式。我们最好使用切片来处理。</strong></p>
<p>接下来我们用[切片]来重写之前的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(sls []<span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">    sls[<span class="number">0</span>] = <span class="number">90</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">89</span>, <span class="number">90</span>, <span class="number">91</span>&#125;</span><br><span class="line">    modify(a[:])</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 13 行，我们将一个切片传递给了 <code>modify</code> 函数。在 <code>modify</code> 函数中，我们把切片的第一个元素修改为 <code>90</code>。程序也会输出 <code>[90 90 91]</code>。<strong>所以别再传递数组指针了，而是使用切片吧</strong>。上面的代码更加简洁，也更符合 Go 语言的习惯。</p>
<h3 id="Go-不支持指针运算"><a href="#Go-不支持指针运算" class="headerlink" title="Go 不支持指针运算"></a>Go 不支持指针运算</h3><p>Go 并不支持其他语言（例如 C）中的指针运算。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    b := [...]<span class="type">int</span>&#123;<span class="number">109</span>, <span class="number">110</span>, <span class="number">111</span>&#125;</span><br><span class="line">    p := &amp;b</span><br><span class="line">    p++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的程序会抛出编译错误：**main.go:6: invalid operation: p++ (non-numeric type *[3]int)**。16. 结构体</p>
<h2 id="16-结构体"><a href="#16-结构体" class="headerlink" title="16.结构体"></a>16.结构体</h2><h3 id="什么是结构体？"><a href="#什么是结构体？" class="headerlink" title="什么是结构体？"></a>什么是结构体？</h3><p>结构体是用户定义的类型，表示若干个字段（Field）的集合。有时应该把数据整合在一起，而不是让这些数据没有联系。这种情况下可以使用结构体。</p>
<p>例如，一个职员有 <code>firstName</code>、<code>lastName</code> 和 <code>age</code> 三个属性，而把这些属性组合在一个结构体 <code>employee</code> 中就很合理。</p>
<h3 id="结构体的声明"><a href="#结构体的声明" class="headerlink" title="结构体的声明"></a>结构体的声明</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copytype Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName  <span class="type">string</span></span><br><span class="line">    age       <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码片段里，声明了一个结构体类型 <code>Employee</code>，它有 <code>firstName</code>、<code>lastName</code> 和 <code>age</code> 三个字段。通过把相同类型的字段声明在同一行，结构体可以变得更加紧凑。在上面的结构体中，<code>firstName</code> 和 <code>lastName</code> 属于相同的 <code>string</code> 类型，于是这个结构体可以重写为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copytype Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的结构体 <code>Employee</code> 称为 <strong>命名的结构体（Named Structure）</strong>。我们创建了名为 <code>Employee</code> 的新类型，而它可以用于创建 <code>Employee</code> 类型的结构体变量。</p>
<p>声明结构体时也可以不用声明一个新类型，这样的结构体类型称为 <strong>匿名结构体（Anonymous Structure）</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyvar employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码片段创建一个<strong>匿名结构体</strong> <code>employee</code>。</p>
<h3 id="创建命名的结构体"><a href="#创建命名的结构体" class="headerlink" title="创建命名的结构体"></a>创建命名的结构体</h3><p>通过下面代码，我们定义了一个<strong>命名的结构体 Employee</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//creating structure using field names</span></span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        firstName: <span class="string">&quot;Sam&quot;</span>,</span><br><span class="line">        age:       <span class="number">25</span>,</span><br><span class="line">        salary:    <span class="number">500</span>,</span><br><span class="line">        lastName:  <span class="string">&quot;Anderson&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//creating structure without using field names</span></span><br><span class="line">    emp2 := Employee&#123;<span class="string">&quot;Thomas&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="number">29</span>, <span class="number">800</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Employee 1&quot;</span>, emp1)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Employee 2&quot;</span>, emp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 7 行，我们创建了一个命名的结构体 <code>Employee</code>。而在第 15 行，通过指定每个字段名的值，我们定义了结构体变量 <code>emp1</code>。字段名的顺序不一定要与声明结构体类型时的顺序相同。在这里，我们改变了 <code>lastName</code> 的位置，将其移到了末尾。这样做也不会有任何的问题。</p>
<p>在上面程序的第 23 行，定义 <code>emp2</code> 时我们省略了字段名。在这种情况下，就需要保证字段名的顺序与声明结构体时的顺序相同。</p>
<p>该程序将输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyEmployee</span> <span class="number">1</span> &#123;Sam Anderson <span class="number">25</span> <span class="number">500</span>&#125;</span><br><span class="line"><span class="attribute">Employee</span> <span class="number">2</span> &#123;Thomas Paul <span class="number">29</span> <span class="number">800</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建匿名结构体"><a href="#创建匿名结构体" class="headerlink" title="创建匿名结构体"></a>创建匿名结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    emp3 := <span class="keyword">struct</span> &#123;</span><br><span class="line">        firstName, lastName <span class="type">string</span></span><br><span class="line">        age, salary         <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        firstName: <span class="string">&quot;Andreah&quot;</span>,</span><br><span class="line">        lastName:  <span class="string">&quot;Nikola&quot;</span>,</span><br><span class="line">        age:       <span class="number">31</span>,</span><br><span class="line">        salary:    <span class="number">5000</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Employee 3&quot;</span>, emp3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 3 行，我们定义了一个<strong>匿名结构体变量</strong> <code>emp3</code>。上面我们已经提到，之所以称这种结构体是匿名的，是因为它只是创建一个新的结构体变量 <code>em3</code>，而没有定义任何结构体类型。</p>
<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyEmployee</span> <span class="number">3</span> &#123;Andreah Nikola <span class="number">31</span> <span class="number">5000</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体的零值（Zero-Value）"><a href="#结构体的零值（Zero-Value）" class="headerlink" title="结构体的零值（Zero Value）"></a>结构体的零值（Zero Value）</h3><p>当定义好的结构体并没有被显式地初始化时，该结构体的字段将默认赋为零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> emp4 Employee <span class="comment">//zero valued structure</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Employee 4&quot;</span>, emp4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序定义了 <code>emp4</code>，却没有初始化任何值。因此 <code>firstName</code> 和 <code>lastName</code> 赋值为 string 的零值（<code>&quot;&quot;</code>）。而 <code>age</code> 和 <code>salary</code> 赋值为 int 的零值（0）。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyEmployee</span> <span class="number">4</span> &#123; <span class="number">0</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>当然还可以为某些字段指定初始值，而忽略其他字段。这样，忽略的字段名会赋值为零值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp5 := Employee&#123;</span><br><span class="line">        firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">        lastName:  <span class="string">&quot;Paul&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Employee 5&quot;</span>, emp5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 14 行和第 15 行，我们初始化了 <code>firstName</code> 和 <code>lastName</code>，而 <code>age</code> 和 <code>salary</code> 没有进行初始化。因此 <code>age</code> 和 <code>salary</code> 赋值为零值。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyEmployee</span> <span class="number">5</span> &#123;John Paul <span class="number">0</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问结构体的字段"><a href="#访问结构体的字段" class="headerlink" title="访问结构体的字段"></a>访问结构体的字段</h3><p>点号操作符 <code>.</code> 用于访问结构体的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp6 := Employee&#123;<span class="string">&quot;Sam&quot;</span>, <span class="string">&quot;Anderson&quot;</span>, <span class="number">55</span>, <span class="number">6000</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;First Name:&quot;</span>, emp6.firstName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Last Name:&quot;</span>, emp6.lastName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, emp6.age)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary: $%d&quot;</span>, emp6.salary)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序中的 <strong>emp6.firstName</strong> 访问了结构体 <code>emp6</code> 的字段 <code>firstName</code>。该程序输出：</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyFirst Name</span><span class="punctuation">:</span> <span class="string">Sam  </span></span><br><span class="line"><span class="attribute">Last Name</span><span class="punctuation">:</span> <span class="string">Anderson  </span></span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">:</span> <span class="string">55  </span></span><br><span class="line"><span class="attribute">Salary</span><span class="punctuation">:</span> <span class="string">$6000</span></span><br></pre></td></tr></table></figure>

<p>还可以创建零值的 <code>struct</code>，以后再给各个字段赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> emp7 Employee</span><br><span class="line">    emp7.firstName = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    emp7.lastName = <span class="string">&quot;Adams&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Employee 7:&quot;</span>, emp7)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，我们定义了 <code>emp7</code>，接着给 <code>firstName</code> 和 <code>lastName</code> 赋值。该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyEmployee</span> <span class="number">7</span>: &#123;Jack Adams <span class="number">0</span> <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体的指针"><a href="#结构体的指针" class="headerlink" title="结构体的指针"></a>结构体的指针</h3><p>还可以创建指向结构体的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp8 := &amp;Employee&#123;<span class="string">&quot;Sam&quot;</span>, <span class="string">&quot;Anderson&quot;</span>, <span class="number">55</span>, <span class="number">6000</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;First Name:&quot;</span>, (*emp8).firstName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, (*emp8).age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，<strong>emp8</strong> 是一个指向结构体 <code>Employee</code> 的指针。<code>(*emp8).firstName</code> 表示访问结构体 <code>emp8</code> 的 <code>firstName</code> 字段。该程序会输出：</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyFirst Name</span><span class="punctuation">:</span> <span class="string">Sam</span></span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">:</span> <span class="string">55</span></span><br></pre></td></tr></table></figure>

<p><strong>Go 语言允许我们在访问 firstName 字段时，可以使用 emp8.firstName 来代替显式的解引用 (*emp8).firstName</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName, lastName <span class="type">string</span></span><br><span class="line">    age, salary         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    emp8 := &amp;Employee&#123;<span class="string">&quot;Sam&quot;</span>, <span class="string">&quot;Anderson&quot;</span>, <span class="number">55</span>, <span class="number">6000</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;First Name:&quot;</span>, emp8.firstName)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, emp8.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，我们使用 <code>emp8.firstName</code> 来访问 <code>firstName</code> 字段，该程序会输出：</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyFirst Name</span><span class="punctuation">:</span> <span class="string">Sam</span></span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">:</span> <span class="string">55</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h3><p>当我们创建结构体时，字段可以只有类型，而没有字段名。这样的字段称为匿名字段（Anonymous Field）。</p>
<p>以下代码创建一个 <code>Person</code> 结构体，它含有两个匿名字段 <code>string</code> 和 <code>int</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copytype Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们接下来使用匿名字段来编写一个程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    p := Person&#123;<span class="string">&quot;Naveen&quot;</span>, <span class="number">50</span>&#125;</span><br><span class="line">    fmt.Println(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，结构体 <code>Person</code> 有两个匿名字段。<code>p := Person&#123;&quot;Naveen&quot;, 50&#125;</code> 定义了一个 <code>Person</code> 类型的变量。该程序输出 <code>&#123;Naveen 50&#125;</code>。</p>
<p><strong>虽然匿名字段没有名称，但其实匿名字段的名称就默认为它的类型</strong>。比如在上面的 <code>Person</code> 结构体里，虽说字段是匿名的，但 Go 默认这些字段名是它们各自的类型。所以 <code>Person</code> 结构体有两个名为 <code>string</code> 和 <code>int</code> 的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    <span class="type">string</span></span><br><span class="line">    <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p1 Person</span><br><span class="line">    p1.<span class="type">string</span> = <span class="string">&quot;naveen&quot;</span></span><br><span class="line">    p1.<span class="type">int</span> = <span class="number">50</span></span><br><span class="line">    fmt.Println(p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 14 行和第 15 行，我们访问了 <code>Person</code> 结构体的匿名字段，我们把字段类型作为字段名，分别为 “string” 和 “int”。上面程序的输出如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy</span>&#123;naveen <span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套结构体（Nested-Structs）"><a href="#嵌套结构体（Nested-Structs）" class="headerlink" title="嵌套结构体（Nested Structs）"></a>嵌套结构体（Nested Structs）</h3><p>结构体的字段有可能也是一个结构体。这样的结构体称为嵌套结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age <span class="type">int</span></span><br><span class="line">    address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.address = Address &#123;</span><br><span class="line">        city: <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">        state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>,p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>,p.address.city)</span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>,p.address.state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的结构体 <code>Person</code> 有一个字段 <code>address</code>，而 <code>address</code> 也是结构体。该程序输出：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CopyName:</span> Naveen  </span><br><span class="line"><span class="symbol">Age:</span> <span class="number">50</span>  </span><br><span class="line"><span class="symbol">City:</span> Chicago  </span><br><span class="line"><span class="symbol">State:</span> Illinois</span><br></pre></td></tr></table></figure>

<h3 id="提升字段（Promoted-Fields）"><a href="#提升字段（Promoted-Fields）" class="headerlink" title="提升字段（Promoted Fields）"></a>提升字段（Promoted Fields）</h3><p>如果是结构体中有匿名的结构体类型字段，则该匿名结构体里的字段就称为提升字段。这是因为提升字段就像是属于外部结构体一样，可以用外部结构体直接访问。我知道这种定义很复杂，所以我们直接研究下代码来理解吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copytype Address <span class="keyword">struct</span> &#123;  </span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">    Address</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码片段中，<code>Person</code> 结构体有一个匿名字段 <code>Address</code>，而 <code>Address</code> 是一个结构体。现在结构体 <code>Address</code> 有 <code>city</code> 和 <code>state</code> 两个字段，访问这两个字段就像在 <code>Person</code> 里直接声明的一样，因此我们称之为提升字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    city, state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">    Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    p.name = <span class="string">&quot;Naveen&quot;</span></span><br><span class="line">    p.age = <span class="number">50</span></span><br><span class="line">    p.Address = Address&#123;</span><br><span class="line">        city:  <span class="string">&quot;Chicago&quot;</span>,</span><br><span class="line">        state: <span class="string">&quot;Illinois&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Name:&quot;</span>, p.name)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Age:&quot;</span>, p.age)</span><br><span class="line">    fmt.Println(<span class="string">&quot;City:&quot;</span>, p.city) <span class="comment">//city is promoted field</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;State:&quot;</span>, p.state) <span class="comment">//state is promoted field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中的第 26 行和第 27 行，我们使用了语法 <code>p.city</code> 和 <code>p.state</code>，访问提升字段 <code>city</code> 和 <code>state</code> 就像它们是在结构体 <code>p</code> 中声明的一样。该程序会输出：</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CopyName:</span> Naveen  </span><br><span class="line"><span class="symbol">Age:</span> <span class="number">50</span>  </span><br><span class="line"><span class="symbol">City:</span> Chicago  </span><br><span class="line"><span class="symbol">State:</span> Illinois</span><br></pre></td></tr></table></figure>

<h3 id="导出结构体和字段"><a href="#导出结构体和字段" class="headerlink" title="导出结构体和字段"></a>导出结构体和字段</h3><p>如果结构体名称以大写字母开头，则它是其他包可以访问的导出类型（Exported Type）。同样，如果结构体里的字段首字母大写，它也能被其他包访问到。</p>
<p>让我们使用自定义包，编写一个程序来更好地去理解它。</p>
<p>在你的 Go 工作区的 <code>src</code> 目录中，创建一个名为 <code>structs</code> 的文件夹。另外在 <code>structs</code> 中再创建一个目录 <code>computer</code>。</p>
<p>在 <code>computer</code> 目录中，在名为 <code>spec.go</code> 的文件中保存下面的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copypackage computer</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Spec <span class="keyword">struct</span> &#123; <span class="comment">//exported struct  </span></span><br><span class="line">    Maker <span class="type">string</span> <span class="comment">//exported field</span></span><br><span class="line">    model <span class="type">string</span> <span class="comment">//unexported field</span></span><br><span class="line">    Price <span class="type">int</span> <span class="comment">//exported field</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码片段中，创建了一个 <code>computer</code> 包，里面有一个导出结构体类型 <code>Spec</code>。<code>Spec</code> 有两个导出字段 <code>Maker</code> 和 <code>Price</code>，和一个未导出的字段 <code>model</code>。接下来我们会在 main 包中导入这个包，并使用 <code>Spec</code> 结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;structs/computer&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> spec computer.Spec</span><br><span class="line">    spec.Maker = <span class="string">&quot;apple&quot;</span></span><br><span class="line">    spec.Price = <span class="number">50000</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Spec:&quot;</span>, spec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Copysrc  </span><br><span class="line">   structs</span><br><span class="line">        computer</span><br><span class="line">            spec.<span class="keyword">go</span></span><br><span class="line">        main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>在上述程序的第 3 行，我们导入了 <code>computer</code> 包。在第 8 行和第 9 行，我们访问了结构体 <code>Spec</code> 的两个导出字段 <code>Maker</code> 和 <code>Price</code>。执行命令 <code>go install structs</code> 和 <code>workspacepath/bin/structs</code>，运行该程序。</p>
<p>如果我们试图访问未导出的字段 <code>model</code>，编译器会报错。将 <code>main.go</code> 的内容替换为下面的代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;structs/computer&quot;</span>  </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> spec computer.Spec</span><br><span class="line">    spec.Maker = <span class="string">&quot;apple&quot;</span></span><br><span class="line">    spec.Price = <span class="number">50000</span></span><br><span class="line">    spec.model = <span class="string">&quot;Mac Mini&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Spec:&quot;</span>, spec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 10 行，我们试图访问未导出的字段 <code>model</code>。如果运行这个程序，编译器会产生错误：**spec.model undefined (cannot refer to unexported field or method model)**。</p>
<h3 id="结构体相等性（Structs-Equality）"><a href="#结构体相等性（Structs-Equality）" class="headerlink" title="结构体相等性（Structs Equality）"></a>结构体相等性（Structs Equality）</h3><p><strong>结构体是值类型。如果它的每一个字段都是可比较的，则该结构体也是可比较的。如果两个结构体变量的对应字段相等，则这两个变量也是相等的</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> name <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name1 := name&#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    name2 := name&#123;<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> name1 == name2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name1 and name2 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name1 and name2 are not equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name3 := name&#123;firstName:<span class="string">&quot;Steve&quot;</span>, lastName:<span class="string">&quot;Jobs&quot;</span>&#125;</span><br><span class="line">    name4 := name&#123;&#125;</span><br><span class="line">    name4.firstName = <span class="string">&quot;Steve&quot;</span></span><br><span class="line">    <span class="keyword">if</span> name3 == name4 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name3 and name4 are equal&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;name3 and name4 are not equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，结构体类型 <code>name</code> 包含两个 <code>string</code> 类型。由于字符串是可比较的，因此可以比较两个 <code>name</code> 类型的结构体变量。</p>
<p>上面代码中 <code>name1</code> 和 <code>name2</code> 相等，而 <code>name3</code> 和 <code>name4</code> 不相等。该程序会输出：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyname1<span class="built_in"> and </span>name2 are equal  </span><br><span class="line">name3<span class="built_in"> and </span>name4 are<span class="built_in"> not </span>equal</span><br></pre></td></tr></table></figure>

<p><strong>如果结构体包含不可比较的字段，则结构体变量也不可比较。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> image <span class="keyword">struct</span> &#123;  </span><br><span class="line">    data <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    image1 := image&#123;data: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">155</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    image2 := image&#123;data: <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">155</span>,</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    <span class="keyword">if</span> image1 == image2 &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;image1 and image2 are equal&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，结构体类型 <code>image</code> 包含一个 <code>map</code> 类型的字段。由于 <code>map</code> 类型是不可比较的，因此 <code>image1</code> 和 <code>image2</code> 也不可比较。如果运行该程序，编译器会报错：**main.go:18: invalid operation: image1 == image2 (struct containing map[int]int cannot be compared)**。17. 方法</p>
<h2 id="17-方法"><a href="#17-方法" class="headerlink" title="17.方法"></a>17.方法</h2><h3 id="什么是方法？"><a href="#什么是方法？" class="headerlink" title="什么是方法？"></a>什么是方法？</h3><p>方法其实就是一个函数，在 <code>func</code> 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的。</p>
<p>下面就是创建一个方法的语法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyfunc (t Type) methodName(parameter list) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码片段创建了一个接收器类型为 <code>Type</code> 的方法 <code>methodName</code>。</p>
<h3 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h3><p>让我们来编写一个简单的小程序，它会在结构体类型上创建一个方法并调用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    salary   <span class="type">int</span></span><br><span class="line">    currency <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  displaySalary() 方法将 Employee 做为接收器类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> displaySalary() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    emp1 := Employee &#123;</span><br><span class="line">        name:     <span class="string">&quot;Sam Adolf&quot;</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">&quot;$&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    emp1.displaySalary() <span class="comment">// 调用 Employee 类型的 displaySalary() 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 16 行，我们在 <code>Employee</code> 结构体类型上创建了一个 <code>displaySalary</code> 方法。displaySalary()方法在方法的内部访问了接收器 <code>e Employee</code>。在第 17 行，我们使用接收器 <code>e</code>，并打印 employee 的 name、currency 和 salary 这 3 个字段。</p>
<p>在第 26 行，我们调用了方法 <code>emp1.displaySalary()</code>。</p>
<p>程序输出：<code>Salary of Sam Adolf is $5000</code>。</p>
<h3 id="为什么我们已经有函数了还需要方法呢？"><a href="#为什么我们已经有函数了还需要方法呢？" class="headerlink" title="为什么我们已经有函数了还需要方法呢？"></a>为什么我们已经有函数了还需要方法呢？</h3><p>上面的程序已经被重写为只使用函数，没有方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name     <span class="type">string</span></span><br><span class="line">    salary   <span class="type">int</span></span><br><span class="line">    currency <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">displaySalary()方法被转化为一个函数，把 Employee 当做参数传入。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displaySalary</span><span class="params">(e Employee)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Salary of %s is %s%d&quot;</span>, e.name, e.currency, e.salary)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    emp1 := Employee&#123;</span><br><span class="line">        name:     <span class="string">&quot;Sam Adolf&quot;</span>,</span><br><span class="line">        salary:   <span class="number">5000</span>,</span><br><span class="line">        currency: <span class="string">&quot;$&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    displaySalary(emp1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>displaySalary</code> 方法被转化为一个函数，<code>Employee</code> 结构体被当做参数传递给它。这个程序也产生完全相同的输出：<code>Salary of Sam Adolf is $5000</code>。</p>
<p>既然我们可以使用函数写出相同的程序，那么为什么我们需要方法？这有着几个原因，让我们一个个的看看。</p>
<ul>
<li><code>Go 不是纯粹的面向对象编程语言</code>，而且Go不支持类。因此，基于类型的方法是一种实现和类相似行为的途径。</li>
<li>相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。假设我们有一个 <code>Square</code> 和 <code>Circle</code> 结构体。可以在 <code>Square</code> 和 <code>Circle</code> 上分别定义一个 <code>Area</code> 方法。见下面的程序。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    width  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.length * r.width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Pi * c.radius * c.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := Rectangle&#123;</span><br><span class="line">        length: <span class="number">10</span>,</span><br><span class="line">        width:  <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area of rectangle %d\n&quot;</span>, r.Area())</span><br><span class="line">    c := Circle&#123;</span><br><span class="line">        radius: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area of circle %f&quot;</span>, c.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyArea</span> of rectangle <span class="number">50</span></span><br><span class="line"><span class="attribute">Area</span> of circle <span class="number">452</span>.<span class="number">389342</span></span><br></pre></td></tr></table></figure>

<p>上面方法的属性被使用在接口中。我们将在接下来的教程中讨论这个问题。</p>
<h3 id="指针接收器与值接收器"><a href="#指针接收器与值接收器" class="headerlink" title="指针接收器与值接收器"></a>指针接收器与值接收器</h3><p>到目前为止，我们只看到了使用值接收器的方法。还可以创建使用指针接收器的方法。值接收器和指针接收器之间的区别在于，在指针接收器的方法内部的改变对于调用者是可见的，然而值接收器的情况不是这样的。让我们用下面的程序来帮助理解这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用值接收器的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> changeName(newName <span class="type">string</span>) &#123;</span><br><span class="line">    e.name = newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指针接收器的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> changeAge(newAge <span class="type">int</span>) &#123;</span><br><span class="line">    e.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e := Employee&#123;</span><br><span class="line">        name: <span class="string">&quot;Mark Andrew&quot;</span>,</span><br><span class="line">        age:  <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Employee name before change: %s&quot;</span>, e.name)</span><br><span class="line">    e.changeName(<span class="string">&quot;Michael Andrew&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nEmployee name after change: %s&quot;</span>, e.name)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n\nEmployee age before change: %d&quot;</span>, e.age)</span><br><span class="line">    (&amp;e).changeAge(<span class="number">51</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nEmployee age after change: %d&quot;</span>, e.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，<code>changeName</code> 方法有一个值接收器 <code>(e Employee)</code>，而 <code>changeAge</code> 方法有一个指针接收器 <code>(e *Employee)</code>。在 <code>changeName</code> 方法中对 <code>Employee</code> 结构体的字段 <code>name</code> 所做的改变对调用者是不可见的，因此程序在调用 <code>e.changeName(&quot;Michael Andrew&quot;)</code> 这个方法的前后打印出相同的名字。由于 <code>changeAge</code> 方法是使用指针 <code>(e *Employee)</code> 接收器的，所以在调用 <code>(&amp;e).changeAge(51)</code> 方法对 <code>age</code> 字段做出的改变对调用者将是可见的。该程序输出如下：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyEmployee name <span class="built_in">before</span> <span class="built_in">change</span>: Mark Andrew</span><br><span class="line">Employee name <span class="built_in">after</span> <span class="built_in">change</span>: Mark Andrew</span><br><span class="line"></span><br><span class="line">Employee age <span class="built_in">before</span> <span class="built_in">change</span>: <span class="number">50</span></span><br><span class="line">Employee age <span class="built_in">after</span> <span class="built_in">change</span>: <span class="number">51</span></span><br></pre></td></tr></table></figure>

<p>在上面程序的第 36 行，我们使用 <code>(&amp;e).changeAge(51)</code> 来调用 <code>changeAge</code> 方法。由于 <code>changeAge</code> 方法有一个指针接收器，所以我们使用 <code>(&amp;e)</code> 来调用这个方法。其实没有这个必要，Go语言让我们可以直接使用 <code>e.changeAge(51)</code>。<code>e.changeAge(51)</code> 会自动被Go语言解释为 <code>(&amp;e).changeAge(51)</code>。</p>
<p>下面的程序重写了，使用 <code>e.changeAge(51)</code> 来代替 <code>(&amp;e).changeAge(51)</code>，它输出相同的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用值接收器的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> changeName(newName <span class="type">string</span>) &#123;</span><br><span class="line">    e.name = newName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用指针接收器的方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> changeAge(newAge <span class="type">int</span>) &#123;</span><br><span class="line">    e.age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    e := Employee&#123;</span><br><span class="line">        name: <span class="string">&quot;Mark Andrew&quot;</span>,</span><br><span class="line">        age:  <span class="number">50</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Employee name before change: %s&quot;</span>, e.name)</span><br><span class="line">    e.changeName(<span class="string">&quot;Michael Andrew&quot;</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nEmployee name after change: %s&quot;</span>, e.name)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;\n\nEmployee age before change: %d&quot;</span>, e.age)</span><br><span class="line">    e.changeAge(<span class="number">51</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nEmployee age after change: %d&quot;</span>, e.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="那么什么时候使用指针接收器，什么时候使用值接收器？"><a href="#那么什么时候使用指针接收器，什么时候使用值接收器？" class="headerlink" title="那么什么时候使用指针接收器，什么时候使用值接收器？"></a>那么什么时候使用指针接收器，什么时候使用值接收器？</h3><p>一般来说，指针接收器可以使用在：对方法内部的接收器所做的改变应该对调用者可见时。</p>
<p>指针接收器也可以被使用在如下场景：当拷贝一个结构体的代价过于昂贵时。考虑下一个结构体有很多的字段。在方法内使用这个结构体做为值接收器需要拷贝整个结构体，这是很昂贵的。在这种情况下使用指针接收器，结构体不会被拷贝，只会传递一个指针到方法内部使用。</p>
<p>在其他的所有情况，值接收器都可以被使用。</p>
<h3 id="匿名字段的方法"><a href="#匿名字段的方法" class="headerlink" title="匿名字段的方法"></a>匿名字段的方法</h3><p>属于结构体的匿名字段的方法可以被直接调用，就好像这些方法是属于定义了匿名字段的结构体一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">    city  <span class="type">string</span></span><br><span class="line">    state <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a address)</span></span> fullAddress() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Full address: %s, %s&quot;</span>, a.city, a.state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName  <span class="type">string</span></span><br><span class="line">    address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := person&#123;</span><br><span class="line">        firstName: <span class="string">&quot;Elon&quot;</span>,</span><br><span class="line">        lastName:  <span class="string">&quot;Musk&quot;</span>,</span><br><span class="line">        address: address &#123;</span><br><span class="line">            city:  <span class="string">&quot;Los Angeles&quot;</span>,</span><br><span class="line">            state: <span class="string">&quot;California&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.fullAddress() <span class="comment">//访问 address 结构体的 fullAddress 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 32 行，我们通过使用 <code>p.fullAddress()</code> 来访问 <code>address</code> 结构体的 <code>fullAddress()</code> 方法。明确的调用 <code>p.address.fullAddress()</code> 是没有必要的。该程序输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyFull <span class="selector-tag">address</span>: Los Angeles, California</span><br></pre></td></tr></table></figure>

<h3 id="在方法中使用值接收器-与-在函数中使用值参数"><a href="#在方法中使用值接收器-与-在函数中使用值参数" class="headerlink" title="在方法中使用值接收器 与 在函数中使用值参数"></a>在方法中使用值接收器 与 在函数中使用值参数</h3><p>这个话题很多Go语言新手都弄不明白。我会尽量讲清楚。</p>
<p>当一个函数有一个值参数，它只能接受一个值参数。</p>
<p>当一个方法有一个值接收器，它可以接受值接收器和指针接收器。</p>
<p>让我们通过一个例子来理解这一点。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    width  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r rectangle)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area Function result: %d\n&quot;</span>, (r.length * r.width))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r rectangle)</span></span> area() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area Method result: %d\n&quot;</span>, (r.length * r.width))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rectangle&#123;</span><br><span class="line">        length: <span class="number">10</span>,</span><br><span class="line">        width:  <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    area(r)</span><br><span class="line">    r.area()</span><br><span class="line"></span><br><span class="line">    p := &amp;r</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       compilation error, cannot use p (type *rectangle) as type rectangle</span></span><br><span class="line"><span class="comment">       in argument to area</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//area(p)</span></span><br><span class="line"></span><br><span class="line">    p.area()<span class="comment">//通过指针调用值接收器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 12 行的函数 <code>func area(r rectangle)</code> 接受一个值参数，方法 <code>func (r rectangle) area()</code> 接受一个值接收器。</p>
<p>在第 25 行，我们通过值参数 <code>area(r)</code> 来调用 area 这个函数，这是合法的。同样，我们使用值接收器来调用 area 方法 <code>r.area()</code>，这也是合法的。</p>
<p>在第 28 行，我们创建了一个指向 <code>r</code> 的指针 <code>p</code>。如果我们试图把这个指针传递到只能接受一个值参数的函数 area，编译器将会报错。所以我把代码的第 33 行注释了。如果你把这行的代码注释去掉，编译器将会抛出错误 <code>compilation error, cannot use p (type *rectangle) as type rectangle in argument to area.</code>。这将会按预期抛出错误。</p>
<p>现在到了棘手的部分了，在第35行的代码 <code>p.area()</code> 使用指针接收器 <code>p</code> 调用了只接受一个值接收器的方法 <code>area</code>。这是完全有效的。原因是当 <code>area</code> 有一个值接收器时，为了方便Go语言把 <code>p.area()</code> 解释为 <code>(*p).area()</code>。</p>
<p>该程序将会输出：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyArea <span class="keyword">Function</span> <span class="title function_">result</span>: <span class="number">50</span></span><br><span class="line">Area <span class="keyword">Method</span> <span class="title function_">result</span>: <span class="number">50</span></span><br><span class="line">Area <span class="keyword">Method</span> <span class="title function_">result</span>: <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h3 id="在方法中使用指针接收器-与-在函数中使用指针参数"><a href="#在方法中使用指针接收器-与-在函数中使用指针参数" class="headerlink" title="在方法中使用指针接收器 与 在函数中使用指针参数"></a>在方法中使用指针接收器 与 在函数中使用指针参数</h3><p>和值参数相类似，函数使用指针参数只接受指针，而使用指针接收器的方法可以使用值接收器和指针接收器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    width  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perimeter</span><span class="params">(r *rectangle)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;perimeter function output:&quot;</span>, <span class="number">2</span>*(r.length+r.width))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *rectangle)</span></span> perimeter() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;perimeter method output:&quot;</span>, <span class="number">2</span>*(r.length+r.width))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := rectangle&#123;</span><br><span class="line">        length: <span class="number">10</span>,</span><br><span class="line">        width:  <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    p := &amp;r <span class="comment">//pointer to r</span></span><br><span class="line">    perimeter(p)</span><br><span class="line">    p.perimeter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cannot use r (type rectangle) as type *rectangle in argument to perimeter</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//perimeter(r)</span></span><br><span class="line"></span><br><span class="line">    r.perimeter()<span class="comment">//使用值来调用指针接收器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 12 行，定义了一个接受指针参数的函数 <code>perimeter</code>。第 17 行定义了一个有一个指针接收器的方法。</p>
<p>在第 27 行，我们调用 perimeter 函数时传入了一个指针参数。在第 28 行，我们通过指针接收器调用了 perimeter 方法。所有一切看起来都这么完美。</p>
<p>在被注释掉的第 33 行，我们尝试通过传入值参数 <code>r</code> 调用函数 <code>perimeter</code>。这是不被允许的，因为函数的指针参数不接受值参数。如果你把这行的代码注释去掉并把程序运行起来，编译器将会抛出错误 <code>main.go:33: cannot use r (type rectangle) as type *rectangle in argument to perimeter.</code>。</p>
<p>在第 35 行，我们通过值接收器 <code>r</code> 来调用有指针接收器的方法 <code>perimeter</code>。这是被允许的，为了方便Go语言把代码 <code>r.perimeter()</code> 解释为 <code>(&amp;r).perimeter()</code>。该程序输出：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyperimeter <span class="keyword">function</span> <span class="title function_">output</span>: <span class="number">30</span></span><br><span class="line">perimeter <span class="keyword">method</span> <span class="title function_">output</span>: <span class="number">30</span></span><br><span class="line">perimeter <span class="keyword">method</span> <span class="title function_">output</span>: <span class="number">30</span></span><br></pre></td></tr></table></figure>

<h3 id="在非结构体上的方法"><a href="#在非结构体上的方法" class="headerlink" title="在非结构体上的方法"></a>在非结构体上的方法</h3><p>到目前为止，我们只在结构体类型上定义方法。也可以在非结构体类型上定义方法，但是有一个问题。<strong>为了在一个类型上定义一个方法，方法的接收器类型定义和方法的定义应该在同一个包中。到目前为止，我们定义的所有结构体和结构体上的方法都是在同一个 main 包中，因此它们是可以运行的。</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a <span class="type">int</span>)</span></span> add(b <span class="type">int</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 3 行，我们尝试把一个 <code>add</code> 方法添加到内置的类型 <code>int</code>。这是不允许的，因为 <code>add</code> 方法的定义和 <code>int</code> 类型的定义不在同一个包中。该程序会抛出编译错误 <code>cannot define new methods on non-local type int</code>。</p>
<p>让该程序工作的方法是为内置类型 int 创建一个类型别名，然后创建一个以该类型别名为接收器的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a myInt)</span></span> add(b myInt) myInt &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    num1 := myInt(<span class="number">5</span>)</span><br><span class="line">    num2 := myInt(<span class="number">10</span>)</span><br><span class="line">    sum := num1.add(num2)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sum is&quot;</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第5行，我们为 <code>int</code> 创建了一个类型别名 <code>myInt</code>。在第7行，我们定义了一个以 <code>myInt</code> 为接收器的的方法 <code>add</code>。</p>
<p>该程序将会打印出 <code>Sum is 15</code>。</p>
<p>我已经创建了一个程序，包含了我们迄今为止所讨论的所有概念</p>
<h2 id="18-接口-一"><a href="#18-接口-一" class="headerlink" title="18.接口(一)"></a>18.接口(一)</h2><h3 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h3><p>在面向对象的领域里，接口一般这样定义：<strong>接口定义一个对象的行为</strong>。接口只指定了对象应该做什么，至于如何实现这个行为（即实现细节），则由对象本身去确定。</p>
<p>在 Go 语言中，接口就是方法签名（Method Signature）的集合。当一个类型定义了接口中的所有方法，我们称它实现了该接口。这与面向对象编程（OOP）的说法很类似。<strong>接口指定了一个类型应该具有的方法，并由该类型决定如何实现这些方法</strong>。</p>
<p>例如，<code>WashingMachine</code> 是一个含有 <code>Cleaning()</code> 和 <code>Drying()</code> 两个方法的接口。任何定义了 <code>Cleaning()</code> 和 <code>Drying()</code> 的类型，都称它实现了 <code>WashingMachine</code> 接口。</p>
<h3 id="接口的声明与实现"><a href="#接口的声明与实现" class="headerlink" title="接口的声明与实现"></a>接口的声明与实现</h3><p>让我们编写代码，创建一个接口并且实现它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface definition</span></span><br><span class="line"><span class="keyword">type</span> VowelsFinder <span class="keyword">interface</span> &#123;  </span><br><span class="line">    FindVowels() []<span class="type">rune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyString <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//MyString implements VowelsFinder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms MyString)</span></span> FindVowels() []<span class="type">rune</span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> vowels []<span class="type">rune</span></span><br><span class="line">    <span class="keyword">for</span> _, <span class="type">rune</span> := <span class="keyword">range</span> ms &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">rune</span> == <span class="string">&#x27;a&#x27;</span> || <span class="type">rune</span> == <span class="string">&#x27;e&#x27;</span> || <span class="type">rune</span> == <span class="string">&#x27;i&#x27;</span> || <span class="type">rune</span> == <span class="string">&#x27;o&#x27;</span> || <span class="type">rune</span> == <span class="string">&#x27;u&#x27;</span> &#123;</span><br><span class="line">            vowels = <span class="built_in">append</span>(vowels, <span class="type">rune</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vowels</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    name := MyString(<span class="string">&quot;Sam Anderson&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> v VowelsFinder</span><br><span class="line">    v = name <span class="comment">// possible since MyString implements VowelsFinder</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Vowels are %c&quot;</span>, v.FindVowels())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序的第 8 行，创建了一个名为 <code>VowelsFinder</code> 的接口，该接口有一个 <code>FindVowels() []rune</code> 的方法。</p>
<p>在接下来的一行，我们创建了一个 <code>MyString</code> 类型。</p>
<p><strong>在第 15 行，我们给接受者类型（Receiver Type） MyString 添加了方法 FindVowels() []rune。现在，我们称 MyString 实现了 VowelsFinder 接口。这就和其他语言（如 Java）很不同，其他一些语言要求一个类使用 implement 关键字，来显式地声明该类实现了接口。而在 Go 中，并不需要这样。如果一个类型包含了接口中声明的所有方法，那么它就隐式地实现了 Go 接口</strong>。</p>
<p>在第 28 行，<code>v</code> 的类型为 <code>VowelsFinder</code>，<code>name</code> 的类型为 <code>MyString</code>，我们把 <code>name</code> 赋值给了 <code>v</code>。由于 <code>MyString</code> 实现了 <code>VowelFinder</code>，因此这是合法的。在下一行，<code>v.FindVowels()</code> 调用了 <code>MyString</code> 类型的 <code>FindVowels</code> 方法，打印字符串 <code>Sam Anderson</code> 里所有的元音。该程序输出 <code>Vowels are [a e o]</code>。</p>
<p>祝贺！你已经创建并实现了你的第一个接口。</p>
<h3 id="接口的实际用途"><a href="#接口的实际用途" class="headerlink" title="接口的实际用途"></a>接口的实际用途</h3><p>前面的例子教我们创建并实现了接口，但还没有告诉我们接口的实际用途。在上面的程序里，如果我们使用 <code>name.FindVowels()</code>，而不是 <code>v.FindVowels()</code>，程序依然能够照常运行，但接口并没有体现出实际价值。</p>
<p>因此，我们现在讨论一下接口的实际应用场景。</p>
<p>我们编写一个简单程序，根据公司员工的个人薪资，计算公司的总支出。为了简单起见，我们假定支出的单位都是美元。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateSalary() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Permanent <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId    <span class="type">int</span></span><br><span class="line">    basicpay <span class="type">int</span></span><br><span class="line">    pf       <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Contract <span class="keyword">struct</span> &#123;  </span><br><span class="line">    empId  <span class="type">int</span></span><br><span class="line">    basicpay <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of permanent employee is sum of basic pay and pf</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Permanent)</span></span> CalculateSalary() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> p.basicpay + p.pf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//salary of contract employee is the basic pay alone</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Contract)</span></span> CalculateSalary() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> c.basicpay</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">total expense is calculated by iterating though the SalaryCalculator slice and summing  </span></span><br><span class="line"><span class="comment">the salaries of the individual employees  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">totalExpense</span><span class="params">(s []SalaryCalculator)</span></span> &#123;  </span><br><span class="line">    expense := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">        expense = expense + v.CalculateSalary()</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Total Expense Per Month $%d&quot;</span>, expense)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    pemp1 := Permanent&#123;<span class="number">1</span>, <span class="number">5000</span>, <span class="number">20</span>&#125;</span><br><span class="line">    pemp2 := Permanent&#123;<span class="number">2</span>, <span class="number">6000</span>, <span class="number">30</span>&#125;</span><br><span class="line">    cemp1 := Contract&#123;<span class="number">3</span>, <span class="number">3000</span>&#125;</span><br><span class="line">    employees := []SalaryCalculator&#123;pemp1, pemp2, cemp1&#125;</span><br><span class="line">    totalExpense(employees)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序的第 7 行声明了一个 <code>SalaryCalculator</code> 接口类型，它只有一个方法 <code>CalculateSalary() int</code>。</p>
<p>在公司里，我们有两类员工，即第 11 行和第 17 行定义的结构体：<code>Permanent</code> 和 <code>Contract</code>。长期员工（<code>Permanent</code>）的薪资是 <code>basicpay</code> 与 <code>pf</code> 相加之和，而合同员工（<code>Contract</code>）只有基本工资 <code>basicpay</code>。在第 23 行和第 28 行中，方法 <code>CalculateSalary</code> 分别实现了以上关系。由于 <code>Permanent</code> 和 <code>Contract</code> 都声明了该方法，因此它们都实现了 <code>SalaryCalculator</code> 接口。</p>
<p>第 36 行声明的 <code>totalExpense</code> 方法体现出了接口的妙用。该方法接收一个 <code>SalaryCalculator</code> 接口的切片（<code>[]SalaryCalculator</code>）作为参数。在第 49 行，我们向 <code>totalExpense</code> 方法传递了一个包含 <code>Permanent</code> 和 <code>Contact</code> 类型的切片。在第 39 行中，通过调用不同类型对应的 <code>CalculateSalary</code> 方法，<code>totalExpense</code> 可以计算得到支出。</p>
<p>这样做最大的优点是：<code>totalExpense</code> 可以扩展新的员工类型，而不需要修改任何代码。假如公司增加了一种新的员工类型 <code>Freelancer</code>，它有着不同的薪资结构。<code>Freelancer</code>只需传递到 <code>totalExpense</code> 的切片参数中，无需 <code>totalExpense</code> 方法本身进行修改。只要 <code>Freelancer</code> 也实现了 <code>SalaryCalculator</code> 接口，<code>totalExpense</code> 就能够实现其功能。</p>
<p>该程序输出 <code>Total Expense Per Month $14050</code>。</p>
<h3 id="接口的内部表示"><a href="#接口的内部表示" class="headerlink" title="接口的内部表示"></a>接口的内部表示</h3><p>我们可以把接口看作内部的一个元组 <code>(type, value)</code>。 <code>type</code> 是接口底层的具体类型（Concrete Type），而 <code>value</code> 是具体类型的值。</p>
<p>我们编写一个程序来更好地理解它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Tester()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m MyFloat)</span></span> Tester() &#123;  </span><br><span class="line">    fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(t Test)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Interface type %T value %v\n&quot;</span>, t, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> t Test</span><br><span class="line">    f := MyFloat(<span class="number">89.7</span>)</span><br><span class="line">    t = f</span><br><span class="line">    describe(t)</span><br><span class="line">    t.Tester()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Test</code> 接口只有一个方法 <code>Tester()</code>，而 <code>MyFloat</code> 类型实现了该接口。在第 24 行，我们把变量 <code>f</code>（<code>MyFloat</code> 类型）赋值给了 <code>t</code>（<code>Test</code> 类型）。现在 <code>t</code> 的具体类型为 <code>MyFloat</code>，而 <code>t</code> 的值为 <code>89.7</code>。第 17 行的 <code>describe</code> 函数打印出了接口的具体类型和值。该程序输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyInterface</span> type main.MyFloat value <span class="number">89</span>.<span class="number">7</span>  </span><br><span class="line"><span class="attribute">89</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>没有包含方法的接口称为空接口。空接口表示为 <code>interface&#123;&#125;</code>。由于空接口没有方法，因此所有类型都实现了空接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">describe</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Type = %T, value = %v\n&quot;</span>, i, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    s := <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    describe(s)</span><br><span class="line">    i := <span class="number">55</span></span><br><span class="line">    describe(i)</span><br><span class="line">    strt := <span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="type">string</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen R&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    describe(strt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序的第 7 行，<code>describe(i interface&#123;&#125;)</code> 函数接收空接口作为参数，因此，可以给这个函数传递任何类型。</p>
<p>在第 13 行、第 15 行和第 21 行，我们分别给 <code>describe</code> 函数传递了 <code>string</code>、<code>int</code> 和 <code>struct</code>。该程序打印：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CopyType</span> = string, value = Hello World  </span><br><span class="line"><span class="attr">Type</span> = int, value = <span class="number">55</span>  </span><br><span class="line"><span class="attr">Type</span> = struct &#123; name string &#125;, value = &#123;Naveen R&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言用于提取接口的底层值（Underlying Value）。</p>
<p>在语法 <code>i.(T)</code> 中，接口 <code>i</code> 的具体类型是 <code>T</code>，该语法用于获得接口的底层值。</p>
<p>一段代码胜过千言。下面编写个关于类型断言的程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    s := i.(<span class="type">int</span>) <span class="comment">//get the underlying int value from i</span></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="number">56</span></span><br><span class="line">    assert(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第 12 行，<code>s</code> 的具体类型是 <code>int</code>。在第 8 行，我们使用了语法 <code>i.(int)</code> 来提取 <code>i</code> 的底层 int 值。该程序会打印 <code>56</code>。</p>
<p>在上面程序中，如果具体类型不是 int，会发生什么呢？接下来看看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    s := i.(<span class="type">int</span>) </span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;Steven Paul&quot;</span></span><br><span class="line">    assert(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，我们把具体类型为 <code>string</code> 的 <code>s</code> 传递给了 <code>assert</code> 函数，试图从它提取出 int 值。该程序会报错：<code>panic: interface conversion: interface &#123;&#125; is string, not int.</code>。</p>
<p>要解决该问题，我们可以使用以下语法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyv, ok := i.(T)</span><br></pre></td></tr></table></figure>

<p>如果 <code>i</code> 的具体类型是 <code>T</code>，那么 <code>v</code> 赋值为 <code>i</code> 的底层值，而 <code>ok</code> 赋值为 <code>true</code>。</p>
<p>如果 <code>i</code> 的具体类型不是 <code>T</code>，那么 <code>ok</code> 赋值为 <code>false</code>，<code>v</code> 赋值为 <code>T</code> 类型的零值，<strong>此时程序不会报错</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    v, ok := i.(<span class="type">int</span>)</span><br><span class="line">    fmt.Println(v, ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">interface</span>&#123;&#125; = <span class="number">56</span></span><br><span class="line">    assert(s)</span><br><span class="line">    <span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="string">&quot;Steven Paul&quot;</span></span><br><span class="line">    assert(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当给 <code>assert</code> 函数传递 <code>Steven Paul</code> 时，由于 <code>i</code> 的具体类型不是 <code>int</code>，<code>ok</code> 赋值为 <code>false</code>，而 <code>v</code> 赋值为 0（int 的零值）。该程序打印：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Copy56</span> <span class="literal">true</span>  </span><br><span class="line"><span class="number">0</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="类型选择（Type-Switch）"><a href="#类型选择（Type-Switch）" class="headerlink" title="类型选择（Type Switch）"></a>类型选择（Type Switch）</h3><p>类型选择用于将接口的具体类型与很多 case 语句所指定的类型进行比较。它与一般的 switch 语句类似。唯一的区别在于类型选择指定的是类型，而一般的 switch 指定的是值。</p>
<p>类型选择的语法类似于类型断言。类型断言的语法是 <code>i.(T)</code>，而对于类型选择，类型 <code>T</code> 由关键字 <code>type</code> 代替。下面看看程序是如何工作的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I am a string and my value is %s\n&quot;</span>, i.(<span class="type">string</span>))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;I am an int and my value is %d\n&quot;</span>, i.(<span class="type">int</span>))</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Unknown type\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    findType(<span class="string">&quot;Naveen&quot;</span>)</span><br><span class="line">    findType(<span class="number">77</span>)</span><br><span class="line">    findType(<span class="number">89.98</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 8 行，<code>switch i.(type)</code> 表示一个类型选择。每个 case 语句都把 <code>i</code> 的具体类型和一个指定类型进行了比较。如果 case 匹配成功，会打印出相应的语句。该程序输出：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyI <span class="keyword">am</span> <span class="keyword">a</span> <span class="built_in">string</span> <span class="built_in">and</span> my value <span class="keyword">is</span> Naveen  </span><br><span class="line">I <span class="keyword">am</span> <span class="keyword">an</span> <span class="keyword">int</span> <span class="built_in">and</span> my value <span class="keyword">is</span> <span class="number">77</span>  </span><br><span class="line">Unknown <span class="built_in">type</span></span><br></pre></td></tr></table></figure>

<p>第 20 行中的 <code>89.98</code> 的类型是 <code>float64</code>，没有在 case 上匹配成功，因此最后一行打印了 <code>Unknown type</code>。</p>
<p><strong>还可以将一个类型和接口相比较。如果一个类型实现了接口，那么该类型与其实现的接口就可以互相比较</strong>。</p>
<p>为了阐明这一点，下面写一个程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Describe() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d years old&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findType</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">switch</span> v := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> Describer:</span><br><span class="line">        v.Describe()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;unknown type\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    findType(<span class="string">&quot;Naveen&quot;</span>)</span><br><span class="line">    p := Person&#123;</span><br><span class="line">        name: <span class="string">&quot;Naveen R&quot;</span>,</span><br><span class="line">        age:  <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    findType(p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中，结构体 <code>Person</code> 实现了 <code>Describer</code> 接口。在第 19 行的 case 语句中，<code>v</code> 与接口类型 <code>Describer</code> 进行了比较。<code>p</code> 实现了 <code>Describer</code>，因此满足了该 case 语句，于是当程序运行到第 32 行的 <code>findType(p)</code> 时，程序调用了 <code>Describe()</code> 方法。</p>
<p>该程序输出：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Copyunknown <span class="keyword">type</span>  </span><br><span class="line"><span class="type">Naveen </span>R <span class="keyword">is</span> <span class="number">25</span> years old</span><br></pre></td></tr></table></figure>

<p>接口（一）的内容到此结束。在接口（二）中我们还会继续讨论接口</p>
<h1 id="19-接口（二）"><a href="#19-接口（二）" class="headerlink" title="19. 接口（二）"></a>19. 接口（二）</h1><h3 id="实现接口：指针接受者与值接受者"><a href="#实现接口：指针接受者与值接受者" class="headerlink" title="实现接口：指针接受者与值接受者"></a>实现接口：指针接受者与值接受者</h3><p>在接口（一）上的所有示例中，我们都是使用值接受者（Value Receiver）来实现接口的。我们同样可以使用指针接受者（Pointer Receiver）来实现接口。只不过在用指针接受者实现接口时，还有一些细节需要注意。我们通过下面的代码来理解吧。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;  </span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> Describe() &#123; <span class="comment">// 使用值接受者实现  </span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s is %d years old\n&quot;</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    state   <span class="type">string</span></span><br><span class="line">    country <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Address)</span></span> Describe() &#123; <span class="comment">// 使用指针接受者实现</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;State %s Country %s&quot;</span>, a.state, a.country)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line">    d1 = p1</span><br><span class="line">    d1.Describe()</span><br><span class="line">    p2 := Person&#123;<span class="string">&quot;James&quot;</span>, <span class="number">32</span>&#125;</span><br><span class="line">    d1 = &amp;p2</span><br><span class="line">    d1.Describe()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d2 Describer</span><br><span class="line">    a := Address&#123;<span class="string">&quot;Washington&quot;</span>, <span class="string">&quot;USA&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果下面一行取消注释会导致编译错误：</span></span><br><span class="line"><span class="comment">       cannot use a (type Address) as type Describer</span></span><br><span class="line"><span class="comment">       in assignment: Address does not implement</span></span><br><span class="line"><span class="comment">       Describer (Describe method has pointer</span></span><br><span class="line"><span class="comment">       receiver)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//d2 = a</span></span><br><span class="line"></span><br><span class="line">    d2 = &amp;a <span class="comment">// 这是合法的</span></span><br><span class="line">    <span class="comment">// 因为在第 22 行，Address 类型的指针实现了 Describer 接口</span></span><br><span class="line">    d2.Describe()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序中的第 13 行，结构体 <code>Person</code> 使用值接受者，实现了 <code>Describer</code> 接口。</p>
<p>我们在讨论方法的时候就已经提到过，使用值接受者声明的方法，既可以用值来调用，也能用指针调用。<strong>不管是一个值，还是一个可以解引用的指针，调用这样的方法都是合法的</strong>。</p>
<p><code>p1</code> 的类型是 <code>Person</code>，在第 29 行，<code>p1</code> 赋值给了 <code>d1</code>。由于 <code>Person</code> 实现了接口变量 <code>d1</code>，因此在第 30 行，会打印 <code>Sam is 25 years old</code>。</p>
<p>接下来在第 32 行，<code>d1</code> 又赋值为 <code>&amp;p2</code>，在第 33 行同样打印输出了 <code>James is 32 years old</code>。棒棒哒。😃</p>
<p>在 22 行，结构体 <code>Address</code> 使用指针接受者实现了 <code>Describer</code> 接口。</p>
<p>在上面程序里，如果去掉第 45 行的注释，我们会得到编译错误：<code>main.go:42: cannot use a (type Address) as type Describer in assignment: Address does not implement Describer (Describe method has pointer receiver)</code>。这是因为在第 22 行，我们使用 <code>Address</code> 类型的指针接受者实现了接口 <code>Describer</code>，而接下来我们试图用 <code>a</code> 来赋值 <code>d2</code>。然而 <code>a</code> 属于值类型，它并没有实现 <code>Describer</code> 接口。你应该会很惊讶，因为我们曾经学习过，使用指针接受者的方法，无论指针还是值都可以调用它。那么为什么第 45 行的代码就不管用呢？</p>
<p><strong>其原因是：对于使用指针接受者的方法，用一个指针或者一个可取得地址的值来调用都是合法的。但接口中存储的具体值（Concrete Value）并不能取到地址，因此在第 45 行，对于编译器无法自动获取 a 的地址，于是程序报错</strong>。</p>
<p>第 47 行就可以成功运行，因为我们将 <code>a</code> 的地址 <code>&amp;a</code> 赋值给了 <code>d2</code>。</p>
<p>程序的其他部分不言而喻。该程序会打印：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopySam <span class="keyword">is</span> <span class="number">25</span> years <span class="keyword">old</span>  </span><br><span class="line">James <span class="keyword">is</span> <span class="number">32</span> years <span class="keyword">old</span>  </span><br><span class="line">State Washington Country USA</span><br></pre></td></tr></table></figure>

<h3 id="实现多个接口"><a href="#实现多个接口" class="headerlink" title="实现多个接口"></a>实现多个接口</h3><p>类型可以实现多个接口。我们看看下面程序是如何做到的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    DisplaySalary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LeaveCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateLeavesLeft() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">    basicPay <span class="type">int</span></span><br><span class="line">    pf <span class="type">int</span></span><br><span class="line">    totalLeaves <span class="type">int</span></span><br><span class="line">    leavesTaken <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> DisplaySalary() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s has salary $%d&quot;</span>, e.firstName, e.lastName, (e.basicPay + e.pf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> CalculateLeavesLeft() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.totalLeaves - e.leavesTaken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := Employee &#123;</span><br><span class="line">        firstName: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        lastName: <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">        basicPay: <span class="number">5000</span>,</span><br><span class="line">        pf: <span class="number">200</span>,</span><br><span class="line">        totalLeaves: <span class="number">30</span>,</span><br><span class="line">        leavesTaken: <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> s SalaryCalculator = e</span><br><span class="line">    s.DisplaySalary()</span><br><span class="line">    <span class="keyword">var</span> l LeaveCalculator = e</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nLeaves left =&quot;</span>, l.CalculateLeavesLeft())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序在第 7 行和第 11 行分别声明了两个接口：<code>SalaryCalculator</code> 和 <code>LeaveCalculator</code>。</p>
<p>第 15 行定义了结构体 <code>Employee</code>，它在第 24 行实现了 <code>SalaryCalculator</code> 接口的 <code>DisplaySalary</code> 方法，接着在第 28 行又实现了 <code>LeaveCalculator</code> 接口里的 <code>CalculateLeavesLeft</code> 方法。于是 <code>Employee</code> 就实现了 <code>SalaryCalculator</code> 和 <code>LeaveCalculator</code> 两个接口。</p>
<p>第 41 行，我们把 <code>e</code> 赋值给了 <code>SalaryCalculator</code> 类型的接口变量 ，而在 43 行，我们同样把 <code>e</code> 赋值给 <code>LeaveCalculator</code> 类型的接口变量 。由于 <code>e</code> 的类型 <code>Employee</code> 实现了 <code>SalaryCalculator</code> 和 <code>LeaveCalculator</code> 两个接口，因此这是合法的。</p>
<p>该程序会输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyNaveen</span> Ramanathan has salary $<span class="number">5200</span>  </span><br><span class="line"><span class="attribute">Leaves</span> left = <span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="接口的嵌套"><a href="#接口的嵌套" class="headerlink" title="接口的嵌套"></a>接口的嵌套</h3><p>尽管 Go 语言没有提供继承机制，但可以通过嵌套其他的接口，创建一个新接口。</p>
<p>我们来看看这如何实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SalaryCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    DisplaySalary()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LeaveCalculator <span class="keyword">interface</span> &#123;  </span><br><span class="line">    CalculateLeavesLeft() <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmployeeOperations <span class="keyword">interface</span> &#123;  </span><br><span class="line">    SalaryCalculator</span><br><span class="line">    LeaveCalculator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;  </span><br><span class="line">    firstName <span class="type">string</span></span><br><span class="line">    lastName <span class="type">string</span></span><br><span class="line">    basicPay <span class="type">int</span></span><br><span class="line">    pf <span class="type">int</span></span><br><span class="line">    totalLeaves <span class="type">int</span></span><br><span class="line">    leavesTaken <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> DisplaySalary() &#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s %s has salary $%d&quot;</span>, e.firstName, e.lastName, (e.basicPay + e.pf))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> CalculateLeavesLeft() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> e.totalLeaves - e.leavesTaken</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    e := Employee &#123;</span><br><span class="line">        firstName: <span class="string">&quot;Naveen&quot;</span>,</span><br><span class="line">        lastName: <span class="string">&quot;Ramanathan&quot;</span>,</span><br><span class="line">        basicPay: <span class="number">5000</span>,</span><br><span class="line">        pf: <span class="number">200</span>,</span><br><span class="line">        totalLeaves: <span class="number">30</span>,</span><br><span class="line">        leavesTaken: <span class="number">5</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> empOp EmployeeOperations = e</span><br><span class="line">    empOp.DisplaySalary()</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nLeaves left =&quot;</span>, empOp.CalculateLeavesLeft())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序的第 15 行，我们创建了一个新的接口 <code>EmployeeOperations</code>，它嵌套了两个接口：<code>SalaryCalculator</code> 和 <code>LeaveCalculator</code>。</p>
<p>如果一个类型定义了 <code>SalaryCalculator</code> 和 <code>LeaveCalculator</code> 接口里包含的方法，我们就称该类型实现了 <code>EmployeeOperations</code> 接口。</p>
<p>在第 29 行和第 33 行，由于 <code>Employee</code> 结构体定义了 <code>DisplaySalary</code> 和 <code>CalculateLeavesLeft</code> 方法，因此它实现了接口 <code>EmployeeOperations</code>。</p>
<p>在 46 行，<code>empOp</code> 的类型是 <code>EmployeeOperations</code>，<code>e</code> 的类型是 <code>Employee</code>，我们把 <code>empOp</code> 赋值为 <code>e</code>。接下来的两行，<code>empOp</code> 调用了 <code>DisplaySalary()</code> 和 <code>CalculateLeavesLeft()</code> 方法。</p>
<p>该程序输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CopyNaveen</span> Ramanathan has salary $<span class="number">5200</span></span><br><span class="line"><span class="attribute">Leaves</span> left = <span class="number">25</span></span><br></pre></td></tr></table></figure>

<h3 id="接口的零值"><a href="#接口的零值" class="headerlink" title="接口的零值"></a>接口的零值</h3><p>接口的零值是 <code>nil</code>。对于值为 <code>nil</code> 的接口，其底层值（Underlying Value）和具体类型（Concrete Type）都为 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;  </span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    <span class="keyword">if</span> d1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;d1 is nil and has type %T value %v\n&quot;</span>, d1, d1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序里的 <code>d1</code> 等于 <code>nil</code>，程序会输出：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copyd1 <span class="keyword">is</span> <span class="keyword">nil</span> <span class="keyword">and</span> <span class="keyword">has</span> <span class="keyword">type</span> &lt;<span class="keyword">nil</span>&gt; value &lt;<span class="keyword">nil</span>&gt;</span><br></pre></td></tr></table></figure>

<p>对于值为 <code>nil</code> 的接口，由于没有底层值和具体类型，当我们试图调用它的方法时，程序会产生 <code>panic</code> 异常。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Copypackage main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Describer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Describe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> d1 Describer</span><br><span class="line">    d1.Describe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述程序中，<code>d1</code> 等于 <code>nil</code>，程序产生运行时错误 <code>panic</code>： <strong>panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xc8527]</strong> 。</p>

    </div>

    
    
    

    <footer class="post-footer"><div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Michaeldong 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="Michaeldong 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Go/" rel="tag"># Go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/08/25/Ansible/" rel="prev" title="Python调用ansible API系列">
                  <i class="fa fa-chevron-left"></i> Python调用ansible API系列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/20/Go-2.%E8%BF%9B%E9%98%B6/" rel="next" title="Go-进阶">
                  Go-进阶 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Michaeldong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:06</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":"9D92XKxDbxTrStQPr"}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>





  





  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":300,"vOffset":300},"mobile":{"show":true},"dialog":{"enable":true,"hitokoto":true}});</script></body>
</html>
