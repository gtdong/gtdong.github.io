<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gtdong.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"gitalk","active":true,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Docker 官网：https:&#x2F;&#x2F;docs.docker.com&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="K8s-1.基础-docker容器基础入门">
<meta property="og:url" content="https://gtdong.github.io/2022/04/30/K8s-1.%E5%9F%BA%E7%A1%80-docker%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="TsukiBlog">
<meta property="og:description" content="Docker 官网：https:&#x2F;&#x2F;docs.docker.com&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174342477.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174434436.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174511248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501180657360.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174715992.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175009431.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175033352.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175116301.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175133955.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175242084.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175304263.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175329604.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175412377.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175432123.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175536173.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175549974.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175617949.png">
<meta property="og:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175642680.png">
<meta property="article:published_time" content="2022-04-30T05:05:00.000Z">
<meta property="article:modified_time" content="2022-05-01T15:06:32.189Z">
<meta property="article:author" content="Michaeldong">
<meta property="article:tag" content="K8s">
<meta property="article:tag" content="云原生">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174342477.png">


<link rel="canonical" href="https://gtdong.github.io/2022/04/30/K8s-1.%E5%9F%BA%E7%A1%80-docker%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gtdong.github.io/2022/04/30/K8s-1.%E5%9F%BA%E7%A1%80-docker%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","path":"2022/04/30/K8s-1.基础-docker容器基础入门/","title":"K8s-1.基础-docker容器基础入门"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>K8s-1.基础-docker容器基础入门 | TsukiBlog</title>
  




<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>
#needsharebutton-postbottom {
  cursor: pointer;
  height: 26px;
  margin-top: 10px;
  position: relative;
}
#needsharebutton-postbottom .btn {
  border: 1px solid $btn-default-border-color;
  border-radius: 3px;
  display: initial;
  padding: 1px 4px;
}
</style>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">TsukiBlog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1%E3%80%81docker-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1、docker 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2%E3%80%81docker-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">2、docker 的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3%E3%80%81docker-%E7%BC%BA%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">3、docker 缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4%E3%80%81%E5%AE%89%E8%A3%85-Docker"><span class="nav-number">4.</span> <span class="nav-text">4、安装 Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5%E3%80%81%E5%BC%80%E5%90%AF%E5%8C%85%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">5、开启包转发功能和修改内核参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6%E3%80%81%E9%85%8D%E7%BD%AE-docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="nav-number">6.</span> <span class="nav-text">6、配置 docker 镜像加速器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7%E3%80%81docker-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">7、docker 的基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 镜像相关操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 容器相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E4%BB%A5%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1 以交互式方式启动并进入容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E4%BB%A5%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 以守护进程方式启动容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.2.3 查看正在运行的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-4-%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.4.</span> <span class="nav-text">7.2.4 停止容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-5-%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%8F%E5%81%9C%E6%AD%A2%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.5.</span> <span class="nav-text">7.2.5 启动已经停止的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-6-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">7.2.6.</span> <span class="nav-text">7.2.6 进入容器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8%E3%80%81%E9%80%9A%E8%BF%87-docker-%E9%83%A8%E7%BD%B2-nginx-%E6%9C%8D%E5%8A%A1"><span class="nav-number">8.</span> <span class="nav-text">8、通过 docker 部署 nginx 服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9%E3%80%81dockerfile-%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="nav-number">9.</span> <span class="nav-text">9、dockerfile 语法详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10%E3%80%81dockerfile-%E6%9E%84%E5%BB%BA-nginx-%E9%95%9C%E5%83%8F"><span class="nav-number">10.</span> <span class="nav-text">10、dockerfile 构建 nginx 镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11%E3%80%81dockerfile-%E6%9E%84%E5%BB%BA-tomcat-%E9%95%9C%E5%83%8F"><span class="nav-number">11.</span> <span class="nav-text">11、dockerfile 构建 tomcat 镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12%E3%80%81Docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="nav-number">12.</span> <span class="nav-text">12、Docker 容器的数据管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13%E3%80%81Docker-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%AE%B9%E5%99%A8"><span class="nav-number">13.</span> <span class="nav-text">13、Docker 的数据卷容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14%E3%80%81docker-%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F"><span class="nav-number">14.</span> <span class="nav-text">14、docker 数据卷的备份和还原</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15%E3%80%81docker-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="nav-number">15.</span> <span class="nav-text">15、docker 容器互联</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="nav-number">15.1.</span> <span class="nav-text">15.1 docker 容器的网络基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BA%92%E8%81%94"><span class="nav-number">15.2.</span> <span class="nav-text">15.2 docker 容器的互联</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#15-2-1-docker-link-%E8%AE%BE%E7%BD%AE%E7%BD%91%E7%BB%9C%E5%88%AB%E5%90%8D"><span class="nav-number">15.2.1.</span> <span class="nav-text">15.2.1 docker link 设置网络别名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16%E3%80%81docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.</span> <span class="nav-text">16、docker 容器的网络模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1-none-%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.1.</span> <span class="nav-text">16.1 none 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2-container-%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.2.</span> <span class="nav-text">16.2 container 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3-bridge-%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.3.</span> <span class="nav-text">16.3 bridge 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-4-host-%E6%A8%A1%E5%BC%8F"><span class="nav-number">16.4.</span> <span class="nav-text">16.4 host 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17%E3%80%81docker-%E8%B5%84%E6%BA%90%E9%85%8D%E9%A2%9D"><span class="nav-number">17.</span> <span class="nav-text">17、docker 资源配额</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1-docker-%E5%AE%B9%E5%99%A8%E6%8E%A7%E5%88%B6-cpu"><span class="nav-number">17.1.</span> <span class="nav-text">17.1 docker 容器控制 cpu</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1-1-%E6%8C%87%E5%AE%9A-docker-%E5%AE%B9%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9A%84-cpu-%E4%BB%BD%E9%A2%9D"><span class="nav-number">17.1.1.</span> <span class="nav-text">17.1.1 指定 docker 容器可以使用的 cpu 份额</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1-2-CPU-core-%E6%A0%B8%E5%BF%83%E6%8E%A7%E5%88%B6"><span class="nav-number">17.1.2.</span> <span class="nav-text">17.1.2 CPU core 核心控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-1-3-CPU-%E9%85%8D%E9%A2%9D%E6%8E%A7%E5%88%B6%E5%8F%82%E6%95%B0%E7%9A%84%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">17.1.3.</span> <span class="nav-text">17.1.3 CPU 配额控制参数的混合使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2-docker-%E5%AE%B9%E5%99%A8%E6%8E%A7%E5%88%B6%E5%86%85%E5%AD%98"><span class="nav-number">17.2.</span> <span class="nav-text">17.2 docker 容器控制内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18%E3%80%81docker-%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-harbor"><span class="nav-number">18.</span> <span class="nav-text">18、docker 私有镜像仓库 harbor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-1-%E4%B8%BA-Harbor-%E8%87%AA%E7%AD%BE%E5%8F%91%E8%AF%81%E4%B9%A6"><span class="nav-number">18.1.</span> <span class="nav-text">18.1 为 Harbor 自签发证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2-%E5%AE%89%E8%A3%85-Harbor"><span class="nav-number">18.2.</span> <span class="nav-text">18.2 安装 Harbor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-1-%E5%AE%89%E8%A3%85-Docker"><span class="nav-number">18.2.1.</span> <span class="nav-text">18.2.1 安装 Docker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-2-%E5%BC%80%E5%90%AF%E5%8C%85%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="nav-number">18.2.2.</span> <span class="nav-text">18.2.2 开启包转发功能和修改内核参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-2-4-%E5%AE%89%E8%A3%85-harbor"><span class="nav-number">18.2.3.</span> <span class="nav-text">18.2.4 安装 harbor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-3-Harbor-%E5%9B%BE%E5%83%8F%E5%8C%96%E7%95%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="nav-number">18.3.</span> <span class="nav-text">18.3 Harbor 图像化界面使用说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4-%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8-harbor-%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="nav-number">18.4.</span> <span class="nav-text">18.4 测试使用 harbor 私有镜像仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-5-%E4%BB%8E-harbor-%E4%BB%93%E5%BA%93%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="nav-number">18.5.</span> <span class="nav-text">18.5 从 harbor 仓库下载镜像</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Michaeldong"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Michaeldong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated">
    <button><i class="fa fa-comment"></i>
      Chat
    </button>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/gtdong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gtdong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/gtdong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gtdong.github.io/2022/04/30/K8s-1.%E5%9F%BA%E7%A1%80-docker%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Michaeldong">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TsukiBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="K8s-1.基础-docker容器基础入门 | TsukiBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          K8s-1.基础-docker容器基础入门
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-30 13:05:00" itemprop="dateCreated datePublished" datetime="2022-04-30T13:05:00+08:00">2022-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 23:06:32" itemprop="dateModified" datetime="2022-05-01T23:06:32+08:00">2022-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/K8s/" itemprop="url" rel="index"><span itemprop="name">K8s</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>33 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Docker 官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<span id="more"></span>

<p>Docker 的 github 地址：<a target="_blank" rel="noopener" href="https://github.com/moby/moby">https://github.com/moby/moby</a></p>
<p>Dockerhub 官网</p>
<p><a target="_blank" rel="noopener" href="https://registry.hub.docker.com/">https://registry.hub.docker.com</a></p>
<p><a target="_blank" rel="noopener" href="https://dashboard.daocloud.io/mirror">https://dashboard.daocloud.io/mirror</a></p>
<h2 id="1、docker-是什么？"><a href="#1、docker-是什么？" class="headerlink" title="1、docker 是什么？"></a>1、docker 是什么？</h2><p><strong>Docker</strong> 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于Google 公司推出的 Go 语言实现。项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在GitHub上进行维护。</p>
<p><strong>Docker</strong> 是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何支持 docker 的机器上运行。容器是完全使用沙箱机制，相互之间不会有任何接口调用。</p>
<p>Docker logo：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174342477.png" alt="image-20220501174342477"></p>
<p>Docker 的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被装在集装箱里，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送蔬菜的船和专门运送货物的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。<br><strong>docker</strong> 就是类似的理念。<strong>云计算</strong>就好比大货轮。<strong>docker</strong> 就是集装箱。</p>
<h2 id="2、docker-的优点"><a href="#2、docker-的优点" class="headerlink" title="2、docker 的优点"></a>2、docker 的优点</h2><p>1）<strong>快</strong></p>
<p>运行时的性能快，管理操作(启动，停止，开始，重启等等) 都是以秒或毫秒为单位的。</p>
<p>2）<strong>敏捷</strong></p>
<p>像虚拟机一样敏捷，而且会更便宜，在 bare metal(裸机)上布署像点个按钮一样简单。</p>
<p>3）<strong>灵活</strong></p>
<p>将应用和系统“容器化”，不添加额外的操作系统</p>
<p>4）<strong>轻量</strong></p>
<p>在一台服务器上可以布署 100~1000 个 Containers 容器。</p>
<p>5）<strong>便宜</strong></p>
<p>开源的，免费的，低成本的。</p>
<p><strong>docker-ce：</strong>社区版</p>
<p><strong>docker-ee:</strong>  商业版</p>
<h2 id="3、docker-缺点"><a href="#3、docker-缺点" class="headerlink" title="3、docker 缺点"></a>3、docker 缺点</h2><p>所有容器共用 linux kernel 资源，资源能否实现最大限度利用，所以在安全上也会存在漏洞。</p>
<h2 id="4、安装-Docker"><a href="#4、安装-Docker" class="headerlink" title="4、安装 Docker"></a>4、安装 Docker</h2><p>主机 ip：192.168.40.180</p>
<p>Centos7.6-centos7.9</p>
<p>4Gib/4vCPU</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置主机名：</span></span><br><span class="line">[root@xianchaomaster1 ~]# hostnamectl set-hostname xianchaomaster1 &amp;&amp; bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭防火墙:</span></span><br><span class="line">[root@xianchaomaster1 ~]# systemctl stop firewalld &amp;&amp; systemctl disable firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭 iptables 防火墙</span></span><br><span class="line">[root@xianchaomaster1 ~]# yum install iptables-services -y #安装 iptables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">禁用 iptables</span></span><br><span class="line"></span><br><span class="line">[root@xianchaomaster1 ~]# service iptables stop &amp;&amp; systemctl disable iptables</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">清空防火墙规则</span></span><br><span class="line"><span class="meta prompt_">[root@xianchaomaster1~]# </span><span class="language-bash">iptables -F</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭 selinux</span></span><br><span class="line">[root@xianchaomaster1 ~]# setenforce 0</span><br><span class="line">[root@xianchaomaster1 ~]# sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config</span><br><span class="line">注意：修改 selinux 配置文件之后，重启机器，selinux 才能永久生效</span><br><span class="line">[root@xianchaomaster1 ~]# getenforce</span><br><span class="line">显示 Disabled 表示 selinux 关闭成功</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置时间同步</span></span><br><span class="line">[root@xianchaomaster1 ~]# yum install -y ntp ntpdate</span><br><span class="line">[root@xianchaomaster1 ~]# ntpdate cn.pool.ntp.org</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编写计划任务</span></span><br><span class="line">[root@xianchaomaster1 ~]# crontab -e</span><br><span class="line">* \*/1 \* \* \* /usr/sbin/ntpdate cn.pool.ntp.org</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启 crond 服务使配置生效：</span></span><br><span class="line">[root@xianchaomaster1 ~]# systemctl restart crond</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装基础软件包</span></span><br><span class="line"></span><br><span class="line">[root@xianchaomaster1 ~]# yum install -y wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget vim ncurses-devel autoconf automake zlib-devel python-devel epel-release openssh-server socat ipvsadm conntrack </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装 docker-ce</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">配置 docker-ce 国内 yum 源（阿里云）</span></span><br><span class="line">[root@xianchaomaster1 ~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装 docker 依赖包</span></span><br><span class="line">[root@xianchaomaster1 ~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装 docker-ce</span></span><br><span class="line">[root@xianchaomaster1 ~]# yum install docker-ce -y </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动 docker 服务</span></span><br><span class="line">[root@xianchaomaster1 ~]# systemctl start docker &amp;&amp; systemctl enable docker</span><br><span class="line">[root@xianchaomaster1 ~]# systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: </span><br><span class="line">disabled)</span><br><span class="line">Active: active (running) since Thu 2021-07-01 21:29:18 CST; 30s ago</span><br><span class="line">Docs: https://docs.docker.com</span><br><span class="line"></span><br><span class="line">看到 running，表示 docker 正常运行</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 Docker 版本信息</span></span><br><span class="line">[root@xianchaomaster1 ~]# docker version </span><br></pre></td></tr></table></figure>



<h2 id="5、开启包转发功能和修改内核参数"><a href="#5、开启包转发功能和修改内核参数" class="headerlink" title="5、开启包转发功能和修改内核参数"></a>5、开启包转发功能和修改内核参数</h2><p><strong>内核参数修改：</strong>br_netfilter 模块用于将桥接流量转发至 iptables 链，br_netfilter 内核参数需要开启转发。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# modprobe br_netfilter</span><br><span class="line">[root@xianchaomaster1 ~]# cat &gt; /etc/sysctl.d/docker.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>使参数生效</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# sysctl -p /etc/sysctl.d/docker.conf</span><br></pre></td></tr></table></figure>

<p>重启后模块失效，下面是开机自动加载模块的脚本,在/etc/新建 rc.sysinit 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/rc.sysinit</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for file in /etc/sysconfig/modules/\*.modules ; do</span><br><span class="line">[ -x $file ] &amp;&amp; $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>在/etc/sysconfig/modules/目录下新建文件如下</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sysconfig/modules/br_netfilter.modules</span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure>

<p><strong>增加权限</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# chmod 755 /etc/sysconfig/modules/br_netfilter.modules</span><br></pre></td></tr></table></figure>

<p><strong>重启机器模块也会自动加载</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsmod |grep br_netfilter</span><br><span class="line">br_netfilter 22209 0</span><br><span class="line">bridge 136173 1 br_netfilter</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<p><strong>Docker 安装后出现：WARNING: bridge-nf-call-iptables is disabled 的解决办法：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1： </span><br></pre></td></tr></table></figure>

<p>将 Linux 系统作为路由或者 VPN 服务就必须要开启 IP 转发功能。当 linux 主机有多个网卡时一个网卡收到的信息是否能够传递给其他的网卡 ，如果设置成 1 的话 可以进行数据包转发，可以实现 VxLAN 等功能。不开启会导致 docker 部署应用无法访问。</p>
<p><strong>#重启 docker</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="6、配置-docker-镜像加速器"><a href="#6、配置-docker-镜像加速器" class="headerlink" title="6、配置 docker 镜像加速器"></a>6、配置 docker 镜像加速器</h2><p>登陆阿里云镜像仓库</p>
<p><a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<p>如果没有开通，可开通阿里云的镜像服务找到镜像加速器，然后按照箭头方向操作</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174434436.png" alt="image-20220501174434436"></p>
<p>修改<code>/etc/docker/daemon.json</code>，变成如下</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;https://y8y6vosv.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span><span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span><span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">,</span><span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span><span class="punctuation">,</span><span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>让配置文件生效</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174511248.png" alt="image-20220501174511248"></p>
<h2 id="7、docker-的基本用法"><a href="#7、docker-的基本用法" class="headerlink" title="7、docker 的基本用法"></a>7、docker 的基本用法</h2><h3 id="7-1-镜像相关操作"><a href="#7-1-镜像相关操作" class="headerlink" title="7.1 镜像相关操作"></a>7.1 镜像相关操作</h3><p><strong>从 dockerhub 查找镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker search centos</span><br><span class="line">NAME DESCRIPTION STARS </span><br><span class="line">OFFICIAL AUTOMATED</span><br><span class="line">centos The official build of CentOS. 6639 </span><br><span class="line">[OK] </span><br><span class="line">ansible/centos7-ansible Ansible on Centos7 134 </span><br><span class="line">[OK]</span><br><span class="line">consol/centos-xfce-vnc Centos container with &quot;headless&quot; VNC session… 129 </span><br><span class="line">[OK]</span><br><span class="line">jdeathe/centos-ssh OpenSSH / Supervisor / EPEL/IUS/SCL Repos - … 118 </span><br><span class="line">[OK]</span><br></pre></td></tr></table></figure>

<p><strong>解释说明：</strong></p>
<p><strong>NAME:</strong> 镜像仓库源的名称</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
<p><strong>AUTOMATED:</strong> 自动构建。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载镜像</span></span><br><span class="line">[root@xianchaomaster1 ~]# docker pull centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看本地镜像</span></span><br><span class="line">[root@xianchaomaster1 ~]# docker images</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">把镜像做成离线压缩包</span></span><br><span class="line">[root@xianchaomaster1 ~]# docker save -o centos.tar.gz centos</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">解压离线镜像包</span></span><br><span class="line">[root@xianchaomaster1 ~]# docker load -i centos.tar.gz </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除镜像</span></span><br><span class="line">[root@xianchaomaster1 ~]# docker rmi -f centos:latest</span><br></pre></td></tr></table></figure>

<h3 id="7-2-容器相关操作"><a href="#7-2-容器相关操作" class="headerlink" title="7.2 容器相关操作"></a>7.2 容器相关操作</h3><h4 id="7-2-1-以交互式方式启动并进入容器"><a href="#7-2-1-以交互式方式启动并进入容器" class="headerlink" title="7.2.1 以交互式方式启动并进入容器"></a>7.2.1 以交互式方式启动并进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --name=hello -it centos /bin/bash</span><br><span class="line"></span><br><span class="line">[root@09c4933b5cd7 /]#</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入 <span class="built_in">exit</span>，退出容器，退出之后容器也会停止，不会再前台运行</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker run 运行并创建容器</span></span><br><span class="line">--name 容器的名字</span><br><span class="line">-i 交互式</span><br><span class="line">-t 分配伪终端</span><br><span class="line">centos: 启动 docker 需要的镜像</span><br><span class="line">/bin/bash 说明你的 shell 类型为 bash，bash shell 是最常用的一种 shell, 是大多数 Linux 发行版默认的 shell。 此外还有 C shell 等其它 shell。 </span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-以守护进程方式启动容器"><a href="#7-2-2-以守护进程方式启动容器" class="headerlink" title="7.2.2 以守护进程方式启动容器"></a>7.2.2 以守护进程方式启动容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --name=hello1 -td centos </span><br><span class="line">[root@xianchaomaster1 ~]# docker ps |grep hello1</span><br><span class="line">1a2b73ba0ac2 centos &quot;/bin/bash&quot; hello1</span><br><span class="line"></span><br><span class="line">-d 在后台运行 docker</span><br><span class="line">[root@xianchaomaster1 ~]# docker exec -it hello1 /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="7-2-3-查看正在运行的容器"><a href="#7-2-3-查看正在运行的容器" class="headerlink" title="7.2.3 查看正在运行的容器"></a>7.2.3 查看正在运行的容器</h4><p>docker ps</p>
<p>[root@xianchaomaster1 ~]# docker ps -a #查看所有容器，包括运行和退出的容器</p>
<h4 id="7-2-4-停止容器"><a href="#7-2-4-停止容器" class="headerlink" title="7.2.4 停止容器"></a>7.2.4 停止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop hello1 </span><br></pre></td></tr></table></figure>

<h4 id="7-2-5-启动已经停止的容器"><a href="#7-2-5-启动已经停止的容器" class="headerlink" title="7.2.5 启动已经停止的容器"></a>7.2.5 启动已经停止的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start hello1 </span><br></pre></td></tr></table></figure>

<h4 id="7-2-6-进入容器"><a href="#7-2-6-进入容器" class="headerlink" title="7.2.6 进入容器"></a>7.2.6 进入容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it hello1 /bin/bash</span><br><span class="line">[root@xianchaomaster1 ~]# docker rm -f hello1 #删除容器</span><br><span class="line">[root@xianchaomaster1 ~]# docker --help</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看 docker 帮助命令</span></span><br></pre></td></tr></table></figure>

<h2 id="8、通过-docker-部署-nginx-服务"><a href="#8、通过-docker-部署-nginx-服务" class="headerlink" title="8、通过 docker 部署 nginx 服务"></a>8、通过 docker 部署 nginx 服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --name nginx -p 80 -itd centos </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-p 把容器端口随机在物理机随机映射一个端口</span></span><br><span class="line"></span><br><span class="line">[root@xianchaomaster1 ~]# docker ps | grep nginx</span><br><span class="line">ecfa046e9681 centos &quot;/bin/bash&quot; 5 seconds ago Up 4 seconds 0.0.0.0:49153-&gt;80/tcp, :::49153-&gt;80/tcp nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在 docker 里安装 nginx</span></span><br><span class="line">docker exec -it nginx /bin/bash </span><br><span class="line"><span class="meta prompt_">[root@ecfa046e9681]# </span><span class="language-bash">ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">	inet 127.0.0.1/8 scope host lo</span><br><span class="line">		valid_lft forever preferred_lft forever</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">	link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">21: eth0@if22: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group </span><br><span class="line">default </span><br><span class="line">	link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">	inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">		valid_lft forever preferred_lft forever</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过上面可以看到容器的 ip 是 172.17.0.3</span></span><br></pre></td></tr></table></figure>

<p><strong>yum 安装 nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install wget -y</span><br><span class="line">yum install nginx -y </span><br></pre></td></tr></table></figure>

<p><strong>安装文本编辑器 vim</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim-enhanced -y</span><br></pre></td></tr></table></figure>

<p><strong>创建静态页面</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/www/html -p</span><br><span class="line">cd /var/www/html/</span><br><span class="line">cat index.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;nginx in docker&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello,My Name is xianchao&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修改 nginx 配置文件中的 root 路径，如下</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br><span class="line">root /var/www/html/;</span><br></pre></td></tr></table></figure>

<p><strong>启动 nginx</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx</span><br></pre></td></tr></table></figure>

<p><strong>访问 docker 里的 nginx 服务,复制一个终端窗口，执行如下命令</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker ps | grep nginx</span><br><span class="line">ecfa046e9681 centos &quot;/bin/bash&quot; </span><br><span class="line">12 minutes ago Up 12 minutes 0.0.0.0:49153-&gt;80/tcp, :::49153-&gt;80/tcp nginx</span><br></pre></td></tr></table></figure>

<p><strong>能查看到 nginx 容器在物理机映射的端口是 49153</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# curl http://192.168.40.180:49153</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;nginx in docker&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello,My Name is xianchao&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>也可以直接访问容器的 ip:port</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# curl 172.17.0.3:80</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;nginx in docker&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello,My Name is xianchao&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>流量走向：</strong>访问物理节点 ip:port（容器在物理节点映射的端口）–→容器 ip:port（容器里部署的服务的端口）-&gt; 就可以访问到容器里部署的应用了</p>
<h2 id="9、dockerfile-语法详解"><a href="#9、dockerfile-语法详解" class="headerlink" title="9、dockerfile 语法详解"></a>9、dockerfile 语法详解</h2><p><strong>Dockerfile</strong> 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。基于 <strong>Dockerfile</strong> 构建镜像可以使用 docker build 命令。docker build 命令中使用-f 可以指定具体的dockerfile 文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install nginx -y</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>dockerfile 构建过程：</strong></p>
<p>1.从基础镜像运行一个容器</p>
<p>2.执行一条指令，对容器做出修改</p>
<p>3.执行类似 docker commit 的操作，提交一个新的镜像层</p>
<p>4.再基于刚提交的镜像运行一个新的容器</p>
<p>5.执行 dockerfile 中的下一条指令，直至所有指令执行完毕</p>
<p><strong>（1）FROM</strong></p>
<p>基础镜像，必须是可以下载下来的，定制的镜像都是基于 FROM 的镜像，这里的 centos 就是定制需要的</p>
<p>基础镜像。后续的操作都是基于 centos 镜像。 </p>
<p><strong>（2）MAINTAINER</strong></p>
<p>指定镜像的作者信息</p>
<p><strong>（3）RUN</strong>：指定在当前镜像构建过程中要运行的命令</p>
<p>包含两种模式</p>
<p>1、Shell</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;<span class="built_in">command</span>&gt; (shell 模式，这个是最常用的，需要记住)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> hello</span></span><br></pre></td></tr></table></figure>

<p>2、exec 模式</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [“executable”，“param1”，“param2”](<span class="built_in">exec</span> 模式)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [“/bin/bash”,”-c”,”<span class="built_in">echo</span> hello”]</span></span><br></pre></td></tr></table></figure>

<p>等价于/bin/bash -c echo hello</p>
<p><strong>（4）EXPOSE 指令</strong></p>
<p>仅仅只是声明端口。</p>
<p>作用：</p>
<p>1、帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</p>
<p>2、在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<p>3、可以是一个或者多个端口，也可以指定多个 EXPOSE</p>
<p>格式：EXPOSE &lt;端口 1&gt; [&lt;端口 2&gt;…]</p>
<p><strong>（5）CMD</strong></p>
<p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: </p>
<p>1、CMD 在 docker run 时运行。</p>
<p>2、RUN 是在 docker build 构建镜像时运行的</p>
<p>作用：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被</p>
<p>docker run 命令行参数中指定要运行的程序所覆盖。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash">[“executable”，“param1”，“param2”]（<span class="built_in">exec</span> 模式）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">command</span> （shell 模式）</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [“param1”,”param2”</span></span><br></pre></td></tr></table></figure>

<p>作为 ENTRYPOINT 指令的默认参数)</p>
<p>例：cd /root/dockerfile/test</p>
<p>cat dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#first dockerfile</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum clean all</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install nginx -y</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>构建镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;dockerfile/test-cmd:v1&quot; .</span><br></pre></td></tr></table></figure>

<p>基于上面构建的镜像运行一个容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80 --name cmd_test2 -d dockerfile/test-cmd:v1</span><br></pre></td></tr></table></figure>

<p>（不需要跟 nginx -g “daemon off；”了）</p>
<p>docker ps 可以看到下面信息</p>
<p>b903d5a71279 dockerfile/test-cmd:v1 “/usr/sbin/nginx -g …” 7 seconds ago Up 6 seconds 0.0.0.0:32770-&gt;80/tcp cmd_test2</p>
<p><strong>（6）ENTERYPOINT</strong></p>
<p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被</p>
<p>当作参数送给 ENTRYPOINT 指令指定的程序。</p>
<p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，将覆盖 entrypoint 指令指定的程序。</p>
<p><strong>优点：</strong>在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p><strong>注意：</strong>如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p>
<p><strong>格式：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTERYPOINT [“executable”,“param1”,“param2”](exec 模式)</span><br><span class="line">ENTERYPOINT command （<span class="keyword">shell</span><span class="language-bash"> 模式）</span></span><br></pre></td></tr></table></figure>

<p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下</p>
<p>示例会提到。</p>
<p>示例：</p>
<p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>] <span class="comment"># 定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>] <span class="comment"># 变参</span></span></span><br></pre></td></tr></table></figure>

<p>1、不传参运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run nginx:<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>

<p>容器内会默认运行以下命令，启动主进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>2、传参运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run nginx:<span class="built_in">test</span> -c /etc/nginx/new.conf</span></span><br></pre></td></tr></table></figure>

<p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p>
<p>nginx -c /etc/nginx/new.conf</p>
<p><strong>（7）COPY</strong></p>
<p>COPY<src>..<dest></p>
<p>COPY[“<src>”…“<dest>”]</p>
<p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p>
<p>格式：</p>
<p>COPY [–chown=<user>:<group>] &lt;源路径 1&gt;… &lt;目标路径&gt;</p>
<p>COPY [–chown=<user>:<group>] [“&lt;源路径 1&gt;”,… “&lt;目标路径&gt;”]</p>
<p>[–chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。</p>
<p>&lt;源路径&gt;：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match </p>
<p>规则。例如：</p>
<p>COPY hom* /mydir/</p>
<p>COPY hom?.txt /mydir/</p>
<p>&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p>
<p><strong>（8）ADD</strong></p>
<p>ADD <src>…<dest></p>
<p>ADD [“<src>”…“<dest>”]</p>
<p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p>
<p>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，</p>
<p>会自动复制并解压到 &lt;目标路径&gt;。</p>
<p>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像</p>
<p>构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</p>
<p>ADD vs COPY</p>
<p>ADD 包含类似 tar 的解压功能</p>
<p>如果单纯复制文件，dockerfile 推荐使用 COPY</p>
<p>例;替换/usr/share/nginx 下的 index.html</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root/dockerfile/test1</span><br><span class="line">cat dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install nginx -y</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>page added to dockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>i am in df_test <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;dockerfile/copy:v1&quot; .</span><br><span class="line">docker run -d -p 80 --name html3 dockerfile/copy:v1</span><br><span class="line">docker ps | grep html3</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<p>478868402ac4 dockerfile/copy:v1 “/usr/sbin/nginx -g …” 15 seconds ago Up 12 seconds 0.0.0.0:32771-&gt;80/tcp html3</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 192.168.40.180:32771</span><br></pre></td></tr></table></figure>

<p>显示的就是替换后的页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>page added to dockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>i am in df_test <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>（9）VOLUME</strong></p>
<p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p>
<p>作用：</p>
<p>1、避免重要的数据，因容器重启而丢失，这是非常致命的。</p>
<p>2、避免容器不断变大。</p>
<p>格式：</p>
<p>VOLUME [“&lt;路径 1&gt;”, “&lt;路径 2&gt;”…]</p>
<p>VOLUME &lt;路径&gt;</p>
<p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p>
<p>VOLUME [“/data”]</p>
<p><strong>（10）WORKDIR</strong></p>
<p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作</p>
<p>目录，必须是提前创建好的）。</p>
<p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才</p>
<p>会一直存在。</p>
<p>格式：</p>
<p>WORKDIR &lt;工作目录路径&gt;</p>
<p>WORKDIR /path/to/workdir</p>
<p>（填写绝对路径）</p>
<p><strong>(11 )ENV</strong></p>
<p>设置环境变量</p>
<p>ENV <key> <value></p>
<p>ENV <key>=<value>…</p>
<p>以下示例设置 NODE_VERSION =6.6.6， 在后续的指令中可以通过 $NODE_VERSION 引用：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">6.6</span>.<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz&quot;</span> \</span></span><br><span class="line"><span class="language-bash">&amp;&amp; curl -SLO <span class="string">&quot;https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>（12）USER</strong></p>
<p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已</p>
<p>经存在）。</p>
<p>格式：</p>
<p>USER &lt;用户名&gt;[:&lt;用户组&gt;]</p>
<p>USER daemon</p>
<p>USER nginx</p>
<p>USER user </p>
<p>USER uid</p>
<p>USER user:group </p>
<p>USER uid:gid</p>
<p>USER user:gid </p>
<p>USER uid:group</p>
<p><strong>（13）ONBUILD</strong></p>
<p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这时执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的ONBUILD 指定的命令。</p>
<p>格式：</p>
<p>ONBUILD &lt;其它指令&gt;</p>
<p>为镜像添加触发器</p>
<p>当一个镜像被其他镜像作为基础镜像时需要写上 OBNBUILD</p>
<p>会在构建时插入触发器指令</p>
<p>例：演示 ONBUILD 指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat index.html</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>page added to dockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>i am in df_test <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install nginx -y</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;onbuild-nginx:v1&quot; .</span><br><span class="line">docker run -d --name html4 -p 80 onbuild-nginx:v1</span><br><span class="line">docker ps | grep html4</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<p>65f4a5be9355 onbuild-nginx:v1 “/usr/sbin/nginx -g …” 14 seconds ago Up 11 seconds 0.0.0.0:32772-&gt;80/tcp html4</p>
<p>curl 192.168.40.180:32772</p>
<p>显示还是以前 nginx 默认的内容，没有被替换，表示 ONBUILD 这个指令后面的 COPY 没有生效</p>
<p>还是在刚在路径下构建新的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="keyword">onbuild</span>-nginx:v1</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;onbuild-nginx1&quot; .</span><br><span class="line">docker run -d --name htm5 -p 80 onbuild-nginx1</span><br><span class="line">docker ps | grep htm5</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<p>e56542310692 onbuild-nginx1 “/usr/sbin/nginx -g …” 12 seconds ago Up 8 seconds 0.0.0.0:32773-&gt;80/tcp htm5</p>
<p>curl 192.168.40.180:32773</p>
<p>显示如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>page added to dockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>i am in df_test <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示的就是已经重新构建的镜像，页面就是替换之后的了，说明我们基于 ONBUILD 指令的镜像作为基础</p>
<p>镜像，在构建镜像，会触发 ONBUILD 后面的 COPY 命令运行</p>
<p><strong>（14）LABEL</strong></p>
<p>LABEL 指令用来给镜像添加一些元数据（metadata），以键值对的形式，语法格式如下：</p>
<p>LABEL <key>=<value> <key>=<value> <key>=<value> …</p>
<p>比如我们可以添加镜像的作者：</p>
<p>LABEL org.opencontainers.image.authors=”xianchao” </p>
<p><strong>（15）HEALTHCHECK</strong></p>
<p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p>
<p>格式：</p>
<p>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</p>
<p>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p>
<p>HEALTHCHECK [选项] CMD &lt;命令&gt; : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</p>
<p><strong>（16）ARG</strong> </p>
<p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就</p>
<p>是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p>
<p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
<p>版权声明，本文档全部内容及版权归韩先超所有，只可用于自己学习使用，禁止私自传阅，违者依法</p>
<p>追责。韩先超老师微信：luckylucky421302</p>
<p>格式：</p>
<p>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p>
<h2 id="10、dockerfile-构建-nginx-镜像"><a href="#10、dockerfile-构建-nginx-镜像" class="headerlink" title="10、dockerfile 构建 nginx 镜像"></a>10、dockerfile 构建 nginx 镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir dockerfile</span><br><span class="line">cd dockerfile/</span><br><span class="line">vim dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget -y</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install nginx -y</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> index.html /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-g&quot;</span>,<span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>page added to dockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello，My Name is Xianchao,My wechat is luckylucky421302 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构建镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;xianchao/nginx:v1&quot; .</span><br></pre></td></tr></table></figure>

<p>查看镜像是否构建成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images | grep nginx</span><br></pre></td></tr></table></figure>

<p>显示如下说明镜像部署成功：</p>
<p>dockerfile/nginx latest baee97a76499 About a minute ago 344MB</p>
<p>基于刚才的镜像启动容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80 --name html2 xianchao/nginx:v1</span><br></pre></td></tr></table></figure>

<p>查看容器具体信息可按如下命令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 dockerfile]# docker ps | grep html</span><br><span class="line">bdbe140d5dc9 xianchao/nginx:v1 &quot;/usr/sbin/nginx -g …&quot; 17 seconds ago Up 15 seconds 0.0.0.0:49154-&gt;80/tcp, :::49154-&gt;80/tcp html2</span><br></pre></td></tr></table></figure>

<p>查看容器里部署的 nginx 网站的内容：</p>
<p>curl <a target="_blank" rel="noopener" href="http://192.168.40.180:49154/">http://192.168.40.180:49154</a></p>
<p>显示如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>page added to dockerfile<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello，My Name is Xianchao,My wechat is luckylucky421302 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：ENTRYPOINT [“/usr/sbin/nginx”,”-g”,”daemon off;”]</p>
<p>表示容器运行时，自动启动容器里的 nginx 服务</p>
<h2 id="11、dockerfile-构建-tomcat-镜像"><a href="#11、dockerfile-构建-tomcat-镜像" class="headerlink" title="11、dockerfile 构建 tomcat 镜像"></a>11、dockerfile 构建 tomcat 镜像</h2><p>下面需要的压缩包在下面需要的压缩包在课件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat8</span><br><span class="line">cd tomcat8</span><br></pre></td></tr></table></figure>

<p>把 apache-tomcat-8.0.26.tar.gz 和 jdk-8u45-linux-x64.rpm 传到这个目录下</p>
<p>ls 可以查看到 tomcat8 下面有如下几个文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget -y</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u45-linux-x64.rpm /usr/local/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-8.0.26.tar.gz /usr/local/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /usr/local &amp;&amp; rpm -ivh jdk-8u45-linux-x64.rpm</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mv</span> /usr/local/apache-tomcat-8.0.26 /usr/local/tomcat8</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p><strong>开始构建镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;tomcat8:v1&quot; .</span><br></pre></td></tr></table></figure>

<p><strong>运行一个容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name tomcat8 -itd -p 8080 tomcat8:v1 </span><br></pre></td></tr></table></figure>

<p><strong>进入到容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it tomcat8 /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>启动 tomcat</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/tomcat8/bin/startup.sh</span><br></pre></td></tr></table></figure>

<p><strong>查看进程，看看是否启动成功</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep tomcat</span><br></pre></td></tr></table></figure>

<p><strong>打开新的终端窗口，查看刚才创建的 tomcat8 这个容器的详细信息：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep tomcat</span><br></pre></td></tr></table></figure>

<p>显示如下信息</p>
<p>4d4c91cff4b5 tomcat8:v1 “/bin/bash” About a minute ago Up About a minute 0.0.0.0:32776-&gt;8080/tcp tomcat8</p>
<p>通过上面可以看到，tomcat 在宿主机上映射的端口是 32776</p>
<p>这样我们请求 docker 节点的 ip:32776，就可以访问到 tomcat 的内容了</p>
<p>通过这些步骤可以实现通过 dockerfile 构建 tomcat 镜像了</p>
<p>刚才我们在构建 tomcat 镜像时候，基于镜像运行容器，但是需要进入到容器，手动启动 tomcat 服务，</p>
<p>那如果想要启动容器，tomcat 也自动起来，需要按照如下方法构建镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xianchao</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install wget -y</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u45-linux-x64.rpm /usr/local/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-8.0.26.tar.gz /usr/local/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /usr/local &amp;&amp; rpm -ivh jdk-8u45-linux-x64.rpm</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mv</span> /usr/local/apache-tomcat-8.0.26 /usr/local/tomcat8</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> /usr/local/tomcat8/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/tomcat8/logs/catalina.out</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>作业：dockerfile 构建 PHP 镜像</p>
<p>或者把公司的项目做成镜像测试下</p>
<h2 id="12、Docker-容器的数据管理"><a href="#12、Docker-容器的数据管理" class="headerlink" title="12、Docker 容器的数据管理"></a>12、Docker 容器的数据管理</h2><p><strong>Docker 容器的数据卷</strong></p>
<p><strong>什么是数据卷？</strong></p>
<p>数据卷是经过特殊设计的目录，可以绕过联合文件系统（UFS），为一个或者多个容器提供访问，数据卷</p>
<p>设计的目的，在于数据的永久存储，它完全独立于容器的生存周期，因此，docker 不会在容器删除时删</p>
<p>除其挂载的数据卷，也不会存在类似的垃圾收集机制，对容器引用的数据卷进行处理，同一个数据卷可</p>
<p>以只支持多个容器的访问。</p>
<p><strong>数据卷的特点：</strong></p>
<ul>
<li>1.数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会被拷贝到新初始</li>
</ul>
<p>化的数据卷中</p>
<ul>
<li><p>2.数据卷可以在容器之间共享和重用</p>
</li>
<li><p>3.可以对数据卷里的内容直接进行修改</p>
</li>
<li><p>4.数据卷的变化不会影像镜像的更新</p>
</li>
<li><p>5.卷会一直存在，即使挂载数据卷的容器已经被删除</p>
</li>
</ul>
<p><strong>数据卷的使用：</strong></p>
<ul>
<li>1.为容器添加数据卷</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /datavolume:/data -it centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name volume -v ~/datavolume:/data -itd centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>注：~/datavolume 为宿主机目录，/data 为 docker 启动的 volume 容器的里的目录</p>
<p>这样在宿主机的/datavolume 目录下创建的数据就会同步到容器的/data 目录下</p>
<p>（1）为数据卷添加访问权限</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name volume1 -v ~<span class="regexp">/datavolume1:/</span>data:ro -itd centos <span class="regexp">/bin/</span>bash</span><br></pre></td></tr></table></figure>

<p>添加只读权限之后在 docker 容器的/data 目录下就不能在创建文件了，为只读权限；在宿主机下的</p>
<p>/datavolume1 下可以创建东西</p>
<ul>
<li>2.使用 dockerfile 构建包含数据卷的镜像</li>
</ul>
<p>dockerfile 指令：</p>
<p>volume[“/data”]</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/datavolume3&quot;,&quot;/datavolume6&quot;]</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>使用如下构建镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;volume&quot; .</span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name volume-dubble -it volume</span><br></pre></td></tr></table></figure>

<p>会看到这个容器下有两个目录，/datavolume3 和/datavolume6</p>
<h2 id="13、Docker-的数据卷容器"><a href="#13、Docker-的数据卷容器" class="headerlink" title="13、Docker 的数据卷容器"></a>13、Docker 的数据卷容器</h2><p><strong>什么是数据卷容器?：</strong></p>
<p>命名的容器挂载数据卷，其他容器通过挂载这个容器实现数据共享，挂载数据卷的容器，就叫做数据卷</p>
<p>容器挂载数据卷容器的方法</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name]</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name data-volume -itd volume（volume 这个镜像是上面创建的带两个数据卷/datavolume3 和/ddatavolume6 的镜像）</span><br><span class="line">docker exec -it data-volume /bin/bash（进入到容器中）</span><br><span class="line">touch /datavolume6/lucky.txt</span><br></pre></td></tr></table></figure>

<p>退出容器 </p>
<p>exit</p>
<p>创建一个新容器挂载刚才 data-volume 这个容器创建的数据卷</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name data-volume2 --volumes-from data-volume -itd centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>进入到新创建的容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it data-volume2 /bin/bash</span><br></pre></td></tr></table></figure>

<p>查看容器的/datavolume6 目录下是否新创建了 lucky.txt 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /datavolume6</span><br></pre></td></tr></table></figure>

<p>可以看见有刚才在上一个容器创建的文件 lucky.txt</p>
<h2 id="14、docker-数据卷的备份和还原"><a href="#14、docker-数据卷的备份和还原" class="headerlink" title="14、docker 数据卷的备份和还原"></a>14、docker 数据卷的备份和还原</h2><p>数据备份方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name] -v $(pwd):/backup centos tar czvf /backup/backup.tar [container data volume]</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from data-volume2 -v /root/backup:/backup --name datavolume-copy centos tar zcvf /backup/data-volume2.tar.gz /datavolume6</span><br></pre></td></tr></table></figure>

<p>数据还原方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from [container name] -v $(pwd):/backup centos tar xzvf /backup/backup.tar.gz [container data volume]</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it data-volume2 /bin/bash</span><br><span class="line">cd /datavolume6</span><br><span class="line">rm -rf lucky.txt</span><br><span class="line">docker run --volumes-from data-volume2 -v /root/backup/:/backup centos tar zxvf /backup/data-volume2.tar.gz -C /datavolume6</span><br><span class="line">docker exec -it data-volum2 /bin/bash</span><br><span class="line">cd /datavolum6</span><br></pre></td></tr></table></figure>

<p>可以看到还原后的数据</p>
<h2 id="15、docker-容器互联"><a href="#15、docker-容器互联" class="headerlink" title="15、docker 容器互联"></a>15、docker 容器互联</h2><p>docker run 创建 Docker 容器时，可以用–net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p>
<p>bridge 模式：使–net =bridge 指定，默认设置；</p>
<p>host 模式：使–net =host 指定；</p>
<p>none 模式：使–net =none 指定；</p>
<p>container 模式：使用–net =container:NAME orID 指定。</p>
<h3 id="15-1-docker-容器的网络基础"><a href="#15-1-docker-容器的网络基础" class="headerlink" title="15.1 docker 容器的网络基础"></a>15.1 docker 容器的网络基础</h3><p>1、docker0：</p>
<p>安装 docker 的时候，会生成一个 docker0 的虚拟网桥</p>
<p>2、Linux 虚拟网桥的特点：</p>
<p>可以设置 ip 地址</p>
<p>相当于拥有一个隐藏的虚拟网卡</p>
<p>docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default </p>
<p>link/ether 02:42:28:ae:c0:42 brd ff:ff:ff:ff:ff:ff</p>
<p>inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</p>
<p>valid_lft forever preferred_lft forever</p>
<p>inet6 fe80::42:28ff:feae:c042/64 scope link</p>
<p>每运行一个 docker 容器都会生成一个 veth 设备对，这个 veth 一个接口在容器里，一个接口在物理机</p>
<p>上。</p>
<p>3、安装网桥管理工具：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bridge-utils -y</span><br></pre></td></tr></table></figure>

<p>brctl show 可以查看到有一个 docker0 的网桥设备，下面有很多接口，每个接口都表示一个启动的</p>
<p>docker 容器，因为我在 docker 上启动了很多容器，所以 interfaces 较多，如下所示：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501180657360.png" alt="image-20220501180657360"></p>
<h3 id="15-2-docker-容器的互联"><a href="#15-2-docker-容器的互联" class="headerlink" title="15.2 docker 容器的互联"></a>15.2 docker 容器的互联</h3><p>下面用到的镜像的 dockerfile 文件如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd dockerfile/inter-image</span><br><span class="line">vim dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget -y</span><br><span class="line">RUN yum install nginx -y</span><br><span class="line">RUN sed -i &quot;7s/^/#/g&quot; /etc/nginx/conf.d/default.conf</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@xianchaomaster1]# </span><span class="language-bash">docker build -t=<span class="string">&quot;inter-image&quot;</span> .</span></span><br></pre></td></tr></table></figure>

<p>允许所有容器间互联（也就是访问）</p>
<p>第一种方法：</p>
<p>例：</p>
<p>（1）基于上面的 inter-image 镜像启动第一个容器 test1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test1 -itd inter-image</span><br></pre></td></tr></table></figure>

<p>进入到容器里面启动 nginx：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/ngnx</span><br></pre></td></tr></table></figure>

<p>（2）基于上面的 inter-image 镜像启动第二个容器 test2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test2 -itd inter-image</span><br></pre></td></tr></table></figure>

<p>（3）进入到 test1 容器和 test2 容器，可以看两个容器的 ip，分别是</p>
<p>172.17.0.20 和 172.17.0.21</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it test2 /bin/bash</span><br></pre></td></tr></table></figure>

<p>ping 172.17.0.20 可以看见能 ping 同 test1 容器的 ip</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://172.17.0.20 </span><br></pre></td></tr></table></figure>

<p>可以访问到 test1 容器的内容</p>
<p>上述方法假如 test1 容器重启，那么在启动就会重新分配 ip 地址，所以为了使 ip 地址变了也可以访问</p>
<p>可以采用下面的方法</p>
<h4 id="15-2-1-docker-link-设置网络别名"><a href="#15-2-1-docker-link-设置网络别名" class="headerlink" title="15.2.1 docker link 设置网络别名"></a>15.2.1 docker link 设置网络别名</h4><p>第二种方法：</p>
<p>可以给容器起一个代号，这样可以直接以代号访问，避免了容器重启 ip 变化带来的问题</p>
<p>–link</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --link=[CONTAINER_NAME]:[ALIAS] [IMAGE][COMMAND]</span><br></pre></td></tr></table></figure>

<p>例：</p>
<p>1.启动一个 test3 容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test3 -itd inter-image /bin/bash</span><br></pre></td></tr></table></figure>

<p>2.启动一个 test5 容器，–link 做链接，那么当我们重新启动 test3 容器时，就算 ip 变了，也没关系，</p>
<p>我们可以在 test5 上 ping 别名 webtest</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test5 -itd --link=test3:webtest inter-image /bin/bash</span><br></pre></td></tr></table></figure>

<p>3.test3 和 test5 的 ip 分别是 172.17.0.22 和 172.17.0.24</p>
<p>4.重启 test3 容器</p>
<p>docker restart test3</p>
<p>发现 ip 变成了 172.17.0.25</p>
<p>5.进入到 test5 容器</p>
<p>docker exec -it test5 /bin/bash</p>
<p>ping test3 容器的 ip 别名 webtest 可以 ping 通，尽管 test3 容器的 ip 变了也可以通</p>
<h2 id="16、docker-容器的网络模式"><a href="#16、docker-容器的网络模式" class="headerlink" title="16、docker 容器的网络模式"></a>16、docker 容器的网络模式</h2><p>docker run 创建 docker 容器时，可以用–net 选项指定容器的网络模式，Docker 有以下 4 种网络模式：</p>
<p>bridge 模式：使–net =bridge 指定，默认设置；</p>
<p>host 模式：使–net =host 指定；</p>
<p>none 模式：使–net =none 指定；</p>
<p>container 模式：使用–net =container:NAME orID 指定。</p>
<h3 id="16-1-none-模式"><a href="#16-1-none-模式" class="headerlink" title="16.1 none 模式"></a>16.1 none 模式</h3><p>Docker 网络 none 模式是指创建的容器没有网络地址，只有 lo 网卡</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -itd --name none --net=none --privileged=true centos </span><br><span class="line">[root@xianchaomaster1 ~]# docker exec -it none /bin/bash</span><br><span class="line">[root@05dbf3f2daaf /]# ip addr</span><br></pre></td></tr></table></figure>

<p>#只有本地 lo 地址</p>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</p>
<p>link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
<p>inet 127.0.0.1/8 scope host lo</p>
<p>valid_lft forever preferred_lft forever</p>
<h3 id="16-2-container-模式"><a href="#16-2-container-模式" class="headerlink" title="16.2 container 模式"></a>16.2 container 模式</h3><p>Docker 网络 container 模式是指，创建新容器的时候，通过–net container 参数，指定其和已经存在的某个容器共享一个 Network Namespace。如下图所示，右方黄色新创建的 container，其网卡共享左边容器。因此就不会拥有自己独立的 IP，而是共享左边容器的 IP 172.17.0.2,端口范围等网络资源，两个容器的进程通过 lo 网卡设备通信。</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501174715992.png"></p>
<p>#和已经存在的 none 容器共享网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --name container2 --net=container:none -it --privileged=true centos</span><br><span class="line">[root@05dbf3f2daaf /]# ip addr</span><br><span class="line">	1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">	inet 127.0.0.1/8 scope host lo</span><br><span class="line">	valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<h3 id="16-3-bridge-模式"><a href="#16-3-bridge-模式" class="headerlink" title="16.3 bridge 模式"></a>16.3 bridge 模式</h3><p>默认选择 bridge 的情况下，容器启动后会通过 DHCP 获取一个地址</p>
<p>#创建桥接网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@xianchaomaster1~]# </span><span class="language-bash">docker run --name bridge -it --privileged=<span class="literal">true</span> centos bash</span></span><br><span class="line">[root@a131580fb605 /]# ip addr</span><br><span class="line">  1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen </span><br><span class="line">  1000</span><br><span class="line">  link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">  inet 127.0.0.1/8 scope host lo</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br><span class="line">  64: eth0@if65: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group </span><br><span class="line">  default link/ether 02:42:ac:11:00:0d brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">  inet 172.17.0.13/16 brd 172.17.255.255 scope global eth0</span><br><span class="line">  valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>



<h3 id="16-4-host-模式"><a href="#16-4-host-模式" class="headerlink" title="16.4 host 模式"></a>16.4 host 模式</h3><p>Docker 网络 host 模式是指共享宿主机的网络</p>
<p>#共享宿主机网络</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@xianchaomaster1~]# </span><span class="language-bash">docker run --name host -it --net=host --privileged=<span class="literal">true</span> centos bash</span></span><br></pre></td></tr></table></figure>



<h2 id="17、docker-资源配额"><a href="#17、docker-资源配额" class="headerlink" title="17、docker 资源配额"></a>17、docker 资源配额</h2><h3 id="17-1-docker-容器控制-cpu"><a href="#17-1-docker-容器控制-cpu" class="headerlink" title="17.1 docker 容器控制 cpu"></a>17.1 docker 容器控制 cpu</h3><p>Docker 通过 cgroup 来控制容器使用的资源限制，可以对 docker 限制的资源包括 CPU、内存、磁盘</p>
<h4 id="17-1-1-指定-docker-容器可以使用的-cpu-份额"><a href="#17-1-1-指定-docker-容器可以使用的-cpu-份额" class="headerlink" title="17.1.1 指定 docker 容器可以使用的 cpu 份额"></a>17.1.1 指定 docker 容器可以使用的 cpu 份额</h4><p>#查看配置份额的帮助命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --help | grep cpu-shares</span><br></pre></td></tr></table></figure>

<p>cpu 配额参数：-c, –cpu-shares int </p>
<p>CPU shares (relative weight) 在创建容器时指定容器所使用的 CPU 份额值。cpu-shares 的值不能</p>
<p>保证可以获得 1 个 vcpu 或者多少 GHz 的 CPU 资源，仅仅只是一个弹性的加权值。</p>
<p>默认每个 docker 容器的 cpu 份额值都是 1024。在同一个 CPU 核心上，同时运行多个容器时，容器的</p>
<p>cpu 加权的效果才能体现出来。</p>
<p>例： 两个容器 A、B 的 cpu 份额分别为 1000 和 500，结果会怎么样？</p>
<p>情况 1：A 和 B 正常运行，占用同一个 CPU，在 cpu 进行时间片分配的时候，容器 A 比容器 B 多一倍</p>
<p>的机会获得 CPU 的时间片。</p>
<p>情况 2：分配的结果取决于当时其他容器的运行状态。比如容器 A 的进程一直是空闲的，那么容器 B</p>
<p>是可以获取比容器 A 更多的 CPU 时间片的； 比如主机上只运行了一个容器，即使它的 cpu 份额只有</p>
<p>50，它也可以独占整个主机的 cpu 资源。</p>
<p>cgroups 只在多个容器同时争抢同一个 cpu 资源时，cpu 配额才会生效。因此，无法单纯根据某个容</p>
<p>器的 cpu 份额来确定有多少 cpu 资源分配给它，资源分配结果取决于同时运行的其他容器的 cpu 分</p>
<p>配和容器中进程运行情况。 </p>
<p>例 1：给容器实例分配 512 权重的 cpu 使用份额</p>
<p>参数： –cpu-shares 512</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -it --cpu-shares <span class="number">512</span> centos <span class="regexp">/bin/</span>bash</span><br><span class="line">[root@df176dd75bd4 <span class="regexp">/]# cat /</span>sys<span class="regexp">/fs/</span>cgroup<span class="regexp">/cpu/</span>cpu.shares</span><br></pre></td></tr></table></figure>

<p>#查看结果：</p>
<p>512</p>
<p>注：稍后，我们启动多个容器，测试一下是不是只能使用 512 份额的 cpu 资源。单独一个容器，看</p>
<p>不出来使用的 cpu 的比例。 因没有 docker 实例同此 docker 实例竞争。</p>
<p>总结：</p>
<p>通过-c 设置的 cpu share 并不是 CPU 资源的绝对数量，而是一个相对的权重值。某个容器最终能</p>
<p>分配到的 CPU 资源取决于它的 cpu share 占所有容器 cpu share 总和的比例。通过 cpu share </p>
<p>可以设置容器使用 CPU 的优先级。</p>
<p>比如在 host 中启动了两个容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name &quot;container_A&quot; -c 1024 ubuntu</span><br><span class="line">docker run --name &quot;container_B&quot; -c 512 ubuntu</span><br></pre></td></tr></table></figure>

<p>container_A 的 cpu share 1024，是 container_B 的两倍。当两个容器都需要 CPU 资源时，</p>
<p>container_A 可以得到的 CPU 是 container_B 的两倍。</p>
<p>需要注意的是，这种按权重分配 CPU 只会发生在 CPU 资源紧张的情况下。如果 container_A 处于空</p>
<p>闲状态，为了充分利用 CPU 资源，container_B 也可以分配到全部可用的 CPU。</p>
<h4 id="17-1-2-CPU-core-核心控制"><a href="#17-1-2-CPU-core-核心控制" class="headerlink" title="17.1.2 CPU core 核心控制"></a>17.1.2 CPU core 核心控制</h4><p>参数：–cpuset 可以绑定 CPU</p>
<p>对多核 CPU 的服务器，docker 还可以控制容器运行限定使用哪些 cpu 内核和内存节点，即使用–</p>
<p>cpuset-cpus 和–cpuset-mems 参数。对具有 NUMA 拓扑（具有多 CPU、多内存节点）的服务器尤其有</p>
<p>用，可以对需要高性能计算的容器进行性能最优的配置。如果服务器只有一个内存节点，则–</p>
<p>cpuset-mems 的配置基本上不会有明显效果。</p>
<p>扩展：</p>
<p>服务器架构一般分： SMP、NUMA、MPP 体系结构介绍</p>
<p>从系统架构来看，目前的商用服务器大体可以分为三类：</p>
<ol>
<li>即对称多处理器结构(SMP ： Symmetric Multi-Processor) 例： x86 服务器，双路服务</li>
</ol>
<p>器。主板上有两个物理 cpu</p>
<ol start="2">
<li>非一致存储访问结构 (NUMA ： Non-Uniform Memory Access) 例： IBM 小型机</li>
</ol>
<p>pSeries 690</p>
<ol start="3">
<li>海量并行处理结构 (MPP ： Massive ParallelProcessing) 。 例： 大型机 Z14</li>
</ol>
<h4 id="17-1-3-CPU-配额控制参数的混合使用"><a href="#17-1-3-CPU-配额控制参数的混合使用" class="headerlink" title="17.1.3 CPU 配额控制参数的混合使用"></a>17.1.3 CPU 配额控制参数的混合使用</h4><p>在上面这些参数中，cpu-shares 控制只发生在容器竞争同一个 cpu 的时间片时有效。</p>
<p>如果通过 cpuset-cpus 指定容器 A 使用 cpu 0，容器 B 只是用 cpu1，在主机上只有这两个容器使用</p>
<p>对应内核的情况，它们各自占用全部的内核资源，cpu-shares 没有明显效果。</p>
<p>如何才能有效果？韩先超老师微信：luckylucky421302</p>
<p>版权声明，本文档全部内容及版权归韩先超所有，只可用于自己学习使用，禁止私自传阅，违者依法</p>
<p>追责。</p>
<p>容器 A 和容器 B 配置上 cpuset-cpus 值并都绑定到同一个 cpu 上，然后同时抢占 cpu 资源，就可以</p>
<p>看出效果了。</p>
<p>例 1：测试 cpu-shares 和 cpuset-cpus 混合使用运行效果，就需要一个压缩力测试工具 stress 来让</p>
<p>容器实例把 cpu 跑满。</p>
<p>如何把 cpu 跑满？</p>
<p>如何把 4 核心的 cpu 中第一和第三核心跑满？可以运行 stress，然后使用 taskset 绑定一下 cpu。</p>
<p>先扩展：stress 命令</p>
<p>概述：linux 系统压力测试软件 Stress 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# yum install -y epel-release</span><br><span class="line">[root@xianchaomaster1 ~]# yum install stress -y </span><br></pre></td></tr></table></figure>

<p>stress 参数解释</p>
<p>-? 显示帮助信息</p>
<p>-v 显示版本号</p>
<p>-q 不显示运行信息</p>
<p>-n 显示已完成的指令情况</p>
<p>-t –timeout N 指定运行 N 秒后停止</p>
<p>–backoff N 等待 N 微妙后开始运行 </p>
<p>-c 产生 n 个进程 ：每个进程都反复不停的计算随机数的平方根，测试 cpu</p>
<p>-i 产生 n 个进程 ：每个进程反复调用 sync()，sync()用于将内存上的内容写到硬</p>
<p>盘上，测试磁盘 io</p>
<p>-m –vm n 产生 n 个进程,每个进程不断调用内存分配 malloc（）和内存释放 free（）函 </p>
<p>数 ，测试内存</p>
<p>–vm-bytes B 指定 malloc 时内存的字节数 （默认 256MB）</p>
<p>–vm-hang N 指定在 free 栈的秒数</p>
<p>-d –hadd n 产生 n 个执行 write 和 unlink 函数的进程</p>
<p>-hadd-bytes B 指定写的字节数</p>
<p>–hadd-noclean 不 unlink</p>
<p>注：时间单位可以为秒 s，分 m，小时 h，天 d，年 y，文件大小单位可以为 K，M，G </p>
<p>例 1：产生 2 个 cpu 进程，2 个 io 进程，20 秒后停止运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@xianchaomaster1]# </span><span class="language-bash">stress -c 2 -i 2 --verbose --<span class="built_in">timeout</span> 20s</span> </span><br></pre></td></tr></table></figure>

<p>#如果执行时间为分钟，改 20s 为 1m</p>
<p>查看：</p>
<p>top</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175009431.png" alt="image-20220501175009431"></p>
<p>例 1：测试 cpuset-cpus 和 cpu-shares 混合使用运行效果，就需要一个压缩力测试工具 stress 来让</p>
<p>容器实例把 cpu 跑满。 当跑满后，会不会去其他 cpu 上运行。 如果没有在其他 cpu 上运行，说明</p>
<p>cgroup 资源限制成功。</p>
<p>实例 3：创建两个容器实例:docker10 和 docker20。 让 docker10 和 docker20 只运行在 cpu0 和 </p>
<p>cpu1 上，最终测试一下 docker10 和 docker20 使用 cpu 的百分比。实验拓扑图如下：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175033352.png" alt="image-20220501175033352"></p>
<p>运行两个容器实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -itd --name docker10 --cpuset-cpus 0,1 --cpu-shares 512 centos /bin/bash </span><br></pre></td></tr></table></figure>

<p>#指定 docker10 只能在 cpu0 和 cpu1 上运行，而且 docker10 的使用 cpu 的份额 512</p>
<p>#参数-itd 就是又能打开一个伪终端，又可以在后台运行着 docker 实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -itd --name docker20 --cpuset-cpus 0,1 --cpu-shares 1024 centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>#指定 docker20 只能在 cpu0 和 cpu1 上运行，而且 docker20 的使用 cpu 的份额 1024，比 dcker10 多</p>
<p>一倍</p>
<p>测试 1： 进入 docker10，使用 stress 测试进程是不是只在 cpu0,1 上运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker exec -it docker10 /bin/bash</span><br><span class="line">[root@d1a431815090 /]# yum install -y epel-release #安装 epel 扩展源</span><br><span class="line">[root@d1a431815090 /]# yum install stress -y #安装 stress 命令</span><br><span class="line">[root@d1a431815090 /]# stress -c 2 -v -t 10m #运行 2 个进程，把两个 cpu 占满</span><br></pre></td></tr></table></figure>

<p>在物理机另外一个虚拟终端上运行 top 命令，按 1 快捷键，查看每个 cpu 使用情况：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175116301.png" alt="image-20220501175116301"></p>
<p>可看到正常。只在 cpu0,1 上运行</p>
<p>测试 2： 然后进入 docker20，使用 stress 测试进程是不是只在 cpu0,1 上运行，且 docker20 上运行</p>
<p>的 stress 使用 cpu 百分比是 docker10 的 2 倍</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker exec -it docker20 /bin/bash</span><br><span class="line">[root@d1a431815090 /]# yum install -y epel-release #安装 epel 扩展源</span><br><span class="line">[root@d1a431815090 /]# yum install stress -y </span><br><span class="line">[root@f24e75bca5c0 /]# stress -c 2 -v -t 10m</span><br></pre></td></tr></table></figure>

<p>在另外一个虚拟终端上运行 top 命令，按 1 快捷键，查看每个 cpu 使用情况：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175133955.png" alt="image-20220501175133955"></p>
<p>注：两个容器只在 cpu0,1 上运行，说明 cpu 绑定限制成功。而 docker20 是 docker10 使用 cpu 的 2</p>
<p>倍。说明–cpu-shares 限制资源成功。</p>
<h3 id="17-2-docker-容器控制内存"><a href="#17-2-docker-容器控制内存" class="headerlink" title="17.2 docker 容器控制内存"></a>17.2 docker 容器控制内存</h3><p>Docker 提供参数-m, –memory=””限制容器的内存使用量。</p>
<p>例 1：允许容器使用的内存上限为 128M：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -it -m 128m centos</span><br></pre></td></tr></table></figure>

<p>查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@40bf29765691 /]# cat /sys/fs/cgroup/memory/memory.limit_in_bytes </span><br></pre></td></tr></table></figure>

<p>134217728</p>
<p>注：也可以使用 tress 进行测试，到现在，我可以限制 docker 实例使用 cpu 的核心数和权重，可以</p>
<p>限制内存大小。</p>
<p>例 2：创建一个 docker，只使用 2 个 cpu 核心，只能使用 128M 内存</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -it --cpuset-cpus 0,1 -m 128m centos </span><br></pre></td></tr></table></figure>

<p>17.3 docker 容器控制 IO</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --help | grep write-b</span><br></pre></td></tr></table></figure>

<p>–device-write-bps value Limit write rate (bytes per second) to a device </p>
<p>(default [])</p>
<p>#限制此设备上的写速度（bytes per second），单位可以是 kb、mb 或者 gb。</p>
<p>–device-read-bps value #限制此设备上的读速度（bytes per second），单位可以是 kb、mb 或 </p>
<p>者 gb。</p>
<p>情景：防止某个 Docker 容器吃光你的磁盘 I / O 资源</p>
<p>例 1：限制容器实例对硬盘的最高写入速度设定为 2MB/s。</p>
<p>–device 参数：将主机设备添加到容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# mkdir -p /var/www/html/</span><br><span class="line">[root@xianchaomaster1 ~]# docker run -it -v /var/www/html/:/var/www/html --device /dev/sda:/dev/sda --device-write-bps /dev/sda:2mb centos /bin/bash</span><br><span class="line">[root@bd79042dbdc9 /]# time dd if=/dev/sda of=/var/www/html/test.out bs=2M count=50 oflag=direct,nonblock</span><br></pre></td></tr></table></figure>

<p>注：dd 参数：</p>
<p>direct：读写数据采用直接 IO 方式，不走缓存。直接从内存写硬盘上。</p>
<p>nonblock：读写数据采用非阻塞 IO 方式，优先写 dd 命令的数据</p>
<p>50+0 records in</p>
<p>50+0 records out</p>
<p>52428800 bytes (52 MB) copied, 50.1831 s, 2.0 MB/s</p>
<p>real 0m50.201s</p>
<p>user 0m0.001s</p>
<p>sys 0m0.303s</p>
<p>注： 发现 1 秒写 2M。 限制成功。</p>
<p>docker 容器运行结束自动释放资源</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run --help | grep rm</span><br></pre></td></tr></table></figure>

<p>–rm 参数： Automatically remove the container when it exits</p>
<p>作用：当容器命令运行结束后，自动删除容器，自动释放资源</p>
<p>例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker run -it --rm --name xianchao centos sleep 6</span><br></pre></td></tr></table></figure>

<p>物理上查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker ps -a | grep xianchao</span><br></pre></td></tr></table></figure>

<p>6c75a9317a6b centos “sleep 6” 6 seconds ago Up 4 </p>
<p>seconds mk韩先超老师微信：luckylucky421302</p>
<p>等 5s 后，再查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker ps | grep xianchao</span><br></pre></td></tr></table></figure>

<p> #自动删除了</p>
<h2 id="18、docker-私有镜像仓库-harbor"><a href="#18、docker-私有镜像仓库-harbor" class="headerlink" title="18、docker 私有镜像仓库 harbor"></a>18、docker 私有镜像仓库 harbor</h2><p>Harbor 介绍</p>
<p>Docker 容器应用的开发和运行离不开可靠的镜像管理，虽然 Docker 官方也提供了公共的镜像仓库，</p>
<p>但是从安全和效率等方面考虑，部署我们私有环境内的 Registry 也是非常必要的。Harbor 是由 VMware</p>
<p>公司开源的企业级的 Docker Registry 管理项目，它包括权限管理(RBAC)、LDAP、日志审核、管理界面、</p>
<p>自我注册、镜像复制和中文支持等功能。</p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor">https://github.com/goharbor/harbor</a></p>
<p>实验环境：</p>
<p>安装 harbor 的机器，主机名设置成 harbor</p>
<p>机器需要的内存至少要 2G，我分配的是 4G</p>
<p>机器 ip：192.168.40.181</p>
<p>4vCPU/4G 内存/100G 硬盘</p>
<h3 id="18-1-为-Harbor-自签发证书"><a href="#18-1-为-Harbor-自签发证书" class="headerlink" title="18.1 为 Harbor 自签发证书"></a>18.1 为 Harbor 自签发证书</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]# hostnamectl set-hostname harbor &amp;&amp; bash</span><br><span class="line">[root@harbor ~]# mkdir /data/ssl -p</span><br><span class="line">[root@harbor ~]# cd /data/ssl/</span><br></pre></td></tr></table></figure>

<p>生成 ca 证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out ca.key 3072</span><br></pre></td></tr></table></figure>

<p>#生成一个 3072 位的 key，也就是私钥</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -days 3650 -key ca.key -out ca.pem</span><br></pre></td></tr></table></figure>

<p>#生成一个数字证书 ca.pem，3650 表示证书的有效时间是 3 年，按箭头提示填写即可，没有箭头标注的为</p>
<p>空：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175242084.png" alt="image-20220501175242084"></p>
<p>生成域名的证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out harbor.key 3072</span><br></pre></td></tr></table></figure>

<p>#生成一个 3072 位的 key，也就是私钥</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key harbor.key -out harbor.csr</span><br></pre></td></tr></table></figure>

<p>#生成一个证书请求，一会签发证书时需要的，标箭头的按提示填写，没有箭头标注的为空：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175304263.png" alt="image-20220501175304263"></p>
<p>签发证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in harbor.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out harbor.pem -days 3650</span><br></pre></td></tr></table></figure>

<p>显示如下，说明证书签发好了：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175329604.png" alt="image-20220501175329604"></p>
<h3 id="18-2-安装-Harbor"><a href="#18-2-安装-Harbor" class="headerlink" title="18.2 安装 Harbor"></a>18.2 安装 Harbor</h3><h4 id="18-2-1-安装-Docker"><a href="#18-2-1-安装-Docker" class="headerlink" title="18.2.1 安装 Docker"></a>18.2.1 安装 Docker</h4><p>关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# systemctl stop firewalld &amp;&amp; systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p>关闭 iptables 防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# yum install iptables-services -y #安装 iptables</span><br></pre></td></tr></table></figure>

<p>禁用 iptables</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ harbor~]# service iptables stop &amp;&amp; systemctl disable iptables</span><br></pre></td></tr></table></figure>

<p>清空防火墙规则</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# iptables -F</span><br></pre></td></tr></table></figure>

<p>关闭 selinux</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# setenforce 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[root@harbor~]# </span><span class="language-bash">sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/selinux/config</span></span><br></pre></td></tr></table></figure>

<p>注意：修改 selinux 配置文件之后，重启机器，selinux 才能永久生效</p>
<p>#配置时间同步</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@harbor~]# </span><span class="language-bash">yum install -y ntp ntpdate</span></span><br><span class="line">[root@xianchaomaster1 ~]# ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>

<p>#编写计划任务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@harbor~]# </span><span class="language-bash">crontab -e</span></span><br><span class="line">* \*/1 \* \* \* /usr/sbin/ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure>

<p>重启 crond 服务使配置生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# systemctl restart crond</span><br></pre></td></tr></table></figure>

<p>配置 hosts 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# cat /etc/hosts</span><br><span class="line">127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1 localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.40.180 xianchaomaster1</span><br><span class="line">192.168.40.181 harbor</span><br><span class="line"></span><br><span class="line">[root@harbor harbor]# cat /etc/hosts</span><br><span class="line">127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1 localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.40.180 xianchaomaster1</span><br><span class="line">192.168.40.181 harbor</span><br></pre></td></tr></table></figure>

<p>安装基础软件包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# yum install -y wget net-tools nfs-utils lrzsz gcc gcc-c++ make cmake libxml2-devel openssl-devel curl curl-devel unzip sudo ntp libaio-devel wget vim ncurses-devel autoconf automake zlib-devel python-devel epel-release openssh-server socat ipvsadm conntrack </span><br></pre></td></tr></table></figure>

<p>#安装 docker-ce</p>
<p>配置 docker-ce 国内 yum 源（阿里云）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<p>安装 docker 依赖包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>安装 docker-ce</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[root@ harbor~]</span><span class="comment"># yum install docker-ce -y</span></span><br></pre></td></tr></table></figure>

<p>#启动 docker 服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# systemctl start docker &amp;&amp; systemctl enable docker</span><br><span class="line">[root@ harbor~]# systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: </span><br><span class="line">disabled)</span><br><span class="line">Active: active (running) since Thu 2021-07-01 21:29:18 CST; 30s ago</span><br><span class="line">Docs: https://docs.docker.com</span><br></pre></td></tr></table></figure>

<p>看到 running，表示 docker 正常运行</p>
<p>#查看 Docker 版本信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# docker version </span><br></pre></td></tr></table></figure>

<h4 id="18-2-2-开启包转发功能和修改内核参数"><a href="#18-2-2-开启包转发功能和修改内核参数" class="headerlink" title="18.2.2 开启包转发功能和修改内核参数"></a>18.2.2 开启包转发功能和修改内核参数</h4><p>内核参数修改：br_netfilter 模块用于将桥接流量转发至 iptables 链，br_netfilter 内核参数需要开</p>
<p>启转发。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@ harbor~]# modprobe br_netfilter</span><br><span class="line">[root@ harbor~]# cat &gt; /etc/sysctl.d/docker.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line">[root@harbor ~]# sysctl -p /etc/sysctl.d/docker.conf</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>Docker 安装后出现：WARNING: bridge-nf-call-iptables is disabled 的解决办法：</p>
<p>net.bridge.bridge-nf-call-ip6tables = 1</p>
<p>net.bridge.bridge-nf-call-iptables = 1</p>
<p>net.ipv4.ip_forward = 1： </p>
<p>将 Linux 系统作为路由或者 VPN 服务就必须要开启 IP 转发功能。当 linux 主机有多个网卡时一个网卡收</p>
<p>到的信息是否能够传递给其他的网卡 如果设置成 1 的话 可以进行数据包转发，可以实现 VxLAN 等功</p>
<p>能。不开启会导致 docker 部署应用无法访问。</p>
<p>#重启 docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# systemctl restart docker</span><br><span class="line">[root@xianchaomaster1 ~]# scp /etc/docker/daemon.json 192.168.40.181:/etc/docker/</span><br><span class="line">[root@harbor ~]# systemctl daemon-reload</span><br><span class="line">[root@harbor ~]# systemctl restart docker</span><br></pre></td></tr></table></figure>



<h4 id="18-2-4-安装-harbor"><a href="#18-2-4-安装-harbor" class="headerlink" title="18.2.4 安装 harbor"></a>18.2.4 安装 harbor</h4><p>创建安装目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@harbor ssl]# mkdir /data/install -p</span><br><span class="line">[root@harbor ssl]# cd /data/install/</span><br></pre></td></tr></table></figure>

<p>安装 harbor</p>
<p>/data/ssl 目录下有如下文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ca.key ca.pem ca.srl harbor.csr harbor.key harbor.pem</span><br><span class="line">[root@harbor install]# cd /data/install/</span><br></pre></td></tr></table></figure>

<p>#把 harbor 的离线包 harbor-offline-installer-v2.3.0-rc3.tgz 上传到这个目录，离线包在课件</p>
<p>里提供了</p>
<p>下载 harbor 离线包的地址：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases/tag/">https://github.com/goharbor/harbor/releases/tag/</a></p>
<p>解压：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@harbor install]# tar zxvf harbor-offline-installer-v2.3.0-rc3.tgz</span><br><span class="line">[root@harbor install]# cd harbor</span><br><span class="line">[root@harbor harbor]# cp harbor.yml.tmpl harbor.yml</span><br><span class="line">[root@harbor harbor]# vim harbor.yml</span><br></pre></td></tr></table></figure>

<p>修改配置文件：</p>
<p>hostname: harbor</p>
<p>#修改 hostname，跟上面签发的证书域名保持一致</p>
<p>#协议用 https</p>
<p>certificate: /data/ssl/harbor.pem</p>
<p>private_key: /data/ssl/harbor.key</p>
<p>邮件和 ldap 不需要配置，在 harbor 的 web 界面可以配置</p>
<p>其他配置采用默认即可</p>
<p>修改之后保存退出</p>
<p>注：harbor 默认的账号密码：admin/Harbor12345</p>
<p>安装 docker-compose</p>
<p>上传课件里的 docker-compose-Linux-x86_64 文件到 harbor 机器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@harbor harbor]# mv docker-compose-Linux-x86_64.64 /usr/bin/docker-compose</span><br><span class="line">[root@harbor harbor]# chmod +x /usr/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>注： docker-compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。</p>
<p>Docker-Compose 的工程配置文件默认为 docker-compose.yml，Docker-Compose 运行目录下的必要有一个</p>
<p>docker-compose.yml。docker-compose 可以管理多个 docker 实例。</p>
<p>安装 harbor 需要的离线镜像包 docker-harbor-2-3-0.tar.gz 在课件，可上传到 harbor 机器，通过</p>
<p>docker load -i 解压</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@harbor install]# docker load -i docker-harbor-2-3-0.tar.gz </span><br><span class="line">[root@harbor install]# cd /data/install/harbor</span><br><span class="line">[root@harbor harbor]# ./install.sh</span><br></pre></td></tr></table></figure>

<p>看到下面内容，说明安装成功：</p>
<p>[Step 5]: starting Harbor …</p>
<p>Creating network “harbor_harbor” with the default driver</p>
<p>Creating harbor-log … done</p>
<p>Creating registryctl … done</p>
<p>Creating harbor-db … done</p>
<p>Creating redis … done</p>
<p>Creating registry … done</p>
<p>Creating harbor-portal … done</p>
<p>Creating harbor-core … done</p>
<p>Creating harbor-jobservice … done</p>
<p>Creating nginx … done</p>
<p>✔ —-Harbor has been installed and started successfully.—-</p>
<p>在自己电脑修改 hosts 文件</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175412377.png" alt="image-20220501175412377"></p>
<p>在 hosts 文件添加如下一行，然后保存即可</p>
<p>192.168.40.181 harbor</p>
<p>扩展：</p>
<p>如何停掉 harbor：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@harbor harbor]# cd /data/install/harbor</span><br><span class="line">[root@harbor harbor]# docker-compose stop </span><br></pre></td></tr></table></figure>

<p>如何启动 harbor：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@harbor harbor]# cd /data/install/harbor</span><br><span class="line">[root@harbor harbor]# docker-compose start</span><br></pre></td></tr></table></figure>

<p>如果 docker-compose start 启动 harbor 之后，还是访问不了，那就需要重启虚拟机韩先超老师微信：luckylucky421302</p>
<h3 id="18-3-Harbor-图像化界面使用说明"><a href="#18-3-Harbor-图像化界面使用说明" class="headerlink" title="18.3 Harbor 图像化界面使用说明"></a>18.3 Harbor 图像化界面使用说明</h3><p>在浏览器输入：</p>
<p><a target="_blank" rel="noopener" href="https://harbor/">https://harbor</a></p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175432123.png" alt="image-20220501175432123"></p>
<p>接收风险并继续，出现如下界面，说明访问正常</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175536173.png" alt="image-20220501175536173"></p>
<p>账号：admin</p>
<p>密码：Harbor12345</p>
<p>输入账号密码出现如下：</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175549974.png" alt="image-20220501175549974"></p>
<p>所有基础镜像都会放在 library 里面，这是一个公开的镜像仓库</p>
<p>新建项目-&gt;起个项目名字 test（把访问级别公开那个选中，让项目才可以被公开使用）</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175617949.png" alt="image-20220501175617949"></p>
<p>版权声明，本文档全部内容及版权归韩先超所有，只可用于自己学习使用，禁止私自传阅，违者依法</p>
<p>追责。韩先超老师微信：luckylucky421302</p>
<h3 id="18-4-测试使用-harbor-私有镜像仓库"><a href="#18-4-测试使用-harbor-私有镜像仓库" class="headerlink" title="18.4 测试使用 harbor 私有镜像仓库"></a>18.4 测试使用 harbor 私有镜像仓库</h3><p>#修改 docker 配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123; &quot;registry-mirrors&quot;: [&quot;https://rsbud4vc.mirror.aliyuncs.com&quot;,&quot;https://registry.docker-cn.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;,&quot;https://dockerhub.azk8s.cn&quot;,&quot;http://hub-mirror.c.163.com&quot;],</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;192.168.40.181&quot;,&quot;harbor&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置之后使配置生效：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# systemctl daemon-reload &amp;&amp; systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>#查看 docker 是否启动成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# systemctl status docker</span><br></pre></td></tr></table></figure>

<p>#显示如下，说明启动成功：</p>
<p>Active: active (running) since Fri … ago</p>
<p>注意：</p>
<p>配置新增加了一行内容如下：</p>
<p>“insecure-registries”:[“192.168.40.181”], </p>
<p>上面增加的内容表示我们内网访问 harbor 的时候走的是 http，192.168.40.181 是安装 harbor 机器</p>
<p>的 ip</p>
<p>登录 harbor：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@xianchaomaster1]# </span><span class="language-bash">docker login 192.168.40.181</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Username：admin</p>
<p>Password: Harbor12345</p>
<p>输入账号密码之后看到如下，说明登录成功了：</p>
<p>Login Succeeded</p>
<p>#导入 tomcat 镜像，tomcat.tar.gz 在课件里</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker load -i tomcat.tar.gz</span><br></pre></td></tr></table></figure>

<p>#把 tomcat 镜像打标签</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker tag tomcat:latest 192.168.40.181/test/tomcat:v1</span><br></pre></td></tr></table></figure>

<p>执行上面命令就会把 192.168.40.181/test/tomcat:v1 上传到 harbor 里的 test 项目下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker push 192.168.40.181/test/tomcat:v1</span><br></pre></td></tr></table></figure>

<p>执行上面命令就会把 192.168.40.181/test/tomcat:v1 上传到 harbor 里的 test 项目下</p>
<p><img src="https://raw.githubusercontent.com/gtdong/images/main/blogimage-20220501175642680.png" alt="image-20220501175642680"></p>
<h3 id="18-5-从-harbor-仓库下载镜像"><a href="#18-5-从-harbor-仓库下载镜像" class="headerlink" title="18.5 从 harbor 仓库下载镜像"></a>18.5 从 harbor 仓库下载镜像</h3><p>在 xianchaomaster1 机器上删除镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]# docker rmi -f 192.168.40.181/test/tomcat:v1</span><br></pre></td></tr></table></figure>

<p>拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xianchaomaster1 ~]#docker pull 192.168.40.181/test/tomcat:v1</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer"><div class="post-widgets">
      <div id="needsharebutton-postbottom">
        <span class="btn">
          <i class="fa fa-share-alt" aria-hidden="true"></i>
        </span>
      </div>
    </div>
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpeg" alt="Michaeldong 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpeg" alt="Michaeldong 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/K8s/" rel="tag"># K8s</a>
              <a href="/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" rel="tag"># 云原生</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/01/Go-4.%E6%A1%86%E6%9E%B6/" rel="prev" title="Go-框架">
                  <i class="fa fa-chevron-left"></i> Go-框架
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Michaeldong</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.2m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:06</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="chatra" type="application/json">{"enable":true,"async":true,"id":"9D92XKxDbxTrStQPr"}</script>
<script src="/js/third-party/chat/chatra.js"></script>
<script async src="https://call.chatra.io/chatra.js"></script>





  





  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script>
  <script>
      pbOptions = {};
        pbOptions.iconStyle = "box";
        pbOptions.boxForm = "horizontal";
        pbOptions.position = "bottomCenter";
        pbOptions.networks = "Wechat,QQZone,Weibo,Douban,Twitter,Facebook";
      new needShareButton('#needsharebutton-postbottom', pbOptions);
  </script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":200,"height":300,"vOffset":300},"mobile":{"show":true},"dialog":{"enable":true,"hitokoto":true}});</script></body>
</html>
